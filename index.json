let articleIndex=[{body:"Terasic DE10-NanoにTVM VTAのRPC Serverを導入したので作業メモ。\nDE10-Nanoセットアップに従う\n必要なもの  DE10-Nano microSDカード  8GB以上推奨、microSDXC非対応な気がするので注意   microUSBケーブル  シリアル通信に必要   LANケーブル  ネットワークに繋ぐのに必要    DE10-Nanoのセットアップ まずはTerasicのページからAngstrom Linuxイメージをダウンロードする。\n de10-nano-image-Angstrom-v2016.12.socfpga-sdimg.2017.03.31.tgz  ダウンロードしたファイルをmicroSDに書き込む。Win32DiskImagerを使用。\nDE10-Nanoに電源ケーブルを接続、microSDをDE10-Nanoに挿入、microUSBケーブルでDE10-NanoとPCを接続する。\nPC上でターミナルエミュレータでDE10-Nanoに接続する。TeraTermを使用。\nユーザ名：root、パスワードなしでログインする。\n以降はDE10-Nano上で実行する。\nパッケージ導入 システムパッケージをアップデートし、必要なパッケージを導入する。\n1 2 3  opkg update opkg upgrade opkg install cmake coreutils   Python導入 Angstrom Linuxに入っているPythonは古すぎるので、Pythonソースビルドする。\nソースコードをダウンロードし、ビルド、インストールする。\n1 2 3 4 5 6 7 8  mkdir ~/workspace cd ~/workspace curl -O https://www.python.org/ftp/python/3.8.8/Python-3.8.8.tgz tar xvf Python-3.8.8.tgz cd Python-3.8.8 ./configure make make install   python、python3コマンドのシンボリックリンクを導入したPythonに置き換える。\n1 2 3 4  rm /usr/bin/python ln -s /usr/local/bin/python3.8 /usr/bin/python rm /usr/bin/python3 ln -s /usr/local/bin/python3.8 /usr/bin/python3   pipを最新バージョンに更新する。\n1  /usr/local/bin/python3 -m pip install --upgrade pip   Git導入 Angstrom Linuxから導入できるGitはバージョンが古いので、これもソースビルドする。\n1 2 3 4 5 6 7 8  opkg install tcl gettext perl-module-pod-man cd ~/workspace git clone https://github.com/git/git cd git make configure ./configure --prefix=/usr make all make install   TVMのRPC Serverをビルド TVMの\n1 2 3 4 5 6 7 8 9 10 11 12  cd ~/workspace git clone --recursive https://github.com/apache/tvm tvm cd tvm mkdir build cp cmake/config.cmake build echo \u0026#39;set(USE_VTA_FPGA ON)\u0026#39; \u0026gt;\u0026gt; build/config.cmake cp 3rdparty/vta-hw/config/de10nano_sample.json 3rdparty/vta-hw/config/vta_config.json cd build cmake .. make clean make runtime vta -j2 pip3 install numpy   TVMのRPC Serverを起動する。\n1 2  cd ~/workspace/tvm ./apps/vta_rpc/start_rpc_server.sh   ホストPCとの通信に必要になるため、ipコマンドなどでDE10-NanoのIPアドレスをメモしておく。\n以下のような出力であればOK。\n1  INFO:root:RPCServer: bind to 0.0.0.0:9091   動作確認 RPCサーバーの動作確認をする。以下はホストPCで実行する。\nRPC ServerのIPアドレスとポート番号を環境変数に設定する。\n1 2  export VTA_RPC_HOST=192.168.10.110 export VTA_RPC_PORT=9091   テストスクリプトを実行する。\n1 2 3 4  cd ~/workspace/tvm cp 3rdparty/vta-hw/config/de10nano_sample.json 3rdparty/vta-hw/config/vta_config.json python vta/tests/python/de10nano/test_program_rpc.py python vta/tests/python/integration/test_benchmark_topi_conv2d.py   ホストPCでは以下のような標準出力。途中からエラーを吐いているが、とりあえず動いてそう。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49  Conv2DWorkload(batch=1, height=56, width=56, in_filter=64, out_filter=64, hkernel=3, wkernel=3, hpad=1, wpad=1, hstride=1, wstride=1) CPU CONV2D TEST PASSED: Time cost = 0.201243 sec/op, 1.14892 GOPS Conv2DWorkload(batch=1, height=56, width=56, in_filter=64, out_filter=128, hkernel=3, wkernel=3, hpad=1, wpad=1, hstride=2, wstride=2) CPU CONV2D TEST PASSED: Time cost = 0.0930569 sec/op, 1.24231 GOPS Conv2DWorkload(batch=1, height=56, width=56, in_filter=64, out_filter=128, hkernel=1, wkernel=1, hpad=0, wpad=0, hstride=2, wstride=2) CPU CONV2D TEST PASSED: Time cost = 0.0126302 sec/op, 1.01701 GOPS Conv2DWorkload(batch=1, height=28, width=28, in_filter=128, out_filter=128, hkernel=3, wkernel=3, hpad=1, wpad=1, hstride=1, wstride=1) CPU CONV2D TEST PASSED: Time cost = 0.194179 sec/op, 1.19071 GOPS Conv2DWorkload(batch=1, height=28, width=28, in_filter=128, out_filter=256, hkernel=3, wkernel=3, hpad=1, wpad=1, hstride=2, wstride=2) CPU CONV2D TEST PASSED: Time cost = 0.0934884 sec/op, 1.23658 GOPS Conv2DWorkload(batch=1, height=28, width=28, in_filter=128, out_filter=256, hkernel=1, wkernel=1, hpad=0, wpad=0, hstride=2, wstride=2) CPU CONV2D TEST PASSED: Time cost = 0.0121611 sec/op, 1.05624 GOPS Conv2DWorkload(batch=1, height=14, width=14, in_filter=256, out_filter=256, hkernel=3, wkernel=3, hpad=1, wpad=1, hstride=1, wstride=1) CPU CONV2D TEST PASSED: Time cost = 0.186729 sec/op, 1.23822 GOPS Conv2DWorkload(batch=1, height=14, width=14, in_filter=256, out_filter=512, hkernel=3, wkernel=3, hpad=1, wpad=1, hstride=2, wstride=2) CPU CONV2D TEST PASSED: Time cost = 0.11122 sec/op, 1.03943 GOPS Conv2DWorkload(batch=1, height=14, width=14, in_filter=256, out_filter=512, hkernel=1, wkernel=1, hpad=0, wpad=0, hstride=2, wstride=2) CPU CONV2D TEST PASSED: Time cost = 0.0136669 sec/op, 0.939866 GOPS Conv2DWorkload(batch=1, height=7, width=7, in_filter=512, out_filter=512, hkernel=3, wkernel=3, hpad=1, wpad=1, hstride=1, wstride=1) CPU CONV2D TEST PASSED: Time cost = 0.223079 sec/op, 1.03645 GOPS Conv2DWorkload(batch=1, height=56, width=56, in_filter=64, out_filter=64, hkernel=3, wkernel=3, hpad=1, wpad=1, hstride=1, wstride=1) Traceback (most recent call last): File \u0026#34;vta/tests/python/integration/test_benchmark_topi_conv2d.py\u0026#34;, line 311, in \u0026lt;module\u0026gt; test_conv2d(device=\u0026#34;vta\u0026#34;) File \u0026#34;vta/tests/python/integration/test_benchmark_topi_conv2d.py\u0026#34;, line 306, in test_conv2d vta.testing.run(_run) File \u0026#34;/home/ubuntu/workspace/tvm/vta/python/vta/testing/utils.py\u0026#34;, line 74, in run run_func(env, remote) File \u0026#34;vta/tests/python/integration/test_benchmark_topi_conv2d.py\u0026#34;, line 304, in _run run_conv2d(env, remote, wl, target) File \u0026#34;vta/tests/python/integration/test_benchmark_topi_conv2d.py\u0026#34;, line 234, in run_conv2d data_arr = tvm.nd.array(data_np, ctx) File \u0026#34;/home/ubuntu/workspace/tvm/python/tvm/runtime/ndarray.py\u0026#34;, line 518, in array return empty(arr.shape, arr.dtype, ctx).copyfrom(arr) File \u0026#34;/home/ubuntu/workspace/tvm/python/tvm/runtime/ndarray.py\u0026#34;, line 292, in empty arr = _ffi_api.TVMArrayAllocWithScope(shape_ptr, ndim, dtype, ctx, mem_scope) File \u0026#34;tvm/_ffi/_cython/./packed_func.pxi\u0026#34;, line 322, in tvm._ffi._cy3.core.PackedFuncBase._call_ File \u0026#34;tvm/_ffi/_cython/./packed_func.pxi\u0026#34;, line 267, in tvm._ffi._cy3.core.FuncCall File \u0026#34;tvm/_ffi/_cython/./base.pxi\u0026#34;, line 160, in tvm._ffi._cy3.core.CALL tvm.error.RPCError: Traceback (most recent call last): \\[bt\\] (8) /home/ubuntu/workspace/tvm/build/libtvm.so(tvm::runtime::NDArray::Empty(std::vector\u0026lt;long, std::allocator\u0026lt;long\u0026gt; \u0026gt;, DLDataType, DLContext, tvm::runtime::Optional\u0026lt;tvm::runtime::String\u0026gt;)+0x124) \\[0x7f1a9ab04024\\] \\[bt\\] (7) /home/ubuntu/workspace/tvm/build/libtvm.so(tvm::runtime::RPCDeviceAPI::AllocDataSpace(DLContext, int, long const\\*, DLDataType, tvm::runtime::Optional\u0026lt;tvm::runtime::String\u0026gt;)+0x89) \\[0x7f1a9ab30c59\\] \\[bt\\] (6) /home/ubuntu/workspace/tvm/build/libtvm.so(tvm::runtime::RPCClientSession::AllocDataSpace(DLContext, int, long const\\*, DLDataType, tvm::runtime::Optional\u0026lt;tvm::runtime::String\u0026gt;)+0x155) \\[0x7f1a9ab3ad45\\] \\[bt\\] (5) /home/ubuntu/workspace/tvm/build/libtvm.so(+0x164fc14) \\[0x7f1a9ab34c14\\] \\[bt\\] (4) /home/ubuntu/workspace/tvm/build/libtvm.so(tvm::runtime::RPCEndpoint::HandleUntilReturnEvent(bool, std::function\u0026lt;void (tvm::runtime::TVMArgs)\u0026gt;)+0x37b) \\[0x7f1a9ab31a5b\\] \\[bt\\] (3) /home/ubuntu/workspace/tvm/build/libtvm.so(tvm::runtime::RPCEndpoint::EventHandler::HandleNextEvent(bool, bool, std::function\u0026lt;void (tvm::runtime::TVMArgs)\u0026gt;)+0x1b8) \\[0x7f1a9ab35238\\] \\[bt\\] (2) /home/ubuntu/workspace/tvm/build/libtvm.so(tvm::runtime::RPCEndpoint::EventHandler::HandleProcessPacket(std::function\u0026lt;void (tvm::runtime::TVMArgs)\u0026gt;)+0xe7) \\[0x7f1a9ab362b7\\] \\[bt\\] (1) /home/ubuntu/workspace/tvm/build/libtvm.so(tvm::runtime::RPCEndpoint::EventHandler::HandleReturn(tvm::runtime::RPCCode, std::function\u0026lt;void (tvm::runtime::TVMArgs)\u0026gt;)+0xc9) \\[0x7f1a9ab38029\\] \\[bt\\] (0) /home/ubuntu/workspace/tvm/build/libtvm.so(dmlc::LogMessageFatal::~LogMessageFatal()+0x6c) \\[0x7f1a99beb06c\\]   DE10-Nanoでは以下のような標準出力。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32  INFO:root:Loading VTA library: /home/root/workspace/tvm/vta/python/vta/../../../build/libvta.so INFO:RPCServer:load_module /tmp/tmpjpvsqhpe/conv2d.o INFO:root:Loading VTA library: /home/root/workspace/tvm/vta/python/vta/../../../build/libvta.so INFO:root:Loading VTA library: /home/root/workspace/tvm/vta/python/vta/../../../build/libvta.so INFO:root:Loading VTA library: /home/root/workspace/tvm/vta/python/vta/../../../build/libvta.so ・・・省略・・・ INFO:root:Loading VTA library: /home/root/workspace/tvm/vta/python/vta/../../../build/libvta.so Process Process-1:2: Traceback (most recent call last): File \u0026#34;/usr/local/lib/python3.8/multiprocessing/process.py\u0026#34;, line 315, in _bootstrap self.run() File \u0026#34;/usr/local/lib/python3.8/multiprocessing/process.py\u0026#34;, line 108, in run self._target(\\*self._args, \\*\\*self._kwargs) File \u0026#34;/home/root/workspace/tvm/python/tvm/rpc/server.py\u0026#34;, line 118, in _serve_loop _ffi_api.ServerLoop(sockfd) File \u0026#34;/home/root/workspace/tvm/python/tvm/_ffi/_ctypes/packed_func.py\u0026#34;, line 237, in _call_ raise get_last_ffi_error() AttributeError: Traceback (most recent call last): 4: TVMFuncCall 3: std::_Function_handler\u0026lt;void (tvm::runtime::TVMArgs, tvm::runtime::TVMRetValue\\*), tvm::runtime::{lambda(tvm::runtime::TVMArgs, tvm::runtime::TVMRetValue\\*)#2}\u0026gt;::_M_invoke(std::_Any_data const\u0026amp;, tvm::runtime::TVMArgs\u0026amp;\u0026amp;, tvm::runtime::TVMRetValue\\*\u0026amp;\u0026amp;)  2: tvm::runtime::RPCServerLoop(int) 1: tvm::runtime::RPCEndpoint::ServerLoop() 0: std::_Function_handler\u0026lt;void (tvm::runtime::TVMArgs, tvm::runtime::TVMRetValue\\*), TVMFuncCreateFromCFunc::{lambda(tvm::runtime::TVMArgs, tvm::runtime::TVMRetValue\\*)#2}\u0026gt;::_M_invoke(std::_Any_data const\u0026amp;, tvm::runtime::TVMArgs\u0026amp;\u0026amp;, tvm::runtime::TVMRetValue\\*\u0026amp;\u0026amp;)  File \u0026#34;/home/root/workspace/tvm/python/tvm/_ffi/_ctypes/packed_func.py\u0026#34;, line 81, in cfun rv = local_pyfunc(\\*pyargs) File \u0026#34;/home/root/workspace/tvm/vta/python/vta/exec/rpc_server.py\u0026#34;, line 84, in server_shutdown runtime_dll\\[0\\].VTARuntimeShutdown() File \u0026#34;/usr/local/lib/python3.8/ctypes/_init_.py\u0026#34;, line 386, in _getattr_ func = self._getitem_(name) File \u0026#34;/usr/local/lib/python3.8/ctypes/_init_.py\u0026#34;, line 391, in _getitem_ func = self._FuncPtr((name_or_ordinal, self)) AttributeError: /home/root/workspace/tvm/vta/python/vta/../../../build/libvta.so: undefined symbol: VTARuntimeShutdown   ",date:"2021-04-12 Mon",permalink:"https://mshr-h.com/posts/tvm-vta-for-de10-nano/",title:"DE10-NanoにTVM VTAのRPC Serverを導入する"},{body:"今週の振り返り。\n英語  今週も毎日受けた  しかしあんまり成長を感じれてない    Machine learning / Cloud computing  DE10-NanoにUbuntu 20.04を導入しようとしたが動かない  https://www.digikey.com/eewiki/display/linuxonarm/DE10-Nano+Kit 以前入れたAngstrom Linuxも起動しなくなったので、ボードの設定がおかしくなってるのかも    Rock climbing  新たなV17課題 \u0026ldquo;Return of the Sleepwalker (V17)\u0026ldquo;ができたらしい  初登者のDaniel Woodsのインタビュー記事    その他トピック  Obsidian使い始めた  Notion+Dynalistで運用していたNote-takingをObsidianに移行するつもり 日々のTodolist管理にNotionは重過ぎるため、Dynalistを併用していたが、使い分けが面倒になったためいろいろ探したところ、Obsidianが良さそうだったので選択 データ自体はただのMarkdownファイルなので、データをローカルにおいて社外秘データを扱うこともできる Notionに1500件ぐらいあるWebclipをどうするかは別途検討する  そのまま残しておくかも   有料プランは、月$5のSyncを契約 One time paymentで$50のObsidian Catalyst SUPPORTERを購入し、限定公開中のiOSアプリをTestflightから導入して使っている    ",date:"2021-04-11 Sun",permalink:"https://mshr-h.com/posts/weekly-report-2021-04-11/",title:"Weekly Report(2021/04/11)"},{body:"今週の振り返り。\n英語  今週は7回レッスンを受けた  満足   感情を表す語彙力が少なく、いい相づちを打てなくてモヤモヤする  \u0026ldquo;That\u0026rsquo;s nice\u0026rdquo;、\u0026ldquo;Sounds good\u0026quot;などは出てくるが、バリエーションが少ない   Whyに対して答えるとき、返答に時間がかかる時がある  結局何が言いたいかまとまらない   英会話力を上達するには、「言いたいことを事前に文章に落とす→英会話の場で使ってみる」を繰り返すのが近道なのでは、ということに気づいた  Machine learning / Cloud computing  TVMのビルドで、LLVMをstatic linkしたほうが良さそう  cmakeのconfig時に、USE_LLVM(\u0026quot;llvm-config --link-static\u0026quot;)を指定すればstatic linkされる    Rock climbing  MoonBoardのBenchmark V5~V7を触るなど 登っているとき小指が使えてないことに気付いた  なるべく中指、薬指、小指の3本で登るようにする   外岩行きたい  その他トピック  HPy - A better C API for Python  Python C APIの次世代版のようなもの debug modeが充実、universal binary(HPyでC拡張を実装すれば、同じバイナリをCPython、PyPy、GraalPythonなどロードできる)など    ",date:"2021-04-04 Sun",permalink:"https://mshr-h.com/posts/weekly-report-2021-04-04/",title:"Weekly Report(2021/04/04)"},{body:"今週の振り返り。\n英語  今週は4回レッスンを受けた  忙しくて毎日受けれず   会話トピックは先週と変わらず、趣味のロッククライミング、ゲーム、英語を勉強している理由など  Machine Learning  TVM VTAを触り始めた  DE10Nanoの環境構築したが、test_benchmark_topi_conv2d.pyが途中でエラー吐く   Gradient free optimizer  https://github.com/SimonBlanke/Gradient-Free-Optimizers 微分フリー最適化のPythonライブラリ 使いやすそう    Rock climbing  ホームジムのV6を触るなど 外岩も行きたい  4月中に何回か行きたい    その他トピック  Docker for M1 Mac RC Architecture Decision Records(ADR)  ソフトウェアアーキテクチャの重要な決定を背景・結果とともに記録する手法 いくつかやり方があるみたいだが、共通しているのは「バージョン管理する」、「ソースコードとともに管理する(adr/のようなディレクトリに保管)」、「1つの決定ごとに対して1つのファイル」 ADR Tools  ADRのためのコマンドラインツール     ブログにSearchを追加した  Hugoのビルド時に全記事のインデックスを作成し、検索時にインデックス内の記事1つ1つに対して検索ワードでString.prototype.match()する単純なやり方 記事数が少ないので、このやり方問題ない 検索結果の表示をもうちょっと見やすくしたい    ",date:"2021-03-28 Sun",permalink:"https://mshr-h.com/posts/weekly-report-2021-03-28/",title:"Weekly Report(2021/03/28)"},{body:"今週の振り返り。\n英語  DMM英会話をはじめて10日経った  DMM英会話にした理由は、無料特典でiKnow!が使えるから   トータルで200分のレッスンを受講した  すべてfree conversationで、自己紹介、ロッククライミング、ゲーム、なぜ英語を勉強しているか、今まで行ったことのある旅行先などを話した   industrial engineer歴30年の講師と話したときは、PLCとかprogrammingの話題で盛り上がった  自動化ゲームの「Factorio」を紹介したら興味持ってくれたみたいで嬉しい    Machine Learning  TVM VTAを触り始めた  といってもチュートリアルをPC上で動かしただけ DE10Nanoを持ってるので、環境構築して実機で動かしたい   Courseraの機械学習コース受講を始めた  \u0026ldquo;Machine Learning\u0026rdquo; \u0026ldquo;Introduction to Embedded Machine Learning\u0026rdquo;    Rock climbing  MoonBoardのV8~V9を触り始めた  打ち込めばできそうなやつを見つけたので、頑張りたい 翌日の疲労感にかなり差がある  V7以下を触った翌日とは比べ物にならないぐらい筋肉痛が来てる     外岩も行きたい  4月中に何回か行きたい    その他トピック  Efficient Processing of Deep Neural Networks  面白そう   コンピュータアーキテクチャのエッセンス［第2版］  コンピュータアーキテクチャの再勉強に良さそう   M1 MacBook Air 13\u0026quot;を使い始めて4か月経った  電池持ちと発熱の少なさは非常に良い  とはいえTVMビルドすると少し暖かくなる   Python周りの環境構築は、いまだに何が正解か理解していない  brew install python@3.9で構築した環境を使ってる      ",date:"2021-03-21 Sun",permalink:"https://mshr-h.com/posts/weekly-report-2021-03-21/",title:"Weekly Report(2021/03/21)"},{body:"2020年10月、ONNX-MLIRという機械学習コンパイラ（ONNXモデルを実行可能バイナリへ変換するツール）に macOSのCI設定を追加するPRを送り、マージされました。 本記事では、このPRを作成してからマージされるまでの試行錯誤を紹介します。\n経緯 OSS機械学習コンパイラの調査の一環でONNX-MLIRを見つけ、開発用PC(macOS; MacBook Pro 13\u0026quot;)に導入していました。 リポジトリ内を見ていたところ、x86-Linux、s390-Linux、x86-WindowsのCIは走っていますが、どうやらmacOSのCIはないみたいでした。 Issueに「macOS向けCIパイプラインを追加しようと思ってるけどどう？」と聞いてみたところ、 メンテナの一人から是非やってやって欲しい旨のコメントがあり、作業に着手しました。\nCIサービスの選定 GitHubをサポートしているCIサービスはいくつかありますが、メンテナからはTravis CIでやって欲しいとの要望があったため、 Travis CI向けの調査に着手しました。\nONNX-MLIRでは、ビルドにDockerを使っています。 単一のDockerイメージでビルドするのではなく、以下のようにビルドを2段階に分ける構成とすることで、 依存ライブラリのビルド成果物を再利用可能となり、ビルド時間の短縮を実現しています。\n 依存ライブラリをビルドするDockerイメージ  llvm/mlirが一番大きな依存ライブラリで、ビルドに1時間程度かかる 依存ライブラリの更新時にビルドされる   上記でビルドした生成物を使ってONNX-MLIR本体をビルドするDockerイメージ  このイメージはTravis-CI実行時に毎回ビルドされる    Travis CIとDockerのmacOSサポート状況を調査したところ、\n DockerはゲストOSとしてのmacOSをサポートしていない（多分） Travis CIのmacOS環境はDockerをサポートしていない（Using Docker in Builds）  ため、Travis CIは使えないと判断しました。\nただ、実現したいことは「キャッシュ機構による高速化」であることは分かった、代替案の調査に着手しました。\n別のCIサービスとしてGitHub Actionsを調査したところ、キャッシュ機構(actions/cache@v2)をサポートしており、これを提案しようと考えました。 （今考えると、Travis CIのキャッシュ機構を使えば同じことができますね。。。）\nしかし、GitHub Actionsのキャッシュ機構は以下の制約があるとわかりました。\n 7日間以上アクセスのないキャッシュエントリは削除される リポジトリ全体でキャッシュサイズの上限が5GB  上記の制約があるが、GitHub Actionsは使えそうとのことをメンテナに相談したところ、 1.の制約は問題なく、2.が大丈夫ならGitHub Actionsを使おうとのコメントをもらいました。 というわけで、キャッシュ対象のファイルサイズの調査をします。\nactions/cache@v2調査 キャッシュ対象のファイルサイズの調査の前に、どのようにキャッシュされているか知るためにactions/cache@v2を調査します。 GitHub Actionsは、リポジトリ全体でキャッシュサイズの上限が5GBという制約があります。 実はこのサイズは、キャッシュ対象の圧縮後のサイズを指しています。（公式ドキュメントには記載がなく、ソースコードを読むとわかりました）\n以下のようにコードを読んでいくと、キャッシュ対象はGzip or zstdで圧縮されることがわかります。\n キャッシュ保存時に呼ばれるメソッドはsaveCache()を呼び出しています。  https://github.com/actions/cache/blob/releases/v2/src/save.ts#L40    1  await cache.saveCache(cachePaths, primaryKey);    中ではcreateTar()を呼び出しています。  https://github.com/actions/toolkit/blob/main/packages/cache/src/cache.ts#L136-L189    1 2 3 4 5  const compressionMethod = await utils.getCompressionMethod() ・・・省略・・・ await createTar(archiveFolder, cachePaths, compressionMethod)    createTar()呼び出し時の引数compressionMethodは、getCompressionMethod()で決めています。  https://github.com/actions/toolkit/blob/main/packages/cache/src/internal/cacheUtils.ts#L86-L106    1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21  // Use zstandard if possible to maximize cache performance export async function getCompressionMethod(): Promise\u0026lt;CompressionMethod\u0026gt; { if (process.platform === \u0026#39;win32\u0026#39; \u0026amp;\u0026amp; !(await isGnuTarInstalled())) { // Disable zstd due to bug https://github.com/actions/cache/issues/301  return CompressionMethod.Gzip } const versionOutput = await getVersion(\u0026#39;zstd\u0026#39;) const version = semver.clean(versionOutput) if (!versionOutput.toLowerCase().includes(\u0026#39;zstd command line interface\u0026#39;)) { // zstd is not installed  return CompressionMethod.Gzip } else if (!version || semver.lt(version, \u0026#39;v1.3.2\u0026#39;)) { // zstd is installed but using a version earlier than v1.3.2  // v1.3.2 is required to use the `--long` options in zstd  return CompressionMethod.ZstdWithoutLong } else { return CompressionMethod.Zstd } }    圧縮オプションはcreateTar()で決めています。  https://github.com/actions/toolkit/blob/main/packages/cache/src/internal/tar.ts#L86-L126    1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21  function getCompressionProgram(): string[] { switch (compressionMethod) { case CompressionMethod.Zstd: return [\u0026#39;--use-compress-program\u0026#39;, \u0026#39;zstd -T0 --long=30\u0026#39;] case CompressionMethod.ZstdWithoutLong: return [\u0026#39;--use-compress-program\u0026#39;, \u0026#39;zstd -T0\u0026#39;] default: return [\u0026#39;-z\u0026#39;] } } const args = [ \u0026#39;--posix\u0026#39;, ...getCompressionProgram(), \u0026#39;-cf\u0026#39;, cacheFileName.replace(new RegExp(`\\\\${path.sep}`, \u0026#39;g\u0026#39;), \u0026#39;/\u0026#39;), \u0026#39;-P\u0026#39;, \u0026#39;-C\u0026#39;, workingDirectory.replace(new RegExp(`\\\\${path.sep}`, \u0026#39;g\u0026#39;), \u0026#39;/\u0026#39;), \u0026#39;--files-from\u0026#39;, manifestFilename ]   というわけで、キャッシュ対象がキャッシュサイズ上限の5GBに収まるかを調べるには、 キャッシュ対象をGzipもしくはzstdで圧縮した後のサイズを見れば良いことがわかります。\nキャッシュサイズ調査 次に、キャッシュ対象が上限の5GBに収まるかを調査します。 macOSの場合はzstdを使うようなので、zstdによる圧縮した後のサイズを見ます。\nキャッシュサイズ調査を進めるにあたり、キャッシュ対象を考える必要があります。 ONNX-MLIRが依存するライブラリのうち一番大きいのはllvmのため、これを対象とします。 キャッシュの範囲としては、(1)ソースコードとビルド済みバイナリの両方を含める、(2)ビルド済みバイナリのみ、2パターンが考えられるため、それぞれの圧縮後のサイズを調査します。\nまたONNX-MLIRはビルドシステムとしてCMakeを使用しており、ビルド時のCMAKE_BUILD_TYPEオプションを指定することで、 適切なオプションを付けたビルドが可能です。 デフォルトではReleaseが指定されていますが、ビルド後のバイナリサイズを最小化するMinSizeRelを指定ことも可能です。\n以上より、キャッシュ範囲2パターン×CMAKE_BUILD_TYPEオプション2パターン=4パターンの圧縮後のサイズを調査しました。 以下の結果を見ると、どのパターンでも圧縮後のサイズは2GB以下であり、上限の5GB以下でした。\n   キャッシュ対象 CMAKE_BUILD_TYPE=Release CMAKE_BUILD_TYPE=MinSizeRel     (1)ソースコードとビルド結済みバイナリの両方 1814 MB 1658 MB   (2)ビルド済みバイナリのみ 629 MB 681 MB    そのため、デフォルトのビルドオプションに一番近い、かつ、キャッシュ対象が一番広い 「(1)ソースコードとビルド済みバイナリの両方かつ、CMAKE_BUILD_TYPE=Release」を採用することとします。\nワークフローの設計 GitHub Actionsでは、実行する処理とその処理の実行条件を定義したものをワークフローと呼び、YAML形式で記述します。 今回のワークフローは以下としました。\n Pythonバージョン  Python 3.7.8を使用  actions/pythonの制約で3.7.0が指定できないため     ビルド手順  公式が提供するビルドスクリプト群を使用   キャッシュ対象  llvmのソースコードとビルド済みバイナリの両方 キャッシュキーはclone-milr.shとbuild-mlir.shの中身    クローンしたリポジトリでこのワークフローをテスト実行したところ、問題なく完了しました。 複数回実行してキャッシュの効果を確認したところ、キャッシュにより7倍の高速化を確認しました。\n キャッシュミス：1h 12m 0s キャッシュヒット：12m 37s  PR提出 細かな修正をワークフローに加えて、PRを提出しました。\nメンテナ側でテストしたところ、キャッシュの保管が失敗した際に、キャッシュキーが予約状態のままワークフローが終了してしまう問題が起きました。 対策として、actions/cacheのIssueで紹介されていたキャッシュキーを手動で書き換えるワークアラウンドを適用し、問題が解決されました。\nメンテナ側のテストでOKとなり、PRがマージされました。\nおわりに 本記事では、ONNX-MLIRにmacOSのCI設定を追加した際の試行錯誤を紹介しました。 OSSメンテナとコミュニケーションを取りながらPRを作成し、無事にマージされました。 この体験は非常に楽しく、自身のモチベーションが上がるものでした。 今後も継続してOSSへ貢献していきたいです。\n",date:"2021-03-13 Sat",permalink:"https://mshr-h.com/posts/how-i-added-macos-ci-support-to-onnx-mlir/",title:"ONNX-MLIRにmacOSのCI設定を追加したときの試行錯誤メモ"},{body:' Search  Results:    function search(){ let query = document.getElementById("query").value; let results = articleIndex.filter(article = article.body.match(query)); let ul = document.getElementById("search-result"); ul.innerHTML = ""; for(let i = 0; i ',date:"2021-02-23 Tue",permalink:"https://mshr-h.com/search/",title:"Search"},{body:"はてブの検索結果をRSSリーダーで取得したい場合、検索結果のURLに\u0026amp;mode=rssを追加したURLを登録する。\n例えば、キーワード「pybind11」の検索結果URLは以下。\n https://b.hatena.ne.jp/search/text?q=pybind11  この検索結果をRSSリーダーで読みたい場合、\u0026amp;mode=rssを追加した以下のURLを登録する。\n https://b.hatena.ne.jp/search/text?q=pybind11\u0026amp;mode=rss  ",date:"2021-02-20 Sat",permalink:"https://mshr-h.com/posts/hatebu-rss-feed/",title:"はてブ検索結果をRSSで取得する"},{body:"Windows環境で使っている開発向けツール。\nリスト  Windows Subsystem for Linux  WindowsでLinuxを動かす互換レイヤ。   Windows Terminal  モダンなターミナル。   Visual Studio Code  コードエディタ。   QuickLook  エクスプローラでファイルを選択中にスペースキーを押す、プレビューを表示してくれるツール。   WinMerge  ファイル/フォルダの比較ツール。   WinDbg  デバッグツール。   winget  パッケージマネージャー。   Everything  検索ツール。    ",date:"2021-02-06 Sat",permalink:"https://mshr-h.com/posts/windows-development-tools/",title:"Windowsで使ってる開発向けツール"},{body:"振り返ってみた。昨年版は以下。\n 2019年にお金を払ったサービス  新規 Dynalist Pro 年額47.94ドル。年末セールで半額だった。Notionで管理していたTodoをDynalistに移行。リッチコンテンツは記述できないがこっちのほうが動作が軽い。\niCloud 50GB 月額130円。macOS Big Surアップデート直後しばらくと、M1 MacBook AirでGoogle Driveのクライアントソフトが動かなかった(2021/1には解決済み)ので、契約。 音楽ファイルを保管し、M1 MacBook Air→iPhoneへ同期のために使用。\niKnow 3ヶ月3920円。英単語の勉強のために契約。ほぼ毎日続いている。DMM英会話の有料会員はiKnow無料なので、近いうちにDMM英会話を契約したい。\nブログのドメイン 年額10ドル。Vercelで契約。\nセブン-イレブンで入る自転車保険 年額3990円。自転車を購入したので保険を契約。支払い金額と賠償保険金で選んだ。\n継続 Amazon Prime 年額4320円。お急ぎ便とプライムビデオがメイン。継続だが、Amazon Prime契約からAmazonマスターカードゴールドを作成し、カードの特典に乗り換えた。\nMoneyForward ME プレミアム 年額5300円。クレジットカード、銀行口座、証券口座、電子マネー、ポイント、通販サイトを登録してお金の出入を管理している。\nRebuild.fm 年額60ドル。サポーターフィードなら配信後すぐに聞けるので重宝している。\nNotion 年額48ドル。Todo、個人ORK、ウェブクリッパーなどを管理するために契約。\nGoogle One 2TB 月額1100円。PCのバックアップ先として契約。Web上から契約すると1300円だが、iOSのGoogle Driveアプリから契約するとなぜか1100円で契約できる。\nYoutube Premium 月額1180円。モバイルアプリでのオフライン視聴、広告なし視聴のために契約。広告がない世界は本当に最高。\n解約 なし。\n",date:"2021-01-16 Sat",permalink:"https://mshr-h.com/posts/list-of-subscription-in-2020/",title:"2020年にお金を払ったサービス"},{body:"TOEIC S\u0026amp;W公式テストを初めて受けたので受験記録をメモ。\n事前準備 公式を含むWeb記事を参照し、出題形式を確認。\n TOEIC SWって？やるべき勉強法・参考書やスコアまで徹底解剖 - Langoo ENGLISH BLOG TOEIC S\u0026amp;Wテストとは：概要と勉強法・試験対策 | 旺文社 英語の友 TOEIC SWテストのスピーキングパート対策の全て〜必勝回答テンプレート付き〜 | EIGOHERO | 社会人・出世する為の英語勉強術 TOEIC SWライティングを時間内に解答するためのテンプレートと対策法 | 4skills  結果  Speaking：130/200 Writing：160/200  感想とか 事前に出題形式を把握したのは良かった。やってなかったらテンパってたと思う。\nUnit 8のEメール作成は、GitHubのIssue書いてれば自然とできるようになりそう。 Unit 9の意見記述は、300ワード以上書くことが推奨されているが、普段そんなに英語を書かないので練習が必要。\n今後も定期的に受けて英語力の把握に使っていきたい。\n",date:"2021-01-16 Sat",permalink:"https://mshr-h.com/posts/toeic-sw-test/",title:"TOEIC S\u0026W受験記録(2020/8)"},{body:"CAUTION 少し古い情報(2020/9頃)のため、2021/01/16時点では不要な情報の可能性が高いが、記録のために残しておく。\nビルド 1 2  sudo apt-get update sudo apt-get install -y python3 python3-dev python3-setuptools gcc libtinfo-dev zlib1g-dev build-essential cmake libedit-dev libxml2-dev ninja-build   1 2 3  cd ~/workspace git clone https://github.com/llvm/llvm-project.git cd llvm-project \u0026amp;\u0026amp; git checkout llvmorg-10.0.1 \u0026amp;\u0026amp; cd ..   TVMとONNX-MLIRを共存するために、ONNX-MLIRが依存するLLVM@1d01fc(未リリースのバージョン)を使ってTVMをビルドすると、ビルドエラーが発生する。(後述)\n1 2 3 4 5  cd ~/workspace git clone --recursive https://github.com/apache/incubator-tvm tvm mkdir build cp cmake/config.cmake build cd build   1  vim config.cmake   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259  # Licensed to the Apache Software Foundation (ASF) under one # or more contributor license agreements. See the NOTICE file # distributed with this work for additional information # regarding copyright ownership. The ASF licenses this file # to you under the Apache License, Version 2.0 (the # \u0026#34;License\u0026#34;); you may not use this file except in compliance # with the License. You may obtain a copy of the License at # # http://www.apache.org/licenses/LICENSE-2.0 # # Unless required by applicable law or agreed to in writing, # software distributed under the License is distributed on an # \u0026#34;AS IS\u0026#34; BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY # KIND, either express or implied. See the License for the # specific language governing permissions and limitations # under the License. #-------------------------------------------------------------------- # Template custom cmake configuration for compiling # # This file is used to override the build options in build. # If you want to change the configuration, please use the following # steps. Assume you are on the root directory. First copy the this # file so that any local changes will be ignored by git # # $ mkdir build # $ cp cmake/config.cmake build # # Next modify the according entries, and then compile by # # $ cd build # $ cmake .. # # Then build in parallel with 8 threads # # $ make -j8 #-------------------------------------------------------------------- #--------------------------------------------- # Backend runtimes. #--------------------------------------------- # Whether enable CUDA during compile, # # Possible values: # - ON: enable CUDA with cmake\u0026#39;s auto search # - OFF: disable CUDA # - /path/to/cuda: use specific path to cuda toolkit set(USE_CUDA OFF) # Whether enable ROCM runtime # # Possible values: # - ON: enable ROCM with cmake\u0026#39;s auto search # - OFF: disable ROCM # - /path/to/rocm: use specific path to rocm set(USE_ROCM OFF) # Whether enable SDAccel runtime set(USE_SDACCEL OFF) # Whether enable Intel FPGA SDK for OpenCL (AOCL) runtime set(USE_AOCL OFF) # Whether enable OpenCL runtime # # Possible values: # - ON: enable OpenCL with cmake\u0026#39;s auto search # - OFF: disable OpenCL # - /path/to/opencl-sdk: use specific path to opencl-sdk set(USE_OPENCL OFF) # Whether enable Metal runtime set(USE_METAL OFF) # Whether enable Vulkan runtime # # Possible values: # - ON: enable Vulkan with cmake\u0026#39;s auto search # - OFF: disable vulkan # - /path/to/vulkan-sdk: use specific path to vulkan-sdk set(USE_VULKAN OFF) # Whether enable OpenGL runtime set(USE_OPENGL OFF) # Whether enable MicroTVM runtime set(USE_MICRO ON) # Whether to enable SGX runtime # # Possible values for USE_SGX: # - /path/to/sgxsdk: path to Intel SGX SDK # - OFF: disable SGX # # SGX_MODE := HW|SIM set(USE_SGX OFF) set(SGX_MODE \u0026#34;SIM\u0026#34;) set(RUST_SGX_SDK \u0026#34;/path/to/rust-sgx-sdk\u0026#34;) # Whether enable RPC runtime set(USE_RPC ON) # Whether to build the C++ RPC server binary set(USE_CPP_RPC ON) # Whether embed stackvm into the runtime set(USE_STACKVM_RUNTIME OFF) # Whether enable tiny embedded graph runtime. set(USE_GRAPH_RUNTIME ON) # Whether enable additional graph debug functions set(USE_GRAPH_RUNTIME_DEBUG ON) # Whether enable additional vm profiler functions set(USE_VM_PROFILER ON) # Whether enable uTVM standalone runtime set(USE_MICRO_STANDALONE_RUNTIME ON) # Whether build with LLVM support # Requires LLVM version \u0026gt;= 4.0 # # Possible values: # - ON: enable llvm with cmake\u0026#39;s find search # - OFF: disable llvm # - /path/to/llvm-config: enable specific LLVM when multiple llvm-dev is available. set(USE_LLVM /home/ubuntu/workspace/llvm-project/build/bin/llvm-config) #--------------------------------------------- # Contrib libraries #--------------------------------------------- # Whether use BLAS, choices: openblas, atlas, apple set(USE_BLAS none) # Whether to use MKL # Possible values: # - ON: Enable MKL # - /path/to/mkl: mkl root path # - OFF: Disable MKL # set(USE_MKL /opt/intel/mkl) for UNIX # set(USE_MKL ../IntelSWTools/compilers_and_libraries_2018/windows/mkl) for WIN32 # set(USE_MKL \u0026lt;path to venv or site-packages directory\u0026gt;) if using `pip install mkl` set(USE_MKL OFF) # Whether use MKLDNN library, choices: ON, OFF, path to mkldnn library set(USE_MKLDNN OFF) # Whether use OpenMP thread pool, choices: gnu, intel # Note: \u0026#34;gnu\u0026#34; uses gomp library, \u0026#34;intel\u0026#34; uses iomp5 library set(USE_OPENMP none) # Whether use contrib.random in runtime set(USE_RANDOM ON) # Whether use NNPack set(USE_NNPACK OFF) # Possible values: # - ON: enable tflite with cmake\u0026#39;s find search # - OFF: disable tflite # - /path/to/libtensorflow-lite.a: use specific path to tensorflow lite library set(USE_TFLITE OFF) # /path/to/tensorflow: tensorflow root path when use tflite library set(USE_TENSORFLOW_PATH none) # Required for full builds with TFLite. Not needed for runtime with TFLite. # /path/to/flatbuffers: flatbuffers root path when using tflite library set(USE_FLATBUFFERS_PATH none) # Possible values: # - OFF: disable tflite support for edgetpu # - /path/to/edgetpu: use specific path to edgetpu library set(USE_EDGETPU OFF) # Whether use CuDNN set(USE_CUDNN OFF) # Whether use cuBLAS set(USE_CUBLAS OFF) # Whether use MIOpen set(USE_MIOPEN OFF) # Whether use MPS set(USE_MPS OFF) # Whether use rocBlas set(USE_ROCBLAS OFF) # Whether use contrib sort set(USE_SORT ON) # Whether use MKL-DNN (DNNL) codegen set(USE_DNNL_CODEGEN OFF) # Whether to use Arm Compute Library (ACL) codegen # We provide 2 separate flags since we cannot build the ACL runtime on x86. # This is useful for cases where you want to cross-compile a relay graph # on x86 then run on AArch. # # An example of how to use this can be found here: docs/deploy/arm_compute_lib.rst. # # USE_ARM_COMPUTE_LIB - Support for compiling a relay graph offloading supported # operators to Arm Compute Library. OFF/ON # USE_ARM_COMPUTE_LIB_GRAPH_RUNTIME - Run Arm Compute Library annotated functions via the ACL # runtime. OFF/ON/\u0026#34;path/to/ACL\u0026#34; set(USE_ARM_COMPUTE_LIB OFF) set(USE_ARM_COMPUTE_LIB_GRAPH_RUNTIME OFF) # Whether to build with Arm Ethos-N support # Possible values: # - OFF: disable Arm Ethos-N support # - path/to/arm-ethos-N-stack: use a specific version of the # Ethos-N driver stack set(USE_ETHOSN OFF) # If USE_ETHOSN is enabled, use ETHOSN_HW (ON) if Ethos-N hardware is available on this machine # otherwise use ETHOSN_HW (OFF) to use the software test infrastructure set(USE_ETHOSN_HW OFF) # Build ANTLR parser for Relay text format # Possible values: # - ON: enable ANTLR by searching default locations (cmake find_program for antlr4 and /usr/local for jar) # - OFF: disable ANTLR # - /path/to/antlr-*-complete.jar: path to specific ANTLR jar file set(USE_ANTLR OFF) # Whether use Relay debug mode set(USE_RELAY_DEBUG ON) # Whether to build fast VTA simulator driver set(USE_VTA_FSIM OFF) # Whether to build cycle-accurate VTA simulator driver set(USE_VTA_TSIM OFF) # Whether to build VTA FPGA driver (device side only) set(USE_VTA_FPGA OFF) # Whether use Thrust set(USE_THRUST OFF) # Whether to build the TensorFlow TVMDSOOp module set(USE_TF_TVMDSOOP OFF) # Whether to use STL\u0026#39;s std::unordered_map or TVM\u0026#39;s POD compatible Map set(USE_FALLBACK_STL_MAP OFF) # Whether to use hexagon device set(USE_HEXAGON_DEVICE OFF) set(USE_HEXAGON_SDK /path/to/sdk) # Whether to use ONNX codegen set(USE_TARGET_ONNX ON) # Whether to compile the standalone C runtime. set(USE_STANDALONE_CRT ON)   1 2  cmake .. -G Ninja ninja   1 2  export TVM_HOME=/path/to/tvm export PYTHONPATH=$TVM_HOME/python:${PYTHONPATH}   ビルドエラーの詳細 LLVM@1d01fcを使用してTVMをビルドすると下記エラーが発生する。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20  [17/85] Building CXX object CMakeFiles/tvm_objs.dir/src/target/llvm/codegen_llvm.cc.o FAILED: CMakeFiles/tvm_objs.dir/src/target/llvm/codegen_llvm.cc.o /usr/bin/c++ -DBUILD_EXAMPLES -DDMLC_USE_FOPEN64=0 -DTVM_INDEX_DEFAULT_I64=1 -DTVM_LLVM_VERSION=120 -DTVM_THREADPOOL_USE_OPENMP=0 -DUSE_FALLBACK_STL_MAP=0 -DUSE_MICRO_STANDALONE_RUNTIME=1 -D_DEBUG -D_GNU_SOURCE -D__STDC_CONSTANT_MACROS -D__STDC_FORMAT_MACROS -D__STDC_LIMIT_MACROS -DDMLC_ENABLE_RTTI=0 -I../include -I../3rdparty/dlpack/include -I../3rdparty/dmlc-core/include -I../3rdparty/rang/include -I../3rdparty/compiler-rt -I../3rdparty/picojson -I/home/ubuntu/workspace/llvm-project/llvm/include -I/home/ubuntu/workspace/llvm-project/build/include -I../topi/include -std=c++14 -faligned-new -O2 -Wall -fPIC -fno-rtti -MD -MT CMakeFiles/tvm_objs.dir/src/target/llvm/codegen_llvm.cc.o -MF CMakeFiles/tvm_objs.dir/src/target/llvm/codegen_llvm.cc.o.d -o CMakeFiles/tvm_objs.dir/src/target/llvm/codegen_llvm.cc.o -c ../src/target/llvm/codegen_llvm.cc ../src/target/llvm/codegen_llvm.cc: In member function ‘llvm::Value* tvm::codegen::CodeGenLLVM::CreateBroadcast(llvm::Value*, int)’: ../src/target/llvm/codegen_llvm.cc:480:82: error: ‘llvm::ElementCount::ElementCount(unsigned int, bool)’ is private within this context 480 | llvm::ConstantVector::getSplat(llvm::ElementCount(lanes, /*Scalable=*/false), zero); | ^ In file included from /home/ubuntu/workspace/llvm-project/llvm/include/llvm/IR/Type.h:24, from /home/ubuntu/workspace/llvm-project/llvm/include/llvm/IR/DerivedTypes.h:23, from /home/ubuntu/workspace/llvm-project/llvm/include/llvm/IR/Constants.h:31, from /home/ubuntu/workspace/llvm-project/llvm/include/llvm/IR/Operator.h:19, from /home/ubuntu/workspace/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h:24, from ../src/target/llvm/llvm_common.h:33, from ../src/target/llvm/codegen_llvm.h:49, from ../src/target/llvm/codegen_llvm.cc:25: /home/ubuntu/workspace/llvm-project/llvm/include/llvm/Support/TypeSize.h:39:3: note: declared private here 39 | ElementCount(unsigned Min, bool Scalable) : Min(Min), Scalable(Scalable) {} | ^~~~~~~~~~~~ [22/85] Building CXX object CMakeFiles/tvm_objs.dir/src/runtime/rpc/rpc_endpoint.cc.o ninja: build stopped: subcommand failed.   エラーメッセージを読むと、privateメソッドとして定義されているllvm::ElementCount::ElementCount(unsigned int, bool)を クラス外から呼び出そうとしているのが原因。\n実際にLLVMのTypeSize.h@1d01fcを見ると、そのように定義されている。\n1 2 3 4 5 6 7 8 9 10 11 12  class ElementCount { private: unsigned Min; // Minimum number of vector elements.  bool Scalable; // If true, NumElements is a multiple of \u0026#39;Min\u0026#39; determined  // at runtime rather than compile time.  /// Prevent code from using initializer-list contructors like  /// ElementCount EC = {\u0026lt;unsigned\u0026gt;, \u0026lt;bool\u0026gt;}. The static `get*`  /// methods below are preferred, as users should always make a  /// conscious choice on the type of `ElementCount` they are  /// requesting.  ElementCount(unsigned Min, bool Scalable) : Min(Min), Scalable(Scalable) {}   コメントには、下記のgetスタティックメソッドを推奨する旨が書いているが、TVM側がこの変更に追いついてないためビルドエラーが発生した。\nTypeSize.h@1d01fc\n1 2 3  static ElementCount get(unsigned Min, bool Scalable) { return {Min, Scalable}; }   ElementCount(unsigned int, bool)のアクセス修飾子の変更経緯を追いかける。 b302561 (Oct 8, 2019, 9:53 PM GMT+9)で該当行を含むファイルが新規作成される。この時点でElementCount(unsigned Min, bool Scalable)はpublicメソッドとして定義されている。\nTypeSize.h@b302561\n1 2 3 4 5 6 7 8  class ElementCount { public: unsigned Min; // Minimum number of vector elements.  bool Scalable; // If true, NumElements is a multiple of \u0026#39;Min\u0026#39; determined  // at runtime rather than compile time.  ElementCount(unsigned Min, bool Scalable) : Min(Min), Scalable(Scalable) {}   a407ec (Aug 20, 2020, 2:26 AM GMT+9)でElementCount(unsigned Min, bool Scalable)がpublicからprivateへ変更される。(これが1d01fc時点のコード)\nTypeSize.h@a407ec\n1 2 3 4 5 6 7 8  class ElementCount { private: /// Prevent code from using initializer-list contructors like  /// ElementCount EC = {\u0026lt;unsigned\u0026gt;, \u0026lt;bool\u0026gt;}. The static `get*`  /// methods below are preferred, as users should always make a  /// conscious choice on the type of `ElementCount` they are  /// requesting.  ElementCount(unsigned Min, bool Scalable) : Min(Min), Scalable(Scalable) {}   llvmorg-10.0.1はb302561のコードを使用している(=publicメソッドとして定義されている)ため、問題なくビルドできる。\n",date:"2021-01-16 Sat",permalink:"https://mshr-h.com/posts/build-tvm/",title:"TVM v0.7ビルド手順"},{body:"とあるPythonパッケージが依存しているパッケージを表示するには、pipdeptreeが便利。 オプションの指定なしで実行すると、全パッケージの依存リストが表示される。 -p package_nameオプションで特定のパッケージに絞ることができる。\ntensorflowの依存一覧を表示する例 1  $ pipdeptree -p tensorflow   実行結果 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74  tensorflow==2.1.0 - absl-py [required: \u0026gt;=0.7.0, installed: 0.9.0] - six [required: Any, installed: 1.13.0] - astor [required: \u0026gt;=0.6.0, installed: 0.8.1] - gast [required: ==0.2.2, installed: 0.2.2] - google-pasta [required: \u0026gt;=0.1.6, installed: 0.1.8] - six [required: Any, installed: 1.13.0] - grpcio [required: \u0026gt;=1.8.6, installed: 1.26.0] - six [required: \u0026gt;=1.5.2, installed: 1.13.0] - keras-applications [required: \u0026gt;=1.0.8, installed: 1.0.8] - h5py [required: Any, installed: 2.10.0] - numpy [required: \u0026gt;=1.7, installed: 1.18.1] - six [required: Any, installed: 1.13.0] - numpy [required: \u0026gt;=1.9.1, installed: 1.18.1] - keras-preprocessing [required: \u0026gt;=1.1.0, installed: 1.1.0] - numpy [required: \u0026gt;=1.9.1, installed: 1.18.1] - six [required: \u0026gt;=1.9.0, installed: 1.13.0] - numpy [required: \u0026gt;=1.16.0,\u0026lt;2.0, installed: 1.18.1] - opt-einsum [required: \u0026gt;=2.3.2, installed: 3.1.0] - numpy [required: \u0026gt;=1.7, installed: 1.18.1] - protobuf [required: \u0026gt;=3.8.0, installed: 3.11.2] - setuptools [required: Any, installed: 41.2.0] - six [required: \u0026gt;=1.9, installed: 1.13.0] - scipy [required: ==1.4.1, installed: 1.4.1] - numpy [required: \u0026gt;=1.13.3, installed: 1.18.1] - six [required: \u0026gt;=1.12.0, installed: 1.13.0] - tensorboard [required: \u0026gt;=2.1.0,\u0026lt;2.2.0, installed: 2.1.0] - absl-py [required: \u0026gt;=0.4, installed: 0.9.0] - six [required: Any, installed: 1.13.0] - google-auth [required: \u0026gt;=1.6.3,\u0026lt;2, installed: 1.10.1] - cachetools [required: \u0026gt;=2.0.0,\u0026lt;5.0, installed: 4.0.0] - pyasn1-modules [required: \u0026gt;=0.2.1, installed: 0.2.8] - pyasn1 [required: \u0026gt;=0.4.6,\u0026lt;0.5.0, installed: 0.4.8] - rsa [required: \u0026gt;=3.1.4,\u0026lt;4.1, installed: 4.0] - pyasn1 [required: \u0026gt;=0.1.3, installed: 0.4.8] - setuptools [required: \u0026gt;=40.3.0, installed: 41.2.0] - six [required: \u0026gt;=1.9.0, installed: 1.13.0] - google-auth-oauthlib [required: \u0026gt;=0.4.1,\u0026lt;0.5, installed: 0.4.1] - google-auth [required: Any, installed: 1.10.1] - cachetools [required: \u0026gt;=2.0.0,\u0026lt;5.0, installed: 4.0.0] - pyasn1-modules [required: \u0026gt;=0.2.1, installed: 0.2.8] - pyasn1 [required: \u0026gt;=0.4.6,\u0026lt;0.5.0, installed: 0.4.8] - rsa [required: \u0026gt;=3.1.4,\u0026lt;4.1, installed: 4.0] - pyasn1 [required: \u0026gt;=0.1.3, installed: 0.4.8] - setuptools [required: \u0026gt;=40.3.0, installed: 41.2.0] - six [required: \u0026gt;=1.9.0, installed: 1.13.0] - requests-oauthlib [required: \u0026gt;=0.7.0, installed: 1.3.0] - oauthlib [required: \u0026gt;=3.0.0, installed: 3.1.0] - requests [required: \u0026gt;=2.0.0, installed: 2.22.0] - certifi [required: \u0026gt;=2017.4.17, installed: 2019.11.28] - chardet [required: \u0026gt;=3.0.2,\u0026lt;3.1.0, installed: 3.0.4] - idna [required: \u0026gt;=2.5,\u0026lt;2.9, installed: 2.8] - urllib3 [required: \u0026gt;=1.21.1,\u0026lt;1.26,!=1.25.1,!=1.25.0, installed: 1.25.7] - grpcio [required: \u0026gt;=1.24.3, installed: 1.26.0] - six [required: \u0026gt;=1.5.2, installed: 1.13.0] - markdown [required: \u0026gt;=2.6.8, installed: 3.1.1] - setuptools [required: \u0026gt;=36, installed: 41.2.0] - numpy [required: \u0026gt;=1.12.0, installed: 1.18.1] - protobuf [required: \u0026gt;=3.6.0, installed: 3.11.2] - setuptools [required: Any, installed: 41.2.0] - six [required: \u0026gt;=1.9, installed: 1.13.0] - requests [required: \u0026gt;=2.21.0,\u0026lt;3, installed: 2.22.0] - certifi [required: \u0026gt;=2017.4.17, installed: 2019.11.28] - chardet [required: \u0026gt;=3.0.2,\u0026lt;3.1.0, installed: 3.0.4] - idna [required: \u0026gt;=2.5,\u0026lt;2.9, installed: 2.8] - urllib3 [required: \u0026gt;=1.21.1,\u0026lt;1.26,!=1.25.1,!=1.25.0, installed: 1.25.7] - setuptools [required: \u0026gt;=41.0.0, installed: 41.2.0] - six [required: \u0026gt;=1.10.0, installed: 1.13.0] - werkzeug [required: \u0026gt;=0.11.15, installed: 0.16.0] - wheel [required: \u0026gt;=0.26, installed: 0.33.6] - tensorflow-estimator [required: \u0026gt;=2.1.0rc0,\u0026lt;2.2.0, installed: 2.1.0] - termcolor [required: \u0026gt;=1.1.0, installed: 1.1.0] - wheel [required: \u0026gt;=0.26, installed: 0.33.6] - wrapt [required: \u0026gt;=1.11.1, installed: 1.11.2]   ",date:"2020-09-21 Mon",permalink:"https://mshr-h.com/posts/pipdeptree/",title:"pipdeptreeでPythonパッケージの依存ツリーを見る"},{body:"pyenvとpyenv-virtualenvを導入する手順メモ。\n環境  Ubuntu 20.04 LTS  手順 1 2 3 4 5 6 7 8  sudo apt install -y build-essential libffi-dev libssl-dev zlib1g-dev liblzma-dev libbz2-dev libreadline-dev libsqlite3-dev git git clone https://github.com/pyenv/pyenv.git ~/.pyenv git clone https://github.com/pyenv/pyenv-virtualenv.git ~/.pyenv/plugins/pyenv-virtualenv echo \u0026#39;export PYENV_ROOT=\u0026#34;$HOME/.pyenv\u0026#34;\u0026#39; \u0026gt;\u0026gt; ~/.bashrc echo \u0026#39;export PATH=\u0026#34;$PYENV_ROOT/bin:$PATH\u0026#34;\u0026#39; \u0026gt;\u0026gt; ~/.bashrc echo \u0026#39;eval \u0026#34;$(pyenv init -)\u0026#34;\u0026#39; \u0026gt;\u0026gt; ~/.bashrc echo \u0026#39;eval \u0026#34;$(pyenv virtualenv-init -)\u0026#34;\u0026#39; \u0026gt;\u0026gt; ~/.bashrc source ~/.bashrc   Pythonインストール --enable-sharedオプションを付けて共有ライブラリをビルドする。\n1 2 3  env PYTHON_CONFIGURE_OPTS=\u0026#34;--enable-shared\u0026#34; pyenv install 3.8.5 pyenv virtualenv 3.8.5 env pyenv global env   ",date:"2020-09-19 Sat",permalink:"https://mshr-h.com/posts/setup-pyenv/",title:"pyenv導入手順メモ"},{body:"CIRCTに含まれるDialectとその変換パスを調査。 Dialectの変換はソースコードの以下に存在。\n lib/Conversion  Dialect一覧 CIRCTには以下のDialectが含まれている。\n FIRRTL Dialect RTL Dialect Handshake Dialect StaticLogic Dialect LLHD Dialect  その他、MLIRでデフォルトで定義されているDialectとして以下がある。\n Standard Dialect LLVM Dialect  Dialect変換パス   FIRRTLからVerilogを生成する流れは、\n FIR parserでFIRRTL Dialectへ変換し、 FIRRTL DialectからRTL Dialectへ変換、 最後にRTL DialectからVerilogコードを生成する  となっている。\n",date:"2020-08-08 Sat",permalink:"https://mshr-h.com/posts/circt-dialect/",title:"CIRCTのDialect調査"},{body:"MLIRでデフォルトで定義されているDialectとその変換パスを調査。 Dialectの変換はソースコードの以下に存在。\n mlir/lib/Conversion  Dialect一覧 MLIRには以下のDialectが含まれている。\n Affine Dialect AVX512 Dialect GPU Dialect Linalg Dialect LLVM Dialect NVVM Dialect ROCDL Dialect SCF Dialect Shape Dialect SPIRV Dialect Standard Dialect Vector Dialect Vulkan Dialect  Dialect変換パス   ",date:"2020-08-08 Sat",permalink:"https://mshr-h.com/posts/mlir-default-dialect/",title:"MLIRの標準Dialect調査"},{body:"ONNX MLIRに含まれるDialectとその変換パスを調査。 Dialectの変換はソースコードの以下に存在。\n src/Conversion  Dialect一覧 ONNX MLIRには以下のDialectが含まれている。\n ONNX Dialect Krnl Dialect Handshake Dialect StaticLogic Dialect LLHD Dialect  その他、MLIRでデフォルトで定義されているDialectとして以下がある。\n Affine Dialect Standard Dialect LLVM Dialect  Dialect変換パス   ONNXモデルをLLVM IRを生成する流れは、\n ONNX parserでONNXモデルからONNX Dialectへ変換し、 ONNX DialectからKrnl Dialectへ変換、 Krnl DialectからLLVM Dialectへ変換し、 最後にLLVM DialectからLLVM IRを生成する  ",date:"2020-08-08 Sat",permalink:"https://mshr-h.com/posts/onnx-mlir-dialect/",title:"ONNX MLIRのDialect調査"},{body:"CIRCT(Circuit IR Compilers and Tools)はMLIRベースのRTL生成ツール。 READMEにしたがってビルド、サンプル回路をコンパイルした。\n環境  Ryzen 5 1600 32GBメモリ Ubuntu 18.04 on WSL2 on Windows 10 作業ディレクトリは~/workspaceとする  ビルド 作業ディレクトリ(~/workspace)にリポジトリをクローンする。\n1 2  cd ~/workspace git clone --recursive https://github.com/llvm/circt.git   CIRCUITはMLIRベースに開発されているため、まずはMLIRをビルドする。\n1 2 3 4 5 6  cd circt mkdir llvm/build cd llvm/build cmake -G Ninja ../llvm -DLLVM_ENABLE_PROJECTS=\u0026#34;mlir\u0026#34; -DLLVM_TARGETS_TO_BUILD=\u0026#34;X86\u0026#34; -DLLVM_ENABLE_ASSERTIONS=ON -DCMAKE_BUILD_TYPE=Release ninja ninja check-mlir   続いてCIRCT本体をビルドする。\n1 2 3 4 5 6  cd ~/workspace/circt mkdir build cd build cmake -G Ninja .. -DMLIR_DIR=~/workspace/circt/llvm/build/lib/cmake/mlir -DLLVM_DIR=~/workspace/circt/llvm/build/lib/cmake/llvm -DLLVM_ENABLE_ASSERTIONS=ON -DCMAKE_BUILD_TYPE=Release ninja ninja check-circt   build/bin/にcircuit-translateとcircuit-optが生成されるので、環境変数パスにディレクトリを追加する。\n1  export PATH=~/workspace/circt/build/bin:$PATH   サンプル回路生成 サンプル入力ファイルのあるディレクトリに移動する。\n1  cd ~/workspace/circt/test/EmitVerilog   FIRRTLからVerilogへ変換 FIRRTL→Verilogへ変換する。\n1  circt-translate --parse-fir verilog-basic.fir | circt-translate -emit-verilog   出力は以下。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 346 347 348 349 350 351 352 353 354 355 356 357 358 359 360 361 362 363 364 365 366 367 368 369 370 371 372 373 374 375 376 377 378 379 380 381 382 383 384 385 386 387 388 389 390 391 392 393 394 395 396 397 398 399 400 401 402 403 404 405 406 407 408 409 410 411 412 413 414 415 416 417 418 419 420 421 422 423 424 425 426 427 428 429 430 431 432 433 434 435 436 437 438 439 440 441 442 443 444  // Standard header to adapt well known macros to our needs.\\n\u0026#34;; `ifdef RANDOMIZE_GARBAGE_ASSIGN `define RANDOMIZE `endif `ifdef RANDOMIZE_INVALID_ASSIGN `define RANDOMIZE `endif `ifdef RANDOMIZE_REG_INIT `define RANDOMIZE `endif `ifdef RANDOMIZE_MEM_INIT `define RANDOMIZE `endif `ifndef RANDOM `define RANDOM $random `endif // Users can define \u0026#39;PRINTF_COND\u0026#39; to add an extra gate to prints. `ifdef PRINTF_COND `define PRINTF_COND_ (`PRINTF_COND) `else `define PRINTF_COND_ 1 `endif // Users can define \u0026#39;STOP_COND\u0026#39; to add an extra gate to stop conditions. `ifdef STOP_COND `define STOP_COND_ (`STOP_COND) `else `define STOP_COND_ 1 `endif // Users can define INIT_RANDOM as general code that gets injected into the // initializer block for modules with registers. `ifndef INIT_RANDOM `define INIT_RANDOM `endif // If using random initialization, you can also define RANDOMIZE_DELAY to // customize the delay used, otherwise 0.002 is used. `ifndef RANDOMIZE_DELAY `define RANDOMIZE_DELAY 0.002 `endif // Define INIT_RANDOM_PROLOG_ for use in our modules below. `ifdef RANDOMIZE `ifndef VERILATOR `define INIT_RANDOM_PROLOG_ `INIT_RANDOM #`RANDOMIZE_DELAY begin end  `else `define INIT_RANDOM_PROLOG_ `INIT_RANDOM  `endif `else `define INIT_RANDOM_PROLOG_ `endif module inputs_only( input a, b); endmodule module no_ports(); wire [3:0] x; // \u0026lt;stdin\u0026gt;:8:12  endmodule module Expressions( input [3:0] in4, input clock, output out1, output [3:0] out4); wire [1:0] x1; // \u0026lt;stdin\u0026gt;:30:13  wire [1:0] x2; // \u0026lt;stdin\u0026gt;:35:13  wire [3:0] x3; // \u0026lt;stdin\u0026gt;:37:13  wire [3:0] x4; // \u0026lt;stdin\u0026gt;:40:13  wire [9:0] x5; // \u0026lt;stdin\u0026gt;:46:13  wire [8:0] x6; // \u0026lt;stdin\u0026gt;:50:13  wire [3:0] x7; // \u0026lt;stdin\u0026gt;:57:13  wire [3:0] x8; // \u0026lt;stdin\u0026gt;:62:13  wire [1:0] x9; // \u0026lt;stdin\u0026gt;:66:13  wire [3:0] x10; // \u0026lt;stdin\u0026gt;:69:14  wire [5:0] x11; // \u0026lt;stdin\u0026gt;:79:14  wire [3:0] x12; // \u0026lt;stdin\u0026gt;:81:14  assign out1 = ^in4; // \u0026lt;stdin\u0026gt;:12:12, :13:7  assign out1 = \u0026amp;in4; // \u0026lt;stdin\u0026gt;:14:12, :15:7  assign out1 = |in4; // \u0026lt;stdin\u0026gt;:16:12, :17:7  assign out1 = ~in4; // \u0026lt;stdin\u0026gt;:18:12, :19:7  assign out4 = in4 % 4\u0026#39;h1; // \u0026lt;stdin\u0026gt;:20:17, :21:12, :22:7  assign out1 = clock; // \u0026lt;stdin\u0026gt;:23:12, :24:7  assign out1 = 1\u0026#39;h1; // \u0026lt;stdin\u0026gt;:25:17, :26:12, :27:12, :28:7  assign x1 = in4[1:0]; // \u0026lt;stdin\u0026gt;:29:12, :30:13  assign x2 = in4[3:2] | {in4[2], 1\u0026#39;h0}; // \u0026lt;stdin\u0026gt;:31:12, :32:13, :33:13, :34:13, :35:13  assign x3 = in4 \u0026gt;\u0026gt;\u0026gt; in4; // \u0026lt;stdin\u0026gt;:36:13, :37:13  assign x4 = $signed(in4) \u0026gt;\u0026gt;\u0026gt; in4; // \u0026lt;stdin\u0026gt;:38:13, :39:13, :40:13  assign x5 = {in4, clock, clock, in4}; // \u0026lt;stdin\u0026gt;:45:13, :46:13  assign x6 = {1\u0026#39;b0, in4, in4}; // \u0026lt;stdin\u0026gt;:49:13, :50:13  assign x7 = clock ? (clock ? 4\u0026#39;h1 : 4\u0026#39;h2) : 4\u0026#39;h3; // \u0026lt;stdin\u0026gt;:20:17, :51:13, :52:13, :53:17, :54:13, :55:17, :56:13, :57:13  assign x8 = clock ? 4\u0026#39;h1 : clock ? 4\u0026#39;h2 : 4\u0026#39;h3; // \u0026lt;stdin\u0026gt;:20:17, :53:17, :55:17, :58:13, :59:13, :60:13, :61:13, :62:13  assign x9 = in4[3:2] | in4[1:0]; // \u0026lt;stdin\u0026gt;:63:13, :64:13, :65:13, :66:13  assign x10 = in4; // \u0026lt;stdin\u0026gt;:68:13, :69:14  assign x11 = { {2\u0026#39;d0}, in4} ^ {{2{in4[3]}}, in4} ^ {6{clock} }; // \u0026lt;stdin\u0026gt;:70:13, :71:13, :72:13, :73:13, :74:13, :75:13, :76:13, :77:13, :78:13, :79:14  assign x12 = in4; // \u0026lt;stdin\u0026gt;:80:13, :81:14 endmodule module Precedence( input [3:0] a, b, c, output out1, output [3:0] out); assign out = a + b + c; // \u0026lt;stdin\u0026gt;:84:12, :85:12, :86:7  assign out = a + b - c; // \u0026lt;stdin\u0026gt;:87:12, :88:12, :89:7  assign out = a - (b + c); // \u0026lt;stdin\u0026gt;:90:12, :91:12, :92:7  assign out = a + b * c; // \u0026lt;stdin\u0026gt;:93:12, :94:12, :95:7  assign out = a * b + c; // \u0026lt;stdin\u0026gt;:96:12, :97:12, :98:7  assign out = (a + b) * c; // \u0026lt;stdin\u0026gt;:99:13, 💯13, :101:7  assign out = a * (b + c); // \u0026lt;stdin\u0026gt;:102:13, :103:13, :104:7  assign out = (a + b) * (b + c); // \u0026lt;stdin\u0026gt;:105:13, :106:13, :107:13, :108:7  assign out1 = ^(b + c); // \u0026lt;stdin\u0026gt;:109:13, :110:13, :111:7  assign out1 = b \u0026lt; c | b \u0026gt; c; // \u0026lt;stdin\u0026gt;:112:13, :113:13, :114:13, :115:7  assign out1 = (b ^ c) \u0026amp; (out1 | out1); // \u0026lt;stdin\u0026gt;:116:13, :117:13, :118:13, :119:7  assign out1 = out[3:2]; // \u0026lt;stdin\u0026gt;:120:13, :121:7  assign out1 = out \u0026lt; a; // \u0026lt;stdin\u0026gt;:122:13, :123:7 endmodule module Sign( input [3:0] a, b, c, d, output out); assign out = a \u0026lt; b; // \u0026lt;stdin\u0026gt;:126:12, :127:7  assign out = $signed(c) \u0026lt; $signed(d); // \u0026lt;stdin\u0026gt;:128:12, :129:7  assign out = $signed(a) \u0026lt; $signed(b); // \u0026lt;stdin\u0026gt;:130:12, :131:12, :132:12, :133:7  assign out = a == b; // \u0026lt;stdin\u0026gt;:134:12, :135:12, :136:12, :137:7 endmodule module MultiUseExpr( input [3:0] a, output b); wire _T = \u0026amp;^a; // \u0026lt;stdin\u0026gt;:140:12, :141:12  wire [4:0] _T_0 = a + a; // \u0026lt;stdin\u0026gt;:142:12  assign b = \u0026amp;_T; // \u0026lt;stdin\u0026gt;:143:12, :144:7  assign b = ^_T; // \u0026lt;stdin\u0026gt;:145:12, :146:7  assign b = \u0026amp;_T_0; // \u0026lt;stdin\u0026gt;:147:12, :148:7  assign b = ^_T_0; // \u0026lt;stdin\u0026gt;:149:12, :150:7  assign b = ^(4\u0026#39;sh3 | 4\u0026#39;sh3); // \u0026lt;stdin\u0026gt;:151:17, :152:12, :153:12, :154:12, :155:7  wire [3:0] _T_1 = ~a; // \u0026lt;stdin\u0026gt;:156:13  assign b = _T_1[3:2]; // \u0026lt;stdin\u0026gt;:157:13, :158:7 endmodule module UseInstances( input [7:0] a_in, output a_out); wire [7:0] xyz_in; // \u0026lt;stdin\u0026gt;:163:14  wire xyz_out; // \u0026lt;stdin\u0026gt;:163:14  wire [7:0] xyz2_in; // \u0026lt;stdin\u0026gt;:168:15  wire xyz2_out; // \u0026lt;stdin\u0026gt;:168:15  FooExtModule xyz ( // \u0026lt;stdin\u0026gt;:163:14  .in(xyz_in), .out(xyz_out) ); assign xyz_in = a_in; // \u0026lt;stdin\u0026gt;:164:12, :165:7  assign a_out = xyz_out; // \u0026lt;stdin\u0026gt;:166:12, :167:7  MyParameterizedExtModule #(.DEFAULT(0), .DEPTH(3.500000e+00), .FORMAT(\u0026#34;xyz_timeout=%d\\n\u0026#34;), .WIDTH(32)) xyz2 ( // \u0026lt;stdin\u0026gt;:168:15  .in(xyz2_in), .out(xyz2_out) ); assign xyz2_in = a_in; // \u0026lt;stdin\u0026gt;:169:12, :170:7  assign a_out = xyz2_out; // \u0026lt;stdin\u0026gt;:171:12, :172:7 endmodule module Stop( input clock, reset); always @(posedge clock) begin `ifndef SYNTHESIS if (`STOP_COND_ \u0026amp;\u0026amp; reset) $fatal; // \u0026lt;stdin\u0026gt;:175:7  `endif end // always @(posedge) endmodule module Stop2( input clock, reset); always @(posedge clock) begin `ifndef SYNTHESIS if (`STOP_COND_ \u0026amp;\u0026amp; reset) begin $fatal; // \u0026lt;stdin\u0026gt;:178:7  $finish; // \u0026lt;stdin\u0026gt;:179:7  end `endif // !SYNTHESIS  end // always @(posedge) endmodule module Stop3( input clock1, clock2, reset); always @(posedge clock1) begin `ifndef SYNTHESIS if (`STOP_COND_ \u0026amp;\u0026amp; reset) $fatal; // \u0026lt;stdin\u0026gt;:182:7  `endif end // always @(posedge)  always @(posedge clock2) begin `ifndef SYNTHESIS if (`STOP_COND_ \u0026amp;\u0026amp; reset) $finish; // \u0026lt;stdin\u0026gt;:183:7  `endif end // always @(posedge) endmodule module Print( input clock, reset, input [3:0] a, b); always @(posedge clock) begin `ifndef SYNTHESIS if (`PRINTF_COND_ \u0026amp;\u0026amp; reset) $fwrite(32\u0026#39;h80000002, \u0026#34;Hi %x %x\\n\u0026#34;, a + a, b); // \u0026lt;stdin\u0026gt;:186:12, :187:7  `endif end // always @(posedge) endmodule module UninitReg1( input clock, reset, cond, input [1:0] value); reg [1:0] count; // \u0026lt;stdin\u0026gt;:191:16  wire [1:0] x; // \u0026lt;stdin\u0026gt;:192:12  assign x = count; // \u0026lt;stdin\u0026gt;:192:12  `ifndef SYNTHESIS initial begin `INIT_RANDOM_PROLOG_ `ifdef RANDOMIZE_REG_INIT count = `RANDOM; // \u0026lt;stdin\u0026gt;:191:16  `endif end // initial  `endif // SYNTHESIS  always @(posedge clock) begin count \u0026lt;= reset ? 2\u0026#39;h0 : cond ? value : count; // \u0026lt;stdin\u0026gt;:193:12, :194:17, :195:12, :196:7  end // always @(posedge) endmodule module InitReg1( input clock, reset, input [31:0] io_d, output [31:0] io_q, input io_en); reg [31:0] reg_0; // \u0026lt;stdin\u0026gt;:201:14  assign io_q = reg_0; // \u0026lt;stdin\u0026gt;:202:7  `ifndef SYNTHESIS initial begin `INIT_RANDOM_PROLOG_ if (reset) reg_0 = 32\u0026#39;h0; // \u0026lt;stdin\u0026gt;:199:12, :200:18, :201:14  `ifdef RANDOMIZE_REG_INIT if (~reset) reg_0 = `RANDOM; // \u0026lt;stdin\u0026gt;:199:12, :200:18, :201:14  `endif end // initial  `endif // SYNTHESIS  always @(posedge clock or posedge reset) begin reg_0 \u0026lt;= io_en ? io_d : reg_0; // \u0026lt;stdin\u0026gt;:199:12, :203:12, :204:7  end // always @(posedge) endmodule module Analog( output [4:0] io_pins_asrcn3v3); endmodule module MemSimple( input clock1, clock2, inpred, input [41:0] indata, output [41:0] result); wire [2:0] _M_read_addr; // \u0026lt;stdin\u0026gt;:209:13  wire _M_read_en; // \u0026lt;stdin\u0026gt;:209:13  wire _M_read_clk; // \u0026lt;stdin\u0026gt;:209:13  wire [41:0] _M_read_data; // \u0026lt;stdin\u0026gt;:209:13  wire [2:0] _M_write_addr; // \u0026lt;stdin\u0026gt;:209:13  wire _M_write_en; // \u0026lt;stdin\u0026gt;:209:13  wire _M_write_clk; // \u0026lt;stdin\u0026gt;:209:13  wire [41:0] _M_write_data; // \u0026lt;stdin\u0026gt;:209:13  wire _M_write_mask; // \u0026lt;stdin\u0026gt;:209:13  reg [41:0] _M[7:0]; assign _M_read_data = _M[_M_read_addr]; // \u0026lt;stdin\u0026gt;:209:13  assign result = _M_read_data; // \u0026lt;stdin\u0026gt;:210:12, :211:12, :212:7  assign _M_read_addr = 1\u0026#39;h0; // \u0026lt;stdin\u0026gt;:213:12, :214:12, :215:17, :216:7  assign _M_read_en = 1\u0026#39;h1; // \u0026lt;stdin\u0026gt;:217:12, :218:12, :219:17, :220:7  assign _M_read_clk = clock1; // \u0026lt;stdin\u0026gt;:221:12, :222:12, :223:7  assign _M_write_addr = 3\u0026#39;h0; // \u0026lt;stdin\u0026gt;:224:12, :225:12, :226:17, :227:13, :228:7  assign _M_write_en = inpred ? 1\u0026#39;h1 : 1\u0026#39;h0; // \u0026lt;stdin\u0026gt;:215:17, :219:17, :229:13, :230:13, :231:13, :232:7  assign _M_write_clk = clock2; // \u0026lt;stdin\u0026gt;:233:13, :234:13, :235:13, :236:7  assign _M_write_data = indata; // \u0026lt;stdin\u0026gt;:237:13, :238:13, :239:13, :240:7  assign _M_write_mask = 1\u0026#39;h1; // \u0026lt;stdin\u0026gt;:219:17, :241:13, :242:13, :243:13, :244:7  `ifndef SYNTHESIS initial begin `INIT_RANDOM_PROLOG_ `ifdef RANDOMIZE_MEM_INIT integer initvar; for (initvar = 0; initvar \u0026lt; 8; initvar = initvar+1) _M[initvar] = `RANDOM; // \u0026lt;stdin\u0026gt;:209:13  `endif // RANDOMIZE_MEM_INIT  end // initial  `endif // SYNTHESIS  always @(posedge _M_write_clk) begin if (_M_write_en \u0026amp; _M_write_mask) _M[_M_write_addr] \u0026lt;= _M_write_data; // \u0026lt;stdin\u0026gt;:209:13  end // always @(posedge) endmodule module MemAggregate( input clock1, clock2); wire [4:0] _M_read_addr; // \u0026lt;stdin\u0026gt;:247:13  wire _M_read_en; // \u0026lt;stdin\u0026gt;:247:13  wire _M_read_clk; // \u0026lt;stdin\u0026gt;:247:13  wire [3:0] _M_read_data_id; // \u0026lt;stdin\u0026gt;:247:13  wire [7:0] _M_read_data_other; // \u0026lt;stdin\u0026gt;:247:13  wire [4:0] _M_write_addr; // \u0026lt;stdin\u0026gt;:247:13  wire _M_write_en; // \u0026lt;stdin\u0026gt;:247:13  wire _M_write_clk; // \u0026lt;stdin\u0026gt;:247:13  wire [3:0] _M_write_data_id; // \u0026lt;stdin\u0026gt;:247:13  wire [7:0] _M_write_data_other; // \u0026lt;stdin\u0026gt;:247:13  wire _M_write_mask_id; // \u0026lt;stdin\u0026gt;:247:13  wire _M_write_mask_other; // \u0026lt;stdin\u0026gt;:247:13  reg [3:0] _M_id[19:0]; reg [7:0] _M_other[19:0]; `ifndef RANDOMIZE_GARBAGE_ASSIGN assign _M_read_data_id = _M_id[_M_read_addr]; // \u0026lt;stdin\u0026gt;:247:13  assign _M_read_data_other = _M_other[_M_read_addr]; // \u0026lt;stdin\u0026gt;:247:13  `else assign _M_read_data_id = _M_read_addr \u0026lt; 20 ? _M_id[_M_read_addr] : `RANDOM; // \u0026lt;stdin\u0026gt;:247:13  assign _M_read_data_other = _M_read_addr \u0026lt; 20 ? _M_other[_M_read_addr] : `RANDOM; // \u0026lt;stdin\u0026gt;:247:13  `endif // RANDOMIZE_GARBAGE_ASSIGN  `ifndef SYNTHESIS initial begin `INIT_RANDOM_PROLOG_ `ifdef RANDOMIZE_MEM_INIT integer initvar; for (initvar = 0; initvar \u0026lt; 20; initvar = initvar+1) begin _M_id[initvar] = `RANDOM; _M_other[initvar] = `RANDOM; end // \u0026lt;stdin\u0026gt;:247:13  `endif // RANDOMIZE_MEM_INIT  end // initial  `endif // SYNTHESIS  always @(posedge _M_write_clk) begin if (_M_write_en \u0026amp; _M_write_mask) begin _M_id[_M_write_addr] \u0026lt;= _M_write_data_id; // \u0026lt;stdin\u0026gt;:247:13  _M_other[_M_write_addr] \u0026lt;= _M_write_data_other; // \u0026lt;stdin\u0026gt;:247:13  end end // always @(posedge) endmodule module MemEmpty(); `ifndef SYNTHESIS initial begin `INIT_RANDOM_PROLOG_ `ifdef RANDOMIZE_MEM_INIT integer initvar; `endif end // initial  `endif // SYNTHESIS endmodule module MemOne(); wire _M_read_addr; // \u0026lt;stdin\u0026gt;:253:13  wire _M_read_en; // \u0026lt;stdin\u0026gt;:253:13  wire _M_read_clk; // \u0026lt;stdin\u0026gt;:253:13  wire [3:0] _M_read_data_id; // \u0026lt;stdin\u0026gt;:253:13  wire [7:0] _M_read_data_other; // \u0026lt;stdin\u0026gt;:253:13  wire _M_write_addr; // \u0026lt;stdin\u0026gt;:253:13  wire _M_write_en; // \u0026lt;stdin\u0026gt;:253:13  wire _M_write_clk; // \u0026lt;stdin\u0026gt;:253:13  wire [3:0] _M_write_data_id; // \u0026lt;stdin\u0026gt;:253:13  wire [7:0] _M_write_data_other; // \u0026lt;stdin\u0026gt;:253:13  wire _M_write_mask_id; // \u0026lt;stdin\u0026gt;:253:13  wire _M_write_mask_other; // \u0026lt;stdin\u0026gt;:253:13  reg [3:0] _M_id[0:0]; reg [7:0] _M_other[0:0]; assign _M_read_data_id = _M_id[_M_read_addr]; // \u0026lt;stdin\u0026gt;:253:13  assign _M_read_data_other = _M_other[_M_read_addr]; // \u0026lt;stdin\u0026gt;:253:13  `ifndef SYNTHESIS initial begin `INIT_RANDOM_PROLOG_ `ifdef RANDOMIZE_MEM_INIT _M_id[0] = `RANDOM; // \u0026lt;stdin\u0026gt;:253:13  _M_other[0] = `RANDOM; // \u0026lt;stdin\u0026gt;:253:13  `endif // RANDOMIZE_MEM_INIT  end // initial  `endif // SYNTHESIS  always @(posedge _M_write_clk) begin if (_M_write_en \u0026amp; _M_write_mask) begin _M_id[_M_write_addr] \u0026lt;= _M_write_data_id; // \u0026lt;stdin\u0026gt;:253:13  _M_other[_M_write_addr] \u0026lt;= _M_write_data_other; // \u0026lt;stdin\u0026gt;:253:13  end end // always @(posedge) endmodule module Attach( input a, b, c); `ifndef SYNTHESIS alias a = b = c; // \u0026lt;stdin\u0026gt;:256:7  `endif `ifdef SYNTHESIS assign a = b; // \u0026lt;stdin\u0026gt;:256:7  assign a = c; // \u0026lt;stdin\u0026gt;:256:7  assign b = a; // \u0026lt;stdin\u0026gt;:256:7  assign b = c; // \u0026lt;stdin\u0026gt;:256:7  assign c = a; // \u0026lt;stdin\u0026gt;:256:7  assign c = b; // \u0026lt;stdin\u0026gt;:256:7  `endif // SYNTHESIS endmodule module IsInvalid( output a); endmodule module Locations( input [3:0] a, output [3:0] b); assign b = a + a + 4\u0026#39;h3 ^ 4\u0026#39;h1; // \u0026lt;stdin\u0026gt;:262:12, :263:17, :264:12, :265:17, :266:12, :267:7  assign b = a * a * 4\u0026#39;h2 ^ 4\u0026#39;h0; // \u0026lt;stdin\u0026gt;:268:12, :269:17, :270:12, :271:17, :272:12, :273:7 endmodule   RTL DialectからVerilogへ変換 MLIRのDialectとして定義されたRTL DialectからVerilogへ変換する。\n1  circt-translate verilog-rtl-dialect.mlir --emit-verilog   出力は以下。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81  // Standard header to adapt well known macros to our needs.\\n\u0026#34;; `ifdef RANDOMIZE_GARBAGE_ASSIGN `define RANDOMIZE `endif `ifdef RANDOMIZE_INVALID_ASSIGN `define RANDOMIZE `endif `ifdef RANDOMIZE_REG_INIT `define RANDOMIZE `endif `ifdef RANDOMIZE_MEM_INIT `define RANDOMIZE `endif `ifndef RANDOM `define RANDOM $random `endif // Users can define \u0026#39;PRINTF_COND\u0026#39; to add an extra gate to prints. `ifdef PRINTF_COND `define PRINTF_COND_ (`PRINTF_COND) `else `define PRINTF_COND_ 1 `endif // Users can define \u0026#39;STOP_COND\u0026#39; to add an extra gate to stop conditions. `ifdef STOP_COND `define STOP_COND_ (`STOP_COND) `else `define STOP_COND_ 1 `endif // Users can define INIT_RANDOM as general code that gets injected into the // initializer block for modules with registers. `ifndef INIT_RANDOM `define INIT_RANDOM `endif // If using random initialization, you can also define RANDOMIZE_DELAY to // customize the delay used, otherwise 0.002 is used. `ifndef RANDOMIZE_DELAY `define RANDOMIZE_DELAY 0.002 `endif // Define INIT_RANDOM_PROLOG_ for use in our modules below. `ifdef RANDOMIZE `ifndef VERILATOR `define INIT_RANDOM_PROLOG_ `INIT_RANDOM #`RANDOMIZE_DELAY begin end  `else `define INIT_RANDOM_PROLOG_ `INIT_RANDOM  `endif `else `define INIT_RANDOM_PROLOG_ `endif module M1( input [7:0] x, output [7:0] y, input [7:0] z); assign y = (z + 8\u0026#39;h2A) * 8\u0026#39;h5; // verilog-rtl-dialect.mlir:7:12, :8:11, :9:10, :10:10, :11:10, :12:5  wire [7:0] _T = z * z * z; // verilog-rtl-dialect.mlir:14:10  assign y = {_T % 8\u0026#39;h5, z, _T}; // verilog-rtl-dialect.mlir:8:11, :15:10, :16:10, :17:10, :18:5 endmodule module M2( input [7:0] x, y, z); wire [7:0] foo; // verilog-rtl-dialect.mlir:38:11  assign x = 8\u0026#39;h2A; // verilog-rtl-dialect.mlir:35:12, :36:5  assign foo = y; // verilog-rtl-dialect.mlir:39:5  assign z = foo; // verilog-rtl-dialect.mlir:40:5 endmodule module M3( input [7:0] x, output [7:0] y, input [7:0] z, input [15:0] q); wire [7:0] _T = z + 8\u0026#39;h2A; // verilog-rtl-dialect.mlir:56:12, :59:10  wire [7:0] _T_0 = _T \u0026amp; 8\u0026#39;h2A \u0026amp; 8\u0026#39;h5; // verilog-rtl-dialect.mlir:56:12, :57:11, :60:11  assign y = _T_0 ^ (_T | _T_0) ^ 8\u0026#39;h2A ^ q[15:8]; // verilog-rtl-dialect.mlir:56:12, :58:14, :61:11, :62:11, :63:10, :64:5 endmodule   translateとoptのヘルプ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33  $ circt-translate -h OVERVIEW: CIRCT translation driver USAGE: circt-translate [options] \u0026lt;input file\u0026gt; OPTIONS: Color Options: --color - Use colors in output (default=autodetect) General options: --mlir-disable-threading - Disabling multi-threading within MLIR --mlir-elide-elementsattrs-if-larger=\u0026lt;uint\u0026gt; - Elide ElementsAttrs with \u0026#34;...\u0026#34; that have more elements than the given upper limit --mlir-pretty-debuginfo - Print pretty debug info in MLIR output --mlir-print-debuginfo - Print debug info in MLIR output --mlir-print-elementsattrs-with-hex-if-larger=\u0026lt;long\u0026gt; - Print DenseElementsAttrs with a hex string that have more elements than the given upper limit (use -1 to disable) --mlir-print-op-on-diagnostic - When a diagnostic is emitted on an operation, also print the operation as an attached note --mlir-print-stacktrace-on-diagnostic - When a diagnostic is emitted, also print the stack trace as an attached note -o=\u0026lt;filename\u0026gt; - Output filename Translation to perform --emit-verilog - emit-verilog --llhd-to-verilog - llhd-to-verilog --parse-fir - parse-fir --split-input-file - Split the input file into pieces and process each chunk independently --verify-diagnostics - Check that emitted diagnostics match expected-* lines on the corresponding line Generic Options: --help - Display available options (--help-hidden for more) --help-list - Display list of available options (--help-list-hidden for more) --version - Display the version of this program   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107  $ circt-opt -h OVERVIEW: circt modular optimizer driver USAGE: circt-opt [options] \u0026lt;input file\u0026gt; OPTIONS: Color Options: --color - Use colors in output (default=autodetect) General options: --allow-unregistered-dialect - Allow operation with no registered dialects --enable-name-compression - Enable name/filename string compression --mlir-disable-threading - Disabling multi-threading within MLIR --mlir-elide-elementsattrs-if-larger=\u0026lt;uint\u0026gt; - Elide ElementsAttrs with \u0026#34;...\u0026#34; that have more elements than the given upper limit --mlir-pretty-debuginfo - Print pretty debug info in MLIR output --mlir-print-debuginfo - Print debug info in MLIR output --mlir-print-elementsattrs-with-hex-if-larger=\u0026lt;long\u0026gt; - Print DenseElementsAttrs with a hex string that have more elements than the given upper limit (use -1 to disable) --mlir-print-op-on-diagnostic - When a diagnostic is emitted on an operation, also print the operation as an attached note --mlir-print-stacktrace-on-diagnostic - When a diagnostic is emitted, also print the stack trace as an attached note -o=\u0026lt;filename\u0026gt; - Output filename --pass-pipeline-crash-reproducer=\u0026lt;string\u0026gt; - Generate a .mlir reproducer file at the given output path if the pass manager crashes or fails --pass-pipeline-local-reproducer - When generating a crash reproducer, attempt to generated a reproducer with the smallest pipeline. --pass-statistics - Display the statistics of each pass --pass-statistics-display=\u0026lt;value\u0026gt; - Display method for pass statistics =list - display the results in a merged list sorted by pass name =pipeline - display the results with a nested pipeline view --pass-timing - Display the execution times of each pass --pass-timing-display=\u0026lt;value\u0026gt; - Display method for pass timing data =list - display the results in a list sorted by total time =pipeline - display the results with a nested pipeline view --print-ir-after - Print IR after specified passes --pass-pipeline - A textual description of a pass pipeline to run Passes: --analyze-dataflow - Print resource (operation) statistics --canonicalize - Canonicalize operations --canonicalize-dataflow - Canonicalize handshake IR --convert-llhd-to-llvm - Convert LLHD to LLVM --create-dataflow - Convert standard MLIR into dataflow IR --create-pipeline - Create StaticLogic pipeline operations. --cse - Eliminate common sub-expressions --handshake-insert-buffer - Insert buffers to break graph cycles. --inline - Inline function calls --disable-simplify - Disable running simplifications during inlining ---iterations=\u0026lt;uint\u0026gt; - Maximum number of iterations when inlining within an SCC --llhmaxd-early-code-motion - Move side-effect-free instructions and llhd.prb up in the CFG --llhd-function-elimination - Deletes all functions. --llhd-process-lowering - Lowers LLHD Processes to Entities. --lower-firrtl-to-rtl - Lower FIRRTL to RTL --lower-handshake-to-firrtl - Lowering to FIRRTL Dialect --remove-block-structure - Remove block structure in handshake IR --print-ir-after-all - Print IR after each pass --print-ir-after-change - When printing the IR after a pass, only print if the IR changed --print-ir-before - Print IR before specified passes --pass-pipeline - A textual description of a pass pipeline to run Passes: --analyze-dataflow - Print resource (operation) statistics --canonicalize - Canonicalize operations --canonicalize-dataflow - Canonicalize handshake IR --convert-llhd-to-llvm - Convert LLHD to LLVM --create-dataflow - Convert standard MLIR into dataflow IR --create-pipeline - Create StaticLogic pipeline operations. --cse - Eliminate common sub-expressions --handshake-insert-buffer - Insert buffers to break graph cycles. --inline - Inline function calls --disable-simplify - Disable running simplifications during inlining --max-iterations=\u0026lt;uint\u0026gt; - Maximum number of iterations when inlining within an SCC --llhd-early-code-motion - Move side-effect-free instructions and llhd.prb up in the CFG --llhd-function-elimination - Deletes all functions. --llhd-process-lowering - Lowers LLHD Processes to Entities. --lower-firrtl-to-rtl - Lower FIRRTL to RTL --lower-handshake-to-firrtl - Lowering to FIRRTL Dialect --remove-block-structure - Remove block structure in handshake IR --print-ir-before-all - Print IR before each pass --print-ir-module-scope - When printing IR for print-ir-[before|after]{-all} always print the top-level module operation Compiler passes to run --pass-pipeline - A textual description of a pass pipeline to run Passes: --analyze-dataflow - Print resource (operation) statistics --canonicalize - Canonicalize operations --canonicalize-dataflow - Canonicalize handshake IR --convert-llhd-to-llvm - Convert LLHD to LLVM --create-dataflow - Convert standard MLIR into dataflow IR --create-pipeline - Create StaticLogic pipeline operations. --cse - Eliminate common sub-expressions --handshake-insert-buffer - Insert buffers to break graph cycles. --inline - Inline function calls --disable-simplify - Disable running simplifications during inlining --max-iterations=\u0026lt;uint\u0026gt; - Maximum number of iterations when inlining within an SCC --llhd-early-code-motion - Move side-effect-free instructions and llhd.prb up in the CFG --llhd-function-elimination - Deletes all functions. --llhd-process-lowering - Lowers LLHD Processes to Entities. --lower-firrtl-to-rtl - Lower FIRRTL to RTL --lower-handshake-to-firrtl - Lowering to FIRRTL Dialect --remove-block-structure - Remove block structure in handshake IR --show-dialects - Print the list of registered dialects --split-input-file - Split the input file into pieces and process each chunk independently --verify-diagnostics - Check that emitted diagnostics match expected-* lines on the corresponding line --verify-each - Run the verifier after each transformation pass Generic Options: --help - Display available options (--help-hidden for more) --help-list - Display list of available options (--help-list-hidden for more) --version - Display the version of this program   ",date:"2020-08-07 Fri",permalink:"https://mshr-h.com/posts/build-circuit-ir-compiler/",title:"CIRCT(Circuit IR Compilers and Tools)をビルドする"},{body:"ONNX MLIRに付属のdebug.pyをベースに作成。 ONNX MLIRでONNXモデルファイルをshared libraryに変換し、PyRuntimeで実行する。\n以下はメモ。\n ExecutionSession(shared_lib_path, \u0026quot;_dyn_entry_point_main_graph\u0026quot;)は、第2引数にエントリポイントを指定している。 ExecutionSession\u0008.runでグラフを実行するときは、引数を辞書で与えなくていい  ONNX Runtimeだと{name: value}の辞書形式で与える必要がある    1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40  import os import sys import argparse import onnx import subprocess import numpy as np import tempfile from collections import OrderedDict ONNX_MLIR = os.path.join(os.environ[\u0026#39;ONNX_MLIR_HOME\u0026#39;], \u0026#34;bin/onnx-mlir\u0026#34;) RUNTIME_DIR = os.path.join(os.environ[\u0026#39;ONNX_MLIR_HOME\u0026#39;], \u0026#34;lib\u0026#34;) sys.path.append(RUNTIME_DIR) from PyRuntime import ExecutionSession def main(model_path): model = onnx.load(model_path) subprocess.run([ONNX_MLIR, model_path], stdout=subprocess.PIPE, check=True) shared_lib_path = os.path.splitext(os.path.basename(model_path))[0] + \u0026#34;.so\u0026#34; sess = ExecutionSession(shared_lib_path, \u0026#34;_dyn_entry_point_main_graph\u0026#34;) # calculate input shape shape_proto = model.graph.input[0].type.tensor_type.shape explicit_shape = [] for dim in shape_proto.dim: explicit_shape.append(dim.dim_value) # generate input value np.random.seed(42) inputs = np.random.uniform(-1.0, 1.0, explicit_shape).astype(np.float32) outs = sess.run(inputs) print(outs) if __name__ == \u0026#39;__main__\u0026#39;: parser = argparse.ArgumentParser() parser.add_argument(\u0026#39;model_path\u0026#39;, type=str, help=\u0026#34;Path to the model to debug.\u0026#34;) args = parser.parse_args() main(**vars(args))   ",date:"2020-08-06 Thu",permalink:"https://mshr-h.com/posts/run-onnx-mlir-shared-library/",title:"ONNX MLIRで出力したshared libraryを実行する"},{body:"ONNX MLIRに付属のdebug.pyを動かすで動かしたdebug.pyの中を見る。\ndebug.pyの処理内容 概要  入力として指定したONNXモデルを、ONNX MLIRでshared libraryとしてビルド、実行し、リファレンスバックエンドで実行した結果と比較する リファレンスバックエンドにはONNX Runtimeを使用 Operatorのoutputごとに比較  モデルの出力だけでなく、Operatorの実行結果単位で比較している   PyRuntimeはおそらく、ONNX MLIRでビルドしたshared libraryを、Pythonから実行するためのPythonバインディング  shared libraryの実行方法はPyRuntimeの実装を見る必要がありそう    詳細 import onnxruntimeでONNX Runtimeをインポートする。\n1 2 3 4 5 6 7 8 9 10 11 12 13  import os import sys import argparse import onnx import subprocess import numpy as np import tempfile from collections import OrderedDict # Reference backend, use onnxruntime by default import onnxruntime prepare = onnxruntime.InferenceSession   ONNX_MLIR_HOMEが設定されているか確認。\n1 2 3 4 5 6  if (not os.environ.get(\u0026#39;ONNX_MLIR_HOME\u0026#39;, None)): raise RuntimeError( \u0026#34;Environment variable ONNX_MLIR_HOME is not set, please set it to the path to \u0026#34; \u0026#34;the HOME directory for onnx-mlir. The HOME directory for onnx-mlir refers to \u0026#34; \u0026#34;the parent folder containing the bin, lib, etc sub-folders in which ONNX-MLIR \u0026#34; \u0026#34;executables and libraries can be found.\u0026#34;)   onnx-mlir実行ファイルパス、libディレクトリをimport検索パスに追加などする。\n1 2 3 4 5 6  VERBOSE = os.environ.get(\u0026#39;VERBOSE\u0026#39;, False) ONNX_MLIR = os.path.join(os.environ[\u0026#39;ONNX_MLIR_HOME\u0026#39;], \u0026#34;bin/onnx-mlir\u0026#34;) # Include runtime directory in python paths, so PyRuntime can be imported. RUNTIME_DIR = os.path.join(os.environ[\u0026#39;ONNX_MLIR_HOME\u0026#39;], \u0026#34;lib\u0026#34;) sys.path.append(RUNTIME_DIR)   PyRuntime(ONNX MLIRでビルドしたshared libraryをPythonから実行するためのPythonバインディング？)をインポートする。\n1 2 3 4 5 6  try: from PyRuntime import ExecutionSession except ImportError: raise ImportError( \u0026#34;Looks like you did not build the PyRuntime target, build it by running `make PyRuntime`.\u0026#34; )   ユーティリティ関数を定義。\nextend_model_output関数は、モデル内の各Operatorのoutputに、data type、shape情報を追加する。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18  def execute_commands(cmds): if (VERBOSE): print(\u0026#34; \u0026#34;.join(cmds)) subprocess.run(cmds, stdout=subprocess.PIPE, check=True) def extend_model_output(model, intermediate_outputs): # onnx-mlir doesn\u0026#39;t care about manually specified output types \u0026amp; shapes. DUMMY_TENSOR_TYPE = onnx.TensorProto.FLOAT while (len(model.graph.output)): model.graph.output.pop() for output_name in intermediate_outputs: output_value_info = onnx.helper.make_tensor_value_info( output_name, DUMMY_TENSOR_TYPE, None) model.graph.output.extend([output_value_info]) return model   メイン関数。\n1  def main(model_path):   入力のONNXファイルを読み込み、各Operatorのoutputにdata type、shape情報を追加する。\n1 2 3 4 5  model = onnx.load(model_path) intermediate_outputs = sum( [list(node.output) for node in model.graph.node], []) intermediate_outputs = list(OrderedDict.fromkeys(intermediate_outputs)) model = extend_model_output(model, intermediate_outputs)   以下は一時ディレクトリ内で実行。\n1 2  with tempfile.TemporaryDirectory() as temp_dir: print(\u0026#34;Temporary directory has been created at {}\u0026#34;.format(temp_dir))   ONNXモデルをファイルに出力し、ONNX MLIRでshared libraryに変換する。\n1 2 3 4  # Save modified model \u0026amp; invoke onnx-mlir to compile it. temp_model_path = os.path.join(temp_dir, \u0026#34;model.onnx\u0026#34;) onnx.save(model, temp_model_path) execute_commands([ONNX_MLIR, temp_model_path])   shared libraryから実行セッションを作成する。\n1 2 3 4  # Use the generated shared library to create an execution session. temp_shared_lib_path = os.path.join(temp_dir, \u0026#34;model.so\u0026#34;) sess = ExecutionSession(temp_shared_lib_path, \u0026#34;_dyn_entry_point_main_graph\u0026#34;)   入力データとしてランダムデータを生成する。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15  # Generate random data as input. inputs = [] input_names = [] initializers = list(map(lambda x: x.name, model.graph.initializer)) np.random.seed(42) for input_proto in model.graph.input: if input_proto.name not in initializers: input_names.append(input_proto.name) shape_proto = input_proto.type.tensor_type.shape explicit_shape = [] for dim in shape_proto.dim: assert dim.dim_value, \u0026#34;Can only debug models with inputs that have explicit shapes.\u0026#34; explicit_shape.append(dim.dim_value) inputs.append( np.random.uniform(-1.0, 1.0, explicit_shape).astype(np.float32))   shared libraryの実行セッションを実行する。\n1 2  # Run the compiled inference function on the randomly generated data. outs = sess.run(inputs)   リファレンスバックエンド(ONNX Runtime)で実行する。\n1 2 3 4 5  # Run the model with reference backend and get results. ref_session = prepare(temp_model_path) output_names = list(map(lambda x: x.name, model.graph.output)) input_feed = dict(zip(input_names, inputs)) ref_outs = ref_session.run(output_names, input_feed)   shared libraryとONNX Runtimeで実行した結果を比較する。\n1 2 3 4  # For each intermediate output tensor, compare results. for i, name in enumerate(intermediate_outputs): print(\u0026#34;Verifying value of {}\u0026#34;.format(name)) np.testing.assert_array_almost_equal(ref_outs[i], outs[i], decimal=5)   引数パーサーを定義し、メイン関数へパース結果を渡す。\n1 2 3 4 5  if __name__ == \u0026#39;__main__\u0026#39;: parser = argparse.ArgumentParser() parser.add_argument(\u0026#39;model_path\u0026#39;, type=str, help=\u0026#34;Path to the model to debug.\u0026#34;) args = parser.parse_args() main(**vars(args))   ",date:"2020-08-05 Wed",permalink:"https://mshr-h.com/posts/onnx-mlir-detail-debug-py/",title:"ONNX MLIRのdebug.py詳細"},{body:"ONNX MLIRに付属のdebug.pyを動かす手順。 .soファイルの実行手順を解析するための事前準備。\n前提条件  環境  macOS Catalina 10.15.6 Python 3.7.5 (pyenvで導入) ONNX MLIR commit id dbe0d734b5687e0aa7da911684912163cea07bd2   ONNX MLIRをビルド済み(ONNX MLIRをビルドする)  ビルドディレクトリは$HOME/workspace/onnx-mlir/buildとする   作業ディレクトリは$HOME/workspace/debug_testとする  環境変数の設定 ONNX_MLIR_HOMEにONNX MLIRのビルドディレクトリを設定する。\n1  export ONNX_MLIR_HOME=$HOME/workspace/onnx-mlir/build   準備 debug.pyを作業ディレクトリにコピーする。 ONNXモデルファイルの例としてmnistをダウンロードする。\n1 2  cp $HOME/workspace/onnx-mlir/utils/debug.py $HOME/workspace/debug_test/ wget https://github.com/onnx/models/raw/master/vision/classification/mnist/model/mnist-8.onnx   Pythonのonnxパッケージを導入する。\n1  pip3 install onnx   実行 debug.pyを見る限り、ONNX MLIRでONNXモデルファイルを.soへ変換し、実行するようだ。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15  python3 debug.py mnist-8.onnx Temporary directory has been created at /var/folders/mg/v57g_1jj3s52wgwtd61rt8t80000gn/T/tmp1megvpue %8 = \u0026#34;krnl.getref\u0026#34;(%7, %c0_i64) : (memref\u0026lt;10368xi8\u0026gt;, i64) -\u0026gt; memref\u0026lt;1x8x18x18xf32\u0026gt; Verifying value of Parameter193_reshape1 Verifying value of Convolution28_Output_0 Verifying value of Plus30_Output_0 Verifying value of ReLU32_Output_0 Verifying value of Pooling66_Output_0 Verifying value of Convolution110_Output_0 Verifying value of Plus112_Output_0 Verifying value of ReLU114_Output_0 Verifying value of Pooling160_Output_0 Verifying value of Pooling160_Output_0_reshape0 Verifying value of Times212_Output_0 Verifying value of Plus214_Output_0   ヘルプ情報 1 2 3 4 5 6 7 8  python3 debug.py -h usage: debug.py [-h] model_path positional arguments: model_path Path to the model to debug. optional arguments: -h, --help show this help message and exit   ",date:"2020-08-04 Tue",permalink:"https://mshr-h.com/posts/onnx-mlir-debug-py/",title:"ONNX MLIRに付属のdebug.pyを動かす"},{body:"C++コードを出力できるMLIR Dialectをビルドする。 ONNX MLIRをビルドするでMLIRをビルド済みとする。 MLIR(LLVM)のソースコードは~/workspace/llvm-projectへ配置済み。\nソースコード取得 1 2  $ cd ~/workspace $ git clone https://github.com/iml130/mlir-emitc/   環境変数設定 1 2  export MLIR_DIR=$(pwd)/llvm-project/build/lib/cmake/mlir export LLVM_EXTERNAL_LIT~$(pwd)/llvm-project/build/bin/llvm-lit   ビルド 1 2 3 4  mkdir mlir-emitc/build \u0026amp;\u0026amp; cd mlir-emitc/build cmake -G Ninja -DCMAKE_C_COMPILER=clang -DCMAKE_CXX_COMPILER=clang++ .. \\  -DMLIR_DIR=$MLIR_DIR -DLLVM_EXTERNAL_LIT=$LLVM_EXTERNAL_LIT cmake --build . --target check-emitc   テストエラーが出るが、一応ビルドはできた。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16  cmake --build . --target check-emitc [12/13] Running the EmitC regression tests -- Testing: 2 tests, 2 workers -- FAIL: EMITC :: Target/cpp-calls.mlir (1 of 2) PASS: EMITC :: Dialect/EmitC/ops.mlir (2 of 2) ******************** Failed Tests (1): EMITC :: Target/cpp-calls.mlir Testing Time: 0.11s Passed: 1 Failed: 1 FAILED: test/CMakeFiles/check-emitc cd /home/mshr/workspace/mlir-emitc/build/test \u0026amp;\u0026amp; /home/mshr/workspace/llvm-project/build/./bin/llvm-lit /home/mshr/workspace/mlir-emitc/build/test ninja: build stopped: subcommand failed.   build/binディレクトリにemitc-optとemitc-translateが生成される。\n1 2  ls bin emitc-opt emitc-translate   ",date:"2020-08-03 Mon",permalink:"https://mshr-h.com/posts/build-mlir-emitc/",title:"MLIR EmitCをビルドする"},{body:"前回の記事でビルドしたONNX MLIRを使って、ONNX Model Zooで配布されている学習済みモデルを変換する。\n環境変数パスの設定 ONNX MLIRのビルドディレクトリは~/workspace/onnx-mlir/buildとする。 ~/workspace/onnx-mlir/build/bin以下に次の2つの実行ファイルがあるはず。\n onnx-mlir  おそらくコンパイラのフロントエンドに相当？   onnx-mlir-opt  コンパイラPassをテストするためのツール    この実行ファイルをコマンドで実行できるように環境変数パスにディレクトリを追加する。\n1  export PATH=$PATH:~/workspace/onnx-mlir/build/bin   ONNXモデルを取得 例としてMNISTの学習済みモデルを取得する。\n1 2  cd ~/workspace wget https://github.com/onnx/models/raw/master/vision/classification/mnist/model/mnist-8.onnx   変換実行 shared libraryへ変換 1 2 3 4 5 6 7 8 9 10 11 12  $ nnx-mlir --EmitLib mnist-8.onnx %22 = \u0026#34;krnl.getref\u0026#34;(%21, %c0_i64) : (memref\u0026lt;4096xi8\u0026gt;, i64) -\u0026gt; memref\u0026lt;1x1x32x32xf32\u0026gt; %20 = \u0026#34;krnl.getref\u0026#34;(%19, %c0_i64) : (memref\u0026lt;25088xi8\u0026gt;, i64) -\u0026gt; memref\u0026lt;1x8x28x28xf32\u0026gt; %18 = \u0026#34;krnl.getref\u0026#34;(%17, %c0_i64) : (memref\u0026lt;25088xi8\u0026gt;, i64) -\u0026gt; memref\u0026lt;1x8x28x28xf32\u0026gt; %16 = \u0026#34;krnl.getref\u0026#34;(%15, %c0_i64) : (memref\u0026lt;25088xi8\u0026gt;, i64) -\u0026gt; memref\u0026lt;1x8x28x28xf32\u0026gt; %14 = \u0026#34;krnl.getref\u0026#34;(%13, %c0_i64) : (memref\u0026lt;6272xi8\u0026gt;, i64) -\u0026gt; memref\u0026lt;1x8x14x14xf32\u0026gt; %12 = \u0026#34;krnl.getref\u0026#34;(%11, %c0_i64) : (memref\u0026lt;10368xi8\u0026gt;, i64) -\u0026gt; memref\u0026lt;1x8x18x18xf32\u0026gt; %10 = \u0026#34;krnl.getref\u0026#34;(%9, %c0_i64) : (memref\u0026lt;12544xi8\u0026gt;, i64) -\u0026gt; memref\u0026lt;1x16x14x14xf32\u0026gt; %8 = \u0026#34;krnl.getref\u0026#34;(%7, %c0_i64) : (memref\u0026lt;12544xi8\u0026gt;, i64) -\u0026gt; memref\u0026lt;1x16x14x14xf32\u0026gt; %6 = \u0026#34;krnl.getref\u0026#34;(%5, %c0_i64) : (memref\u0026lt;12544xi8\u0026gt;, i64) -\u0026gt; memref\u0026lt;1x16x14x14xf32\u0026gt; %4 = \u0026#34;krnl.getref\u0026#34;(%3, %c0_i64) : (memref\u0026lt;1024xi8\u0026gt;, i64) -\u0026gt; memref\u0026lt;1x16x4x4xf32\u0026gt; %2 = \u0026#34;krnl.getref\u0026#34;(%1, %c0_i64) : (memref\u0026lt;1024xi8\u0026gt;, i64) -\u0026gt; memref\u0026lt;1x256xf32\u0026gt;   shared libraryがmnist-8.soが生成される。 現時点でドキュメントはほとんど整備されていないので、テストコード等から使い方を解析する必要がある。\nMLIRのtransformation dialectへ変換 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21  $ onnx-mlir --EmitMLIR mnist-8.onnx %22 = \u0026#34;krnl.getref\u0026#34;(%21, %c0_i64) : (memref\u0026lt;4096xi8\u0026gt;, i64) -\u0026gt; memref\u0026lt;1x1x32x32xf32\u0026gt; %20 = \u0026#34;krnl.getref\u0026#34;(%19, %c0_i64) : (memref\u0026lt;25088xi8\u0026gt;, i64) -\u0026gt; memref\u0026lt;1x8x28x28xf32\u0026gt; %18 = \u0026#34;krnl.getref\u0026#34;(%17, %c0_i64) : (memref\u0026lt;25088xi8\u0026gt;, i64) -\u0026gt; memref\u0026lt;1x8x28x28xf32\u0026gt; %16 = \u0026#34;krnl.getref\u0026#34;(%15, %c0_i64) : (memref\u0026lt;25088xi8\u0026gt;, i64) -\u0026gt; memref\u0026lt;1x8x28x28xf32\u0026gt; %14 = \u0026#34;krnl.getref\u0026#34;(%13, %c0_i64) : (memref\u0026lt;6272xi8\u0026gt;, i64) -\u0026gt; memref\u0026lt;1x8x14x14xf32\u0026gt; %12 = \u0026#34;krnl.getref\u0026#34;(%11, %c0_i64) : (memref\u0026lt;10368xi8\u0026gt;, i64) -\u0026gt; memref\u0026lt;1x8x18x18xf32\u0026gt; %10 = \u0026#34;krnl.getref\u0026#34;(%9, %c0_i64) : (memref\u0026lt;12544xi8\u0026gt;, i64) -\u0026gt; memref\u0026lt;1x16x14x14xf32\u0026gt; %8 = \u0026#34;krnl.getref\u0026#34;(%7, %c0_i64) : (memref\u0026lt;12544xi8\u0026gt;, i64) -\u0026gt; memref\u0026lt;1x16x14x14xf32\u0026gt; %6 = \u0026#34;krnl.getref\u0026#34;(%5, %c0_i64) : (memref\u0026lt;12544xi8\u0026gt;, i64) -\u0026gt; memref\u0026lt;1x16x14x14xf32\u0026gt; %4 = \u0026#34;krnl.getref\u0026#34;(%3, %c0_i64) : (memref\u0026lt;1024xi8\u0026gt;, i64) -\u0026gt; memref\u0026lt;1x16x4x4xf32\u0026gt; %2 = \u0026#34;krnl.getref\u0026#34;(%1, %c0_i64) : (memref\u0026lt;1024xi8\u0026gt;, i64) -\u0026gt; memref\u0026lt;1x256xf32\u0026gt; Full MLIR code written to: mnist-8.onnx.mlir Constant-free MLIR Code written to: mnist-8.tmp Use: mnist-8.onnx.mlir to continue lowering the code to other dialects.   mnist-8.onnx.mlirにtransformation dialectが出力される。 cat mnist-8.onnx.mlirは以下。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269  $ cat mnist-8.onnx.mlir #map0 = affine_map\u0026lt;()[s0, s1, s2, s3] -\u0026gt; (s0, s1, s2, s3)\u0026gt; #map1 = affine_map\u0026lt;() -\u0026gt; (0)\u0026gt; #map2 = affine_map\u0026lt;() -\u0026gt; (32)\u0026gt; #map3 = affine_map\u0026lt;() -\u0026gt; (1)\u0026gt; #map4 = affine_map\u0026lt;()[s0, s1, s2, s3] -\u0026gt; (s0, s1, s2 + 2, s3 + 2)\u0026gt; #map5 = affine_map\u0026lt;() -\u0026gt; (28)\u0026gt; #map6 = affine_map\u0026lt;()[s0, s1, s2, s3, s4, s5] -\u0026gt; (s0, s1, s2 + s3, s4 + s5)\u0026gt; #map7 = affine_map\u0026lt;() -\u0026gt; (5)\u0026gt; #map8 = affine_map\u0026lt;() -\u0026gt; (8)\u0026gt; #map9 = affine_map\u0026lt;()[s0, s1, s2] -\u0026gt; (0, s0, s1, s2)\u0026gt; #map10 = affine_map\u0026lt;()[s0] -\u0026gt; (s0, 0, 0)\u0026gt; #map11 = affine_map\u0026lt;()[s0] -\u0026gt; (0, s0 * 2)\u0026gt; #map12 = affine_map\u0026lt;(d0) -\u0026gt; (28, d0 * -2 + 28, d0 * 2 + 2, 2)\u0026gt; #map13 = affine_map\u0026lt;() -\u0026gt; (14)\u0026gt; #map14 = affine_map\u0026lt;() -\u0026gt; (18)\u0026gt; #map15 = affine_map\u0026lt;() -\u0026gt; (16)\u0026gt; #map16 = affine_map\u0026lt;()[s0] -\u0026gt; (0, s0 * 3)\u0026gt; #map17 = affine_map\u0026lt;(d0) -\u0026gt; (14, d0 * -3 + 14, d0 * 3 + 3, 3)\u0026gt; #map18 = affine_map\u0026lt;() -\u0026gt; (4)\u0026gt; #map19 = affine_map\u0026lt;()[s0, s1] -\u0026gt; (s0, s1)\u0026gt; #map20 = affine_map\u0026lt;() -\u0026gt; (256)\u0026gt; #map21 = affine_map\u0026lt;()[s0] -\u0026gt; (0, s0)\u0026gt; #map22 = affine_map\u0026lt;() -\u0026gt; (10)\u0026gt; module { %0 = \u0026#34;krnl.packed_const\u0026#34;() {file_name = \u0026#34;/tmp/packed_const-85df46.tmp\u0026#34;, is_le = true, size_in_bytes = 23840 : i64} : () -\u0026gt; i64 func @main_graph(%arg0: memref\u0026lt;1x1x28x28xf32\u0026gt;) -\u0026gt; memref\u0026lt;1x10xf32\u0026gt; { %c28 = constant 28 : index %c2 = constant 2 : index %cst = constant 0xFF800000 : f32 %c14 = constant 14 : index %c3 = constant 3 : index %c1 = constant 1 : index %c1024_i64 = constant 1024 : i64 %cst_0 = constant 1.000000e+00 : f32 %cst_1 = constant 0.000000e+00 : f32 %c0 = constant 0 : index %c0_i64 = constant 0 : i64 %c10240_i64 = constant 10240 : i64 %c14336_i64 = constant 14336 : i64 %c39424_i64 = constant 39424 : i64 %c64512_i64 = constant 64512 : i64 %c89600_i64 = constant 89600 : i64 %c95872_i64 = constant 95872 : i64 %c106240_i64 = constant 106240 : i64 %c118784_i64 = constant 118784 : i64 %c131328_i64 = constant 131328 : i64 %c143872_i64 = constant 143872 : i64 %c144896_i64 = constant 144896 : i64 %1 = alloc() : memref\u0026lt;1x10xf32\u0026gt; %2 = alloc() : memref\u0026lt;145920xi8\u0026gt; %3 = \u0026#34;krnl.getref\u0026#34;(%2, %c144896_i64) : (memref\u0026lt;145920xi8\u0026gt;, i64) -\u0026gt; memref\u0026lt;1x256xf32\u0026gt; %4 = \u0026#34;krnl.getref\u0026#34;(%2, %c143872_i64) : (memref\u0026lt;145920xi8\u0026gt;, i64) -\u0026gt; memref\u0026lt;1x16x4x4xf32\u0026gt; %5 = \u0026#34;krnl.getref\u0026#34;(%2, %c131328_i64) : (memref\u0026lt;145920xi8\u0026gt;, i64) -\u0026gt; memref\u0026lt;1x16x14x14xf32\u0026gt; %6 = \u0026#34;krnl.getref\u0026#34;(%2, %c118784_i64) : (memref\u0026lt;145920xi8\u0026gt;, i64) -\u0026gt; memref\u0026lt;1x16x14x14xf32\u0026gt; %7 = \u0026#34;krnl.getref\u0026#34;(%2, %c106240_i64) : (memref\u0026lt;145920xi8\u0026gt;, i64) -\u0026gt; memref\u0026lt;1x16x14x14xf32\u0026gt; %8 = \u0026#34;krnl.getref\u0026#34;(%2, %c95872_i64) : (memref\u0026lt;145920xi8\u0026gt;, i64) -\u0026gt; memref\u0026lt;1x8x18x18xf32\u0026gt; %9 = \u0026#34;krnl.getref\u0026#34;(%2, %c89600_i64) : (memref\u0026lt;145920xi8\u0026gt;, i64) -\u0026gt; memref\u0026lt;1x8x14x14xf32\u0026gt; %10 = \u0026#34;krnl.getref\u0026#34;(%2, %c64512_i64) : (memref\u0026lt;145920xi8\u0026gt;, i64) -\u0026gt; memref\u0026lt;1x8x28x28xf32\u0026gt; %11 = \u0026#34;krnl.getref\u0026#34;(%2, %c39424_i64) : (memref\u0026lt;145920xi8\u0026gt;, i64) -\u0026gt; memref\u0026lt;1x8x28x28xf32\u0026gt; %12 = \u0026#34;krnl.getref\u0026#34;(%2, %c14336_i64) : (memref\u0026lt;145920xi8\u0026gt;, i64) -\u0026gt; memref\u0026lt;1x8x28x28xf32\u0026gt; %13 = \u0026#34;krnl.getref\u0026#34;(%2, %c10240_i64) : (memref\u0026lt;145920xi8\u0026gt;, i64) -\u0026gt; memref\u0026lt;1x1x32x32xf32\u0026gt; %14 = \u0026#34;krnl.getref\u0026#34;(%2, %c0_i64) : (memref\u0026lt;145920xi8\u0026gt;, i64) -\u0026gt; memref\u0026lt;256x10xf32\u0026gt; %15 = \u0026#34;krnl.global\u0026#34;() {name = \u0026#34;constant_0\u0026#34;, offset = 0 : i64, shape = [16, 4, 4, 10]} : () -\u0026gt; memref\u0026lt;16x4x4x10xf32\u0026gt; \u0026#34;krnl.memcpy\u0026#34;(%14, %15, %c10240_i64) : (memref\u0026lt;256x10xf32\u0026gt;, memref\u0026lt;16x4x4x10xf32\u0026gt;, i64) -\u0026gt; () %16 = \u0026#34;krnl.global\u0026#34;() {name = \u0026#34;constant_1\u0026#34;, offset = 10240 : i64, shape = [8, 1, 5, 5]} : () -\u0026gt; memref\u0026lt;8x1x5x5xf32\u0026gt; affine.for %arg1 = 0 to 1 { affine.for %arg2 = 0 to 1 { affine.for %arg3 = 0 to 32 { affine.for %arg4 = 0 to 32 { affine.store %cst_1, %13[symbol(%arg1), symbol(%arg2), symbol(%arg3), symbol(%arg4)] : memref\u0026lt;1x1x32x32xf32\u0026gt; } } } } affine.for %arg1 = 0 to 1 { affine.for %arg2 = 0 to 1 { affine.for %arg3 = 0 to 28 { affine.for %arg4 = 0 to 28 { %21 = affine.load %arg0[symbol(%arg1), symbol(%arg2), symbol(%arg3), symbol(%arg4)] : memref\u0026lt;1x1x28x28xf32\u0026gt; affine.store %21, %13[symbol(%arg1), symbol(%arg2), symbol(%arg3) + 2, symbol(%arg4) + 2] : memref\u0026lt;1x1x32x32xf32\u0026gt; } } } } affine.for %arg1 = 0 to 1 { affine.for %arg2 = 0 to 8 { affine.for %arg3 = 0 to 28 { affine.for %arg4 = 0 to 28 { affine.store %cst_1, %12[symbol(%arg1), symbol(%arg2), symbol(%arg3), symbol(%arg4)] : memref\u0026lt;1x8x28x28xf32\u0026gt; affine.for %arg5 = 0 to 1 { affine.for %arg6 = 0 to 5 { affine.for %arg7 = 0 to 5 { %21 = affine.load %13[symbol(%arg1), symbol(%arg5), symbol(%arg3) + symbol(%arg6), symbol(%arg4) + symbol(%arg7)] : memref\u0026lt;1x1x32x32xf32\u0026gt; %22 = affine.load %16[symbol(%arg2), symbol(%arg5), symbol(%arg6), symbol(%arg7)] : memref\u0026lt;8x1x5x5xf32\u0026gt; %23 = affine.load %12[symbol(%arg1), symbol(%arg2), symbol(%arg3), symbol(%arg4)] : memref\u0026lt;1x8x28x28xf32\u0026gt; %24 = mulf %21, %22 : f32 %25 = addf %23, %24 : f32 affine.store %25, %12[symbol(%arg1), symbol(%arg2), symbol(%arg3), symbol(%arg4)] : memref\u0026lt;1x8x28x28xf32\u0026gt; } } } } } } } %17 = \u0026#34;krnl.global\u0026#34;() {name = \u0026#34;constant_2\u0026#34;, offset = 11040 : i64, shape = [8, 1, 1], value = dense\u0026lt;[[[-0.161539719]], [[-0.433835655]], [[0.091641359]], [[-0.0168522168]], [[-0.0650264397]], [[-0.131737873]], [[0.0204175506]], [[-0.121110231]]]\u0026gt; : tensor\u0026lt;8x1x1xf32\u0026gt;} : () -\u0026gt; memref\u0026lt;8x1x1xf32\u0026gt; affine.for %arg1 = 0 to 1 { affine.for %arg2 = 0 to 8 { affine.for %arg3 = 0 to 28 { affine.for %arg4 = 0 to 28 { %21 = affine.load %12[0, symbol(%arg2), symbol(%arg3), symbol(%arg4)] : memref\u0026lt;1x8x28x28xf32\u0026gt; %22 = affine.load %17[symbol(%arg2), 0, 0] : memref\u0026lt;8x1x1xf32\u0026gt; %23 = addf %21, %22 : f32 affine.store %23, %11[symbol(%arg1), symbol(%arg2), symbol(%arg3), symbol(%arg4)] : memref\u0026lt;1x8x28x28xf32\u0026gt; } } } } affine.for %arg1 = 0 to 1 { affine.for %arg2 = 0 to 8 { affine.for %arg3 = 0 to 28 { affine.for %arg4 = 0 to 28 { %21 = affine.load %11[symbol(%arg1), symbol(%arg2), symbol(%arg3), symbol(%arg4)] : memref\u0026lt;1x8x28x28xf32\u0026gt; %22 = cmpf \u0026#34;olt\u0026#34;, %21, %cst_1 : f32 %23 = select %22, %cst_1, %21 : f32 affine.store %23, %10[symbol(%arg1), symbol(%arg2), symbol(%arg3), symbol(%arg4)] : memref\u0026lt;1x8x28x28xf32\u0026gt; } } } } affine.for %arg1 = 0 to 1 { affine.for %arg2 = 0 to 8 { affine.for %arg3 = 0 to 14 { affine.for %arg4 = 0 to 14 { affine.store %cst, %9[symbol(%arg1), symbol(%arg2), symbol(%arg3), symbol(%arg4)] : memref\u0026lt;1x8x14x14xf32\u0026gt; %21 = affine.max #map11()[%arg3] %22 = affine.max #map11()[%arg4] affine.for %arg5 = 0 to min #map12(%arg3) { affine.for %arg6 = 0 to min #map12(%arg4) { %23 = addi %arg5, %21 : index %24 = addi %arg6, %22 : index %25 = load %10[%arg1, %arg2, %23, %24] : memref\u0026lt;1x8x28x28xf32\u0026gt; %26 = affine.load %9[symbol(%arg1), symbol(%arg2), symbol(%arg3), symbol(%arg4)] : memref\u0026lt;1x8x14x14xf32\u0026gt; %27 = cmpf \u0026#34;ogt\u0026#34;, %26, %25 : f32 %28 = select %27, %26, %25 : f32 affine.store %28, %9[symbol(%arg1), symbol(%arg2), symbol(%arg3), symbol(%arg4)] : memref\u0026lt;1x8x14x14xf32\u0026gt; } } } } } } %18 = \u0026#34;krnl.global\u0026#34;() {name = \u0026#34;constant_3\u0026#34;, offset = 11040 : i64, shape = [16, 8, 5, 5]} : () -\u0026gt; memref\u0026lt;16x8x5x5xf32\u0026gt; affine.for %arg1 = 0 to 1 { affine.for %arg2 = 0 to 8 { affine.for %arg3 = 0 to 18 { affine.for %arg4 = 0 to 18 { affine.store %cst_1, %8[symbol(%arg1), symbol(%arg2), symbol(%arg3), symbol(%arg4)] : memref\u0026lt;1x8x18x18xf32\u0026gt; } } } } affine.for %arg1 = 0 to 1 { affine.for %arg2 = 0 to 8 { affine.for %arg3 = 0 to 14 { affine.for %arg4 = 0 to 14 { %21 = affine.load %9[symbol(%arg1), symbol(%arg2), symbol(%arg3), symbol(%arg4)] : memref\u0026lt;1x8x14x14xf32\u0026gt; affine.store %21, %8[symbol(%arg1), symbol(%arg2), symbol(%arg3) + 2, symbol(%arg4) + 2] : memref\u0026lt;1x8x18x18xf32\u0026gt; } } } } affine.for %arg1 = 0 to 1 { affine.for %arg2 = 0 to 16 { affine.for %arg3 = 0 to 14 { affine.for %arg4 = 0 to 14 { affine.store %cst_1, %7[symbol(%arg1), symbol(%arg2), symbol(%arg3), symbol(%arg4)] : memref\u0026lt;1x16x14x14xf32\u0026gt; affine.for %arg5 = 0 to 8 { affine.for %arg6 = 0 to 5 { affine.for %arg7 = 0 to 5 { %21 = affine.load %8[symbol(%arg1), symbol(%arg5), symbol(%arg3) + symbol(%arg6), symbol(%arg4) + symbol(%arg7)] : memref\u0026lt;1x8x18x18xf32\u0026gt; %22 = affine.load %18[symbol(%arg2), symbol(%arg5), symbol(%arg6), symbol(%arg7)] : memref\u0026lt;16x8x5x5xf32\u0026gt; %23 = affine.load %7[symbol(%arg1), symbol(%arg2), symbol(%arg3), symbol(%arg4)] : memref\u0026lt;1x16x14x14xf32\u0026gt; %24 = mulf %21, %22 : f32 %25 = addf %23, %24 : f32 affine.store %25, %7[symbol(%arg1), symbol(%arg2), symbol(%arg3), symbol(%arg4)] : memref\u0026lt;1x16x14x14xf32\u0026gt; } } } } } } } %19 = \u0026#34;krnl.global\u0026#34;() {name = \u0026#34;constant_4\u0026#34;, offset = 23840 : i64, shape = [16, 1, 1], value = dense\u0026lt;[[[-0.0822488219]], [[-0.108868778]], [[-0.141039595]], [[-0.204869166]], [[-0.17913565]], [[-0.215438381]], [[-0.133805066]], [[-0.195724562]], [[-0.268250644]], [[-0.258212209]], [[-0.0761560649]], [[0.0132841459]], [[-0.00444464432]], [[-0.414740831]], [[-0.17879115]], [[-0.0386558883]]]\u0026gt; : tensor\u0026lt;16x1x1xf32\u0026gt;} : () -\u0026gt; memref\u0026lt;16x1x1xf32\u0026gt; affine.for %arg1 = 0 to 1 { affine.for %arg2 = 0 to 16 { affine.for %arg3 = 0 to 14 { affine.for %arg4 = 0 to 14 { %21 = affine.load %7[0, symbol(%arg2), symbol(%arg3), symbol(%arg4)] : memref\u0026lt;1x16x14x14xf32\u0026gt; %22 = affine.load %19[symbol(%arg2), 0, 0] : memref\u0026lt;16x1x1xf32\u0026gt; %23 = addf %21, %22 : f32 affine.store %23, %6[symbol(%arg1), symbol(%arg2), symbol(%arg3), symbol(%arg4)] : memref\u0026lt;1x16x14x14xf32\u0026gt; } } } } affine.for %arg1 = 0 to 1 { affine.for %arg2 = 0 to 16 { affine.for %arg3 = 0 to 14 { affine.for %arg4 = 0 to 14 { %21 = affine.load %6[symbol(%arg1), symbol(%arg2), symbol(%arg3), symbol(%arg4)] : memref\u0026lt;1x16x14x14xf32\u0026gt; %22 = cmpf \u0026#34;olt\u0026#34;, %21, %cst_1 : f32 %23 = select %22, %cst_1, %21 : f32 affine.store %23, %5[symbol(%arg1), symbol(%arg2), symbol(%arg3), symbol(%arg4)] : memref\u0026lt;1x16x14x14xf32\u0026gt; } } } } affine.for %arg1 = 0 to 1 { affine.for %arg2 = 0 to 16 { affine.for %arg3 = 0 to 4 { affine.for %arg4 = 0 to 4 { affine.store %cst, %4[symbol(%arg1), symbol(%arg2), symbol(%arg3), symbol(%arg4)] : memref\u0026lt;1x16x4x4xf32\u0026gt; %21 = affine.max #map16()[%arg3] %22 = affine.max #map16()[%arg4] affine.for %arg5 = 0 to min #map17(%arg3) { affine.for %arg6 = 0 to min #map17(%arg4) { %23 = addi %arg5, %21 : index %24 = addi %arg6, %22 : index %25 = load %5[%arg1, %arg2, %23, %24] : memref\u0026lt;1x16x14x14xf32\u0026gt; %26 = affine.load %4[symbol(%arg1), symbol(%arg2), symbol(%arg3), symbol(%arg4)] : memref\u0026lt;1x16x4x4xf32\u0026gt; %27 = cmpf \u0026#34;ogt\u0026#34;, %26, %25 : f32 %28 = select %27, %26, %25 : f32 affine.store %28, %4[symbol(%arg1), symbol(%arg2), symbol(%arg3), symbol(%arg4)] : memref\u0026lt;1x16x4x4xf32\u0026gt; } } } } } } \u0026#34;krnl.memcpy\u0026#34;(%3, %4, %c1024_i64) : (memref\u0026lt;1x256xf32\u0026gt;, memref\u0026lt;1x16x4x4xf32\u0026gt;, i64) -\u0026gt; () %20 = \u0026#34;krnl.global\u0026#34;() {name = \u0026#34;constant_5\u0026#34;, offset = 23840 : i64, shape = [1, 10], value = dense\u0026lt;[[-0.0448560268, 0.00779166119, 0.0681008175, 0.0299937408, -0.126409635, 0.14021875, -0.0552849025, -0.0493838154, 0.0843220502, -0.0545404144]]\u0026gt; : tensor\u0026lt;1x10xf32\u0026gt;} : () -\u0026gt; memref\u0026lt;1x10xf32\u0026gt; affine.for %arg1 = 0 to 1 { affine.for %arg2 = 0 to 10 { affine.store %cst_1, %1[symbol(%arg1), symbol(%arg2)] : memref\u0026lt;1x10xf32\u0026gt; affine.for %arg3 = 0 to 256 { %26 = affine.load %3[symbol(%arg1), symbol(%arg3)] : memref\u0026lt;1x256xf32\u0026gt; %27 = affine.load %14[symbol(%arg3), symbol(%arg2)] : memref\u0026lt;256x10xf32\u0026gt; %28 = affine.load %1[symbol(%arg1), symbol(%arg2)] : memref\u0026lt;1x10xf32\u0026gt; %29 = mulf %26, %27 : f32 %30 = addf %28, %29 : f32 affine.store %30, %1[symbol(%arg1), symbol(%arg2)] : memref\u0026lt;1x10xf32\u0026gt; } %21 = affine.load %1[symbol(%arg1), symbol(%arg2)] : memref\u0026lt;1x10xf32\u0026gt; %22 = mulf %cst_0, %21 : f32 %23 = affine.load %20[0, symbol(%arg2)] : memref\u0026lt;1x10xf32\u0026gt; %24 = mulf %cst_0, %23 : f32 %25 = addf %22, %24 : f32 affine.store %25, %1[symbol(%arg1), symbol(%arg2)] : memref\u0026lt;1x10xf32\u0026gt; } } dealloc %2 : memref\u0026lt;145920xi8\u0026gt; return %1 : memref\u0026lt;1x10xf32\u0026gt; } \u0026#34;krnl.entry_point\u0026#34;() {func = @main_graph, numInputs = 1 : i32, numOutputs = 1 : i32} : () -\u0026gt; () }   transformation dialectからLLVM dialectへ変換 上記で出力したtransformation dialectをLLVM dialectへ変換する。\n1  $ onnx-mlir-opt --convert-krnl-to-llvm mnist-8.onnx.mlir   出力は以下。2000行以上ある。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 346 347 348 349 350 351 352 353 354 355 356 357 358 359 360 361 362 363 364 365 366 367 368 369 370 371 372 373 374 375 376 377 378 379 380 381 382 383 384 385 386 387 388 389 390 391 392 393 394 395 396 397 398 399 400 401 402 403 404 405 406 407 408 409 410 411 412 413 414 415 416 417 418 419 420 421 422 423 424 425 426 427 428 429 430 431 432 433 434 435 436 437 438 439 440 441 442 443 444 445 446 447 448 449 450 451 452 453 454 455 456 457 458 459 460 461 462 463 464 465 466 467 468 469 470 471 472 473 474 475 476 477 478 479 480 481 482 483 484 485 486 487 488 489 490 491 492 493 494 495 496 497 498 499 500 501 502 503 504 505 506 507 508 509 510 511 512 513 514 515 516 517 518 519 520 521 522 523 524 525 526 527 528 529 530 531 532 533 534 535 536 537 538 539 540 541 542 543 544 545 546 547 548 549 550 551 552 553 554 555 556 557 558 559 560 561 562 563 564 565 566 567 568 569 570 571 572 573 574 575 576 577 578 579 580 581 582 583 584 585 586 587 588 589 590 591 592 593 594 595 596 597 598 599 600 601 602 603 604 605 606 607 608 609 610 611 612 613 614 615 616 617 618 619 620 621 622 623 624 625 626 627 628 629 630 631 632 633 634 635 636 637 638 639 640 641 642 643 644 645 646 647 648 649 650 651 652 653 654 655 656 657 658 659 660 661 662 663 664 665 666 667 668 669 670 671 672 673 674 675 676 677 678 679 680 681 682 683 684 685 686 687 688 689 690 691 692 693 694 695 696 697 698 699 700 701 702 703 704 705 706 707 708 709 710 711 712 713 714 715 716 717 718 719 720 721 722 723 724 725 726 727 728 729 730 731 732 733 734 735 736 737 738 739 740 741 742 743 744 745 746 747 748 749 750 751 752 753 754 755 756 757 758 759 760 761 762 763 764 765 766 767 768 769 770 771 772 773 774 775 776 777 778 779 780 781 782 783 784 785 786 787 788 789 790 791 792 793 794 795 796 797 798 799 800 801 802 803 804 805 806 807 808 809 810 811 812 813 814 815 816 817 818 819 820 821 822 823 824 825 826 827 828 829 830 831 832 833 834 835 836 837 838 839 840 841 842 843 844 845 846 847 848 849 850 851 852 853 854 855 856 857 858 859 860 861 862 863 864 865 866 867 868 869 870 871 872 873 874 875 876 877 878 879 880 881 882 883 884 885 886 887 888 889 890 891 892 893 894 895 896 897 898 899 900 901 902 903 904 905 906 907 908 909 910 911 912 913 914 915 916 917 918 919 920 921 922 923 924 925 926 927 928 929 930 931 932 933 934 935 936 937 938 939 940 941 942 943 944 945 946 947 948 949 950 951 952 953 954 955 956 957 958 959 960 961 962 963 964 965 966 967 968 969 970 971 972 973 974 975 976 977 978 979 980 981 982 983 984 985 986 987 988 989 990 991 992 993 994 995 996 997 998 999 1000 1001 1002 1003 1004 1005 1006 1007 1008 1009 1010 1011 1012 1013 1014 1015 1016 1017 1018 1019 1020 1021 1022 1023 1024 1025 1026 1027 1028 1029 1030 1031 1032 1033 1034 1035 1036 1037 1038 1039 1040 1041 1042 1043 1044 1045 1046 1047 1048 1049 1050 1051 1052 1053 1054 1055 1056 1057 1058 1059 1060 1061 1062 1063 1064 1065 1066 1067 1068 1069 1070 1071 1072 1073 1074 1075 1076 1077 1078 1079 1080 1081 1082 1083 1084 1085 1086 1087 1088 1089 1090 1091 1092 1093 1094 1095 1096 1097 1098 1099 1100 1101 1102 1103 1104 1105 1106 1107 1108 1109 1110 1111 1112 1113 1114 1115 1116 1117 1118 1119 1120 1121 1122 1123 1124 1125 1126 1127 1128 1129 1130 1131 1132 1133 1134 1135 1136 1137 1138 1139 1140 1141 1142 1143 1144 1145 1146 1147 1148 1149 1150 1151 1152 1153 1154 1155 1156 1157 1158 1159 1160 1161 1162 1163 1164 1165 1166 1167 1168 1169 1170 1171 1172 1173 1174 1175 1176 1177 1178 1179 1180 1181 1182 1183 1184 1185 1186 1187 1188 1189 1190 1191 1192 1193 1194 1195 1196 1197 1198 1199 1200 1201 1202 1203 1204 1205 1206 1207 1208 1209 1210 1211 1212 1213 1214 1215 1216 1217 1218 1219 1220 1221 1222 1223 1224 1225 1226 1227 1228 1229 1230 1231 1232 1233 1234 1235 1236 1237 1238 1239 1240 1241 1242 1243 1244 1245 1246 1247 1248 1249 1250 1251 1252 1253 1254 1255 1256 1257 1258 1259 1260 1261 1262 1263 1264 1265 1266 1267 1268 1269 1270 1271 1272 1273 1274 1275 1276 1277 1278 1279 1280 1281 1282 1283 1284 1285 1286 1287 1288 1289 1290 1291 1292 1293 1294 1295 1296 1297 1298 1299 1300 1301 1302 1303 1304 1305 1306 1307 1308 1309 1310 1311 1312 1313 1314 1315 1316 1317 1318 1319 1320 1321 1322 1323 1324 1325 1326 1327 1328 1329 1330 1331 1332 1333 1334 1335 1336 1337 1338 1339 1340 1341 1342 1343 1344 1345 1346 1347 1348 1349 1350 1351 1352 1353 1354 1355 1356 1357 1358 1359 1360 1361 1362 1363 1364 1365 1366 1367 1368 1369 1370 1371 1372 1373 1374 1375 1376 1377 1378 1379 1380 1381 1382 1383 1384 1385 1386 1387 1388 1389 1390 1391 1392 1393 1394 1395 1396 1397 1398 1399 1400 1401 1402 1403 1404 1405 1406 1407 1408 1409 1410 1411 1412 1413 1414 1415 1416 1417 1418 1419 1420 1421 1422 1423 1424 1425 1426 1427 1428 1429 1430 1431 1432 1433 1434 1435 1436 1437 1438 1439 1440 1441 1442 1443 1444 1445 1446 1447 1448 1449 1450 1451 1452 1453 1454 1455 1456 1457 1458 1459 1460 1461 1462 1463 1464 1465 1466 1467 1468 1469 1470 1471 1472 1473 1474 1475 1476 1477 1478 1479 1480 1481 1482 1483 1484 1485 1486 1487 1488 1489 1490 1491 1492 1493 1494 1495 1496 1497 1498 1499 1500 1501 1502 1503 1504 1505 1506 1507 1508 1509 1510 1511 1512 1513 1514 1515 1516 1517 1518 1519 1520 1521 1522 1523 1524 1525 1526 1527 1528 1529 1530 1531 1532 1533 1534 1535 1536 1537 1538 1539 1540 1541 1542 1543 1544 1545 1546 1547 1548 1549 1550 1551 1552 1553 1554 1555 1556 1557 1558 1559 1560 1561 1562 1563 1564 1565 1566 1567 1568 1569 1570 1571 1572 1573 1574 1575 1576 1577 1578 1579 1580 1581 1582 1583 1584 1585 1586 1587 1588 1589 1590 1591 1592 1593 1594 1595 1596 1597 1598 1599 1600 1601 1602 1603 1604 1605 1606 1607 1608 1609 1610 1611 1612 1613 1614 1615 1616 1617 1618 1619 1620 1621 1622 1623 1624 1625 1626 1627 1628 1629 1630 1631 1632 1633 1634 1635 1636 1637 1638 1639 1640 1641 1642 1643 1644 1645 1646 1647 1648 1649 1650 1651 1652 1653 1654 1655 1656 1657 1658 1659 1660 1661 1662 1663 1664 1665 1666 1667 1668 1669 1670 1671 1672 1673 1674 1675 1676 1677 1678 1679 1680 1681 1682 1683 1684 1685 1686 1687 1688 1689 1690 1691 1692 1693 1694 1695 1696 1697 1698 1699 1700 1701 1702 1703 1704 1705 1706 1707 1708 1709 1710 1711 1712 1713 1714 1715 1716 1717 1718 1719 1720 1721 1722 1723 1724 1725 1726 1727 1728 1729 1730 1731 1732 1733 1734 1735 1736 1737 1738 1739 1740 1741 1742 1743 1744 1745 1746 1747 1748 1749 1750 1751 1752 1753 1754 1755 1756 1757 1758 1759 1760 1761 1762 1763 1764 1765 1766 1767 1768 1769 1770 1771 1772 1773 1774 1775 1776 1777 1778 1779 1780 1781 1782 1783 1784 1785 1786 1787 1788 1789 1790 1791 1792 1793 1794 1795 1796 1797 1798 1799 1800 1801 1802 1803 1804 1805 1806 1807 1808 1809 1810 1811 1812 1813 1814 1815 1816 1817 1818 1819 1820 1821 1822 1823 1824 1825 1826 1827 1828 1829 1830 1831 1832 1833 1834 1835 1836 1837 1838 1839 1840 1841 1842 1843 1844 1845 1846 1847 1848 1849 1850 1851 1852 1853 1854 1855 1856 1857 1858 1859 1860 1861 1862 1863 1864 1865 1866 1867 1868 1869 1870 1871 1872 1873 1874 1875 1876 1877 1878 1879 1880 1881 1882 1883 1884 1885 1886 1887 1888 1889 1890 1891 1892 1893 1894 1895 1896 1897 1898 1899 1900 1901 1902 1903 1904 1905 1906 1907 1908 1909 1910 1911 1912 1913 1914 1915 1916 1917 1918 1919 1920 1921 1922 1923 1924 1925 1926 1927 1928 1929 1930 1931 1932 1933 1934 1935 1936 1937 1938 1939 1940 1941 1942 1943 1944 1945 1946 1947 1948 1949 1950 1951 1952 1953 1954 1955 1956 1957 1958 1959 1960 1961 1962 1963 1964 1965 1966 1967 1968 1969 1970 1971 1972 1973 1974 1975 1976 1977 1978 1979 1980 1981 1982 1983 1984 1985 1986 1987 1988 1989 1990 1991 1992 1993 1994 1995 1996 1997 1998 1999 2000 2001 2002 2003 2004 2005 2006 2007 2008 2009 2010 2011 2012 2013 2014 2015 2016 2017 2018 2019 2020 2021 2022 2023 2024 2025 2026 2027 2028 2029 2030 2031 2032 2033 2034 2035 2036 2037 2038 2039 2040 2041 2042 2043 2044 2045 2046 2047 2048 2049 2050 2051 2052 2053 2054 2055  module { llvm.func @setDType(!llvm\u0026lt;\u0026#34;i8*\u0026#34;\u0026gt;, !llvm.i32) llvm.func @getDType(!llvm\u0026lt;\u0026#34;i8*\u0026#34;\u0026gt;) -\u0026gt; !llvm.i32 llvm.func @getStrides(!llvm\u0026lt;\u0026#34;i8*\u0026#34;\u0026gt;) -\u0026gt; !llvm\u0026lt;\u0026#34;i64*\u0026#34;\u0026gt; llvm.func @getSizes(!llvm\u0026lt;\u0026#34;i8*\u0026#34;\u0026gt;) -\u0026gt; !llvm\u0026lt;\u0026#34;i64*\u0026#34;\u0026gt; llvm.func @setRtMemRef(!llvm\u0026lt;\u0026#34;i8*\u0026#34;\u0026gt;, !llvm.i32, !llvm\u0026lt;\u0026#34;i8*\u0026#34;\u0026gt;) llvm.func @getRtMemRef(!llvm\u0026lt;\u0026#34;i8*\u0026#34;\u0026gt;, !llvm.i32) -\u0026gt; !llvm\u0026lt;\u0026#34;i8*\u0026#34;\u0026gt; llvm.func @setData(!llvm\u0026lt;\u0026#34;i8*\u0026#34;\u0026gt;, !llvm\u0026lt;\u0026#34;i8*\u0026#34;\u0026gt;) llvm.func @getData(!llvm\u0026lt;\u0026#34;i8*\u0026#34;\u0026gt;) -\u0026gt; !llvm\u0026lt;\u0026#34;i8*\u0026#34;\u0026gt; llvm.func @createRtMemRef(!llvm.i32) -\u0026gt; !llvm\u0026lt;\u0026#34;i8*\u0026#34;\u0026gt; llvm.func @createOrderedRtMemRefDict() -\u0026gt; !llvm\u0026lt;\u0026#34;i8*\u0026#34;\u0026gt; llvm.func @free(!llvm\u0026lt;\u0026#34;i8*\u0026#34;\u0026gt;) llvm.mlir.global internal constant @constant_5(dense\u0026lt;[[-0.0448560268, 0.00779166119, 0.0681008175, 0.0299937408, -0.126409635, 0.14021875, -0.0552849025, -0.0493838154, 0.0843220502, -0.0545404144]]\u0026gt; : tensor\u0026lt;1x10xf32\u0026gt;) : !llvm\u0026lt;\u0026#34;[1 x [10 x float]]\u0026#34;\u0026gt; llvm.mlir.global internal constant @constant_4(dense\u0026lt;[[[-0.0822488219]], [[-0.108868778]], [[-0.141039595]], [[-0.204869166]], [[-0.17913565]], [[-0.215438381]], [[-0.133805066]], [[-0.195724562]], [[-0.268250644]], [[-0.258212209]], [[-0.0761560649]], [[0.0132841459]], [[-0.00444464432]], [[-0.414740831]], [[-0.17879115]], [[-0.0386558883]]]\u0026gt; : tensor\u0026lt;16x1x1xf32\u0026gt;) : !llvm\u0026lt;\u0026#34;[16 x [1 x [1 x float]]]\u0026#34;\u0026gt; llvm.mlir.global internal constant @constant_2(dense\u0026lt;[[[-0.161539719]], [[-0.433835655]], [[0.091641359]], [[-0.0168522168]], [[-0.0650264397]], [[-0.131737873]], [[0.0204175506]], [[-0.121110231]]]\u0026gt; : tensor\u0026lt;8x1x1xf32\u0026gt;) : !llvm\u0026lt;\u0026#34;[8 x [1 x [1 x float]]]\u0026#34;\u0026gt; llvm.func @llvm.memcpy.p0i8.p0i8.i64(!llvm\u0026lt;\u0026#34;i8*\u0026#34;\u0026gt;, !llvm\u0026lt;\u0026#34;i8*\u0026#34;\u0026gt;, !llvm.i64, !llvm.i1) llvm.func @malloc(!llvm.i64) -\u0026gt; !llvm\u0026lt;\u0026#34;i8*\u0026#34;\u0026gt; llvm.mlir.global external constant @constPackFilePath(\u0026#34;/tmp/packed_const-85df46.tmp\u0026#34;) llvm.mlir.global external constant @constPackFilePathStrLen(28 : i64) : !llvm.i64 llvm.mlir.global external constant @constPackFileName(\u0026#34;packed_const-85df46.tmp\u0026#34;) llvm.mlir.global external constant @constPackFileNameStrLen(23 : i64) : !llvm.i64 llvm.mlir.global external constant @constPackIsLE(1 : i8) : !llvm.i8 llvm.func @getEmbeddedConstPool(!llvm.i64) -\u0026gt; !llvm\u0026lt;\u0026#34;i8*\u0026#34;\u0026gt; llvm.mlir.global internal @packedConst() : !llvm\u0026lt;\u0026#34;i8*\u0026#34;\u0026gt; llvm.func @main_graph(%arg0: !llvm\u0026lt;\u0026#34;float*\u0026#34;\u0026gt;, %arg1: !llvm\u0026lt;\u0026#34;float*\u0026#34;\u0026gt;, %arg2: !llvm.i64, %arg3: !llvm.i64, %arg4: !llvm.i64, %arg5: !llvm.i64, %arg6: !llvm.i64, %arg7: !llvm.i64, %arg8: !llvm.i64, %arg9: !llvm.i64, %arg10: !llvm.i64) -\u0026gt; !llvm\u0026lt;\u0026#34;{ float*, float*, i64, [2 x i64], [2 x i64] }\u0026#34;\u0026gt; { %0 = llvm.mlir.undef : !llvm\u0026lt;\u0026#34;{ float*, float*, i64, [4 x i64], [4 x i64] }\u0026#34;\u0026gt; %1 = llvm.insertvalue %arg0, %0[0] : !llvm\u0026lt;\u0026#34;{ float*, float*, i64, [4 x i64], [4 x i64] }\u0026#34;\u0026gt; %2 = llvm.insertvalue %arg1, %1[1] : !llvm\u0026lt;\u0026#34;{ float*, float*, i64, [4 x i64], [4 x i64] }\u0026#34;\u0026gt; %3 = llvm.insertvalue %arg2, %2[2] : !llvm\u0026lt;\u0026#34;{ float*, float*, i64, [4 x i64], [4 x i64] }\u0026#34;\u0026gt; %4 = llvm.insertvalue %arg3, %3[3, 0] : !llvm\u0026lt;\u0026#34;{ float*, float*, i64, [4 x i64], [4 x i64] }\u0026#34;\u0026gt; %5 = llvm.insertvalue %arg7, %4[4, 0] : !llvm\u0026lt;\u0026#34;{ float*, float*, i64, [4 x i64], [4 x i64] }\u0026#34;\u0026gt; %6 = llvm.insertvalue %arg4, %5[3, 1] : !llvm\u0026lt;\u0026#34;{ float*, float*, i64, [4 x i64], [4 x i64] }\u0026#34;\u0026gt; %7 = llvm.insertvalue %arg8, %6[4, 1] : !llvm\u0026lt;\u0026#34;{ float*, float*, i64, [4 x i64], [4 x i64] }\u0026#34;\u0026gt; %8 = llvm.insertvalue %arg5, %7[3, 2] : !llvm\u0026lt;\u0026#34;{ float*, float*, i64, [4 x i64], [4 x i64] }\u0026#34;\u0026gt; %9 = llvm.insertvalue %arg9, %8[4, 2] : !llvm\u0026lt;\u0026#34;{ float*, float*, i64, [4 x i64], [4 x i64] }\u0026#34;\u0026gt; %10 = llvm.insertvalue %arg6, %9[3, 3] : !llvm\u0026lt;\u0026#34;{ float*, float*, i64, [4 x i64], [4 x i64] }\u0026#34;\u0026gt; %11 = llvm.insertvalue %arg10, %10[4, 3] : !llvm\u0026lt;\u0026#34;{ float*, float*, i64, [4 x i64], [4 x i64] }\u0026#34;\u0026gt; %12 = llvm.mlir.addressof @packedConst : !llvm\u0026lt;\u0026#34;i8**\u0026#34;\u0026gt; %13 = llvm.mlir.constant(23840 : i64) : !llvm.i64 %14 = llvm.call @getEmbeddedConstPool(%13) : (!llvm.i64) -\u0026gt; !llvm\u0026lt;\u0026#34;i8*\u0026#34;\u0026gt; llvm.store %14, %12 : !llvm\u0026lt;\u0026#34;i8**\u0026#34;\u0026gt; %15 = llvm.mlir.constant(28 : index) : !llvm.i64 %16 = llvm.mlir.constant(2 : index) : !llvm.i64 %17 = llvm.mlir.constant(0xFF800000 : f32) : !llvm.float %18 = llvm.mlir.constant(14 : index) : !llvm.i64 %19 = llvm.mlir.constant(3 : index) : !llvm.i64 %20 = llvm.mlir.constant(1 : index) : !llvm.i64 %21 = llvm.mlir.constant(1024 : i64) : !llvm.i64 %22 = llvm.mlir.constant(1.000000e+00 : f32) : !llvm.float %23 = llvm.mlir.constant(0.000000e+00 : f32) : !llvm.float %24 = llvm.mlir.constant(0 : index) : !llvm.i64 %25 = llvm.mlir.constant(0 : i64) : !llvm.i64 %26 = llvm.mlir.constant(10240 : i64) : !llvm.i64 %27 = llvm.mlir.constant(14336 : i64) : !llvm.i64 %28 = llvm.mlir.constant(39424 : i64) : !llvm.i64 %29 = llvm.mlir.constant(64512 : i64) : !llvm.i64 %30 = llvm.mlir.constant(89600 : i64) : !llvm.i64 %31 = llvm.mlir.constant(95872 : i64) : !llvm.i64 %32 = llvm.mlir.constant(106240 : i64) : !llvm.i64 %33 = llvm.mlir.constant(118784 : i64) : !llvm.i64 %34 = llvm.mlir.constant(131328 : i64) : !llvm.i64 %35 = llvm.mlir.constant(143872 : i64) : !llvm.i64 %36 = llvm.mlir.constant(144896 : i64) : !llvm.i64 %37 = llvm.mlir.constant(1 : index) : !llvm.i64 %38 = llvm.mlir.constant(10 : index) : !llvm.i64 %39 = llvm.mul %37, %38 : !llvm.i64 %40 = llvm.mlir.null : !llvm\u0026lt;\u0026#34;float*\u0026#34;\u0026gt; %41 = llvm.mlir.constant(1 : index) : !llvm.i64 %42 = llvm.getelementptr %40[%41] : (!llvm\u0026lt;\u0026#34;float*\u0026#34;\u0026gt;, !llvm.i64) -\u0026gt; !llvm\u0026lt;\u0026#34;float*\u0026#34;\u0026gt; %43 = llvm.ptrtoint %42 : !llvm\u0026lt;\u0026#34;float*\u0026#34;\u0026gt; to !llvm.i64 %44 = llvm.mul %39, %43 : !llvm.i64 %45 = llvm.call @malloc(%44) : (!llvm.i64) -\u0026gt; !llvm\u0026lt;\u0026#34;i8*\u0026#34;\u0026gt; %46 = llvm.bitcast %45 : !llvm\u0026lt;\u0026#34;i8*\u0026#34;\u0026gt; to !llvm\u0026lt;\u0026#34;float*\u0026#34;\u0026gt; %47 = llvm.mlir.undef : !llvm\u0026lt;\u0026#34;{ float*, float*, i64, [2 x i64], [2 x i64] }\u0026#34;\u0026gt; %48 = llvm.insertvalue %46, %47[0] : !llvm\u0026lt;\u0026#34;{ float*, float*, i64, [2 x i64], [2 x i64] }\u0026#34;\u0026gt; %49 = llvm.insertvalue %46, %48[1] : !llvm\u0026lt;\u0026#34;{ float*, float*, i64, [2 x i64], [2 x i64] }\u0026#34;\u0026gt; %50 = llvm.mlir.constant(0 : index) : !llvm.i64 %51 = llvm.insertvalue %50, %49[2] : !llvm\u0026lt;\u0026#34;{ float*, float*, i64, [2 x i64], [2 x i64] }\u0026#34;\u0026gt; %52 = llvm.mlir.constant(1 : index) : !llvm.i64 %53 = llvm.mlir.constant(10 : index) : !llvm.i64 %54 = llvm.insertvalue %37, %51[3, 0] : !llvm\u0026lt;\u0026#34;{ float*, float*, i64, [2 x i64], [2 x i64] }\u0026#34;\u0026gt; %55 = llvm.insertvalue %53, %54[4, 0] : !llvm\u0026lt;\u0026#34;{ float*, float*, i64, [2 x i64], [2 x i64] }\u0026#34;\u0026gt; %56 = llvm.insertvalue %38, %55[3, 1] : !llvm\u0026lt;\u0026#34;{ float*, float*, i64, [2 x i64], [2 x i64] }\u0026#34;\u0026gt; %57 = llvm.insertvalue %52, %56[4, 1] : !llvm\u0026lt;\u0026#34;{ float*, float*, i64, [2 x i64], [2 x i64] }\u0026#34;\u0026gt; %58 = llvm.mlir.constant(145920 : index) : !llvm.i64 %59 = llvm.mlir.null : !llvm\u0026lt;\u0026#34;i8*\u0026#34;\u0026gt; %60 = llvm.mlir.constant(1 : index) : !llvm.i64 %61 = llvm.getelementptr %59[%60] : (!llvm\u0026lt;\u0026#34;i8*\u0026#34;\u0026gt;, !llvm.i64) -\u0026gt; !llvm\u0026lt;\u0026#34;i8*\u0026#34;\u0026gt; %62 = llvm.ptrtoint %61 : !llvm\u0026lt;\u0026#34;i8*\u0026#34;\u0026gt; to !llvm.i64 %63 = llvm.mul %58, %62 : !llvm.i64 %64 = llvm.call @malloc(%63) : (!llvm.i64) -\u0026gt; !llvm\u0026lt;\u0026#34;i8*\u0026#34;\u0026gt; %65 = llvm.bitcast %64 : !llvm\u0026lt;\u0026#34;i8*\u0026#34;\u0026gt; to !llvm\u0026lt;\u0026#34;i8*\u0026#34;\u0026gt; %66 = llvm.mlir.undef : !llvm\u0026lt;\u0026#34;{ i8*, i8*, i64, [1 x i64], [1 x i64] }\u0026#34;\u0026gt; %67 = llvm.insertvalue %65, %66[0] : !llvm\u0026lt;\u0026#34;{ i8*, i8*, i64, [1 x i64], [1 x i64] }\u0026#34;\u0026gt; %68 = llvm.insertvalue %65, %67[1] : !llvm\u0026lt;\u0026#34;{ i8*, i8*, i64, [1 x i64], [1 x i64] }\u0026#34;\u0026gt; %69 = llvm.mlir.constant(0 : index) : !llvm.i64 %70 = llvm.insertvalue %69, %68[2] : !llvm\u0026lt;\u0026#34;{ i8*, i8*, i64, [1 x i64], [1 x i64] }\u0026#34;\u0026gt; %71 = llvm.mlir.constant(1 : index) : !llvm.i64 %72 = llvm.insertvalue %58, %70[3, 0] : !llvm\u0026lt;\u0026#34;{ i8*, i8*, i64, [1 x i64], [1 x i64] }\u0026#34;\u0026gt; %73 = llvm.insertvalue %71, %72[4, 0] : !llvm\u0026lt;\u0026#34;{ i8*, i8*, i64, [1 x i64], [1 x i64] }\u0026#34;\u0026gt; %74 = llvm.extractvalue %73[1] : !llvm\u0026lt;\u0026#34;{ i8*, i8*, i64, [1 x i64], [1 x i64] }\u0026#34;\u0026gt; %75 = llvm.getelementptr %74[%36] : (!llvm\u0026lt;\u0026#34;i8*\u0026#34;\u0026gt;, !llvm.i64) -\u0026gt; !llvm\u0026lt;\u0026#34;i8*\u0026#34;\u0026gt; %76 = llvm.bitcast %75 : !llvm\u0026lt;\u0026#34;i8*\u0026#34;\u0026gt; to !llvm\u0026lt;\u0026#34;float*\u0026#34;\u0026gt; %77 = llvm.mlir.undef : !llvm\u0026lt;\u0026#34;{ float*, float*, i64, [2 x i64], [2 x i64] }\u0026#34;\u0026gt; %78 = llvm.insertvalue %76, %77[0] : !llvm\u0026lt;\u0026#34;{ float*, float*, i64, [2 x i64], [2 x i64] }\u0026#34;\u0026gt; %79 = llvm.insertvalue %76, %78[1] : !llvm\u0026lt;\u0026#34;{ float*, float*, i64, [2 x i64], [2 x i64] }\u0026#34;\u0026gt; %80 = llvm.mlir.constant(0 : index) : !llvm.i64 %81 = llvm.insertvalue %80, %79[2] : !llvm\u0026lt;\u0026#34;{ float*, float*, i64, [2 x i64], [2 x i64] }\u0026#34;\u0026gt; %82 = llvm.mlir.constant(1 : index) : !llvm.i64 %83 = llvm.insertvalue %82, %81[3, 0] : !llvm\u0026lt;\u0026#34;{ float*, float*, i64, [2 x i64], [2 x i64] }\u0026#34;\u0026gt; %84 = llvm.mlir.constant(256 : index) : !llvm.i64 %85 = llvm.insertvalue %84, %83[4, 0] : !llvm\u0026lt;\u0026#34;{ float*, float*, i64, [2 x i64], [2 x i64] }\u0026#34;\u0026gt; %86 = llvm.mlir.constant(256 : index) : !llvm.i64 %87 = llvm.insertvalue %86, %85[3, 1] : !llvm\u0026lt;\u0026#34;{ float*, float*, i64, [2 x i64], [2 x i64] }\u0026#34;\u0026gt; %88 = llvm.mlir.constant(1 : index) : !llvm.i64 %89 = llvm.insertvalue %88, %87[4, 1] : !llvm\u0026lt;\u0026#34;{ float*, float*, i64, [2 x i64], [2 x i64] }\u0026#34;\u0026gt; %90 = llvm.extractvalue %73[1] : !llvm\u0026lt;\u0026#34;{ i8*, i8*, i64, [1 x i64], [1 x i64] }\u0026#34;\u0026gt; %91 = llvm.getelementptr %90[%35] : (!llvm\u0026lt;\u0026#34;i8*\u0026#34;\u0026gt;, !llvm.i64) -\u0026gt; !llvm\u0026lt;\u0026#34;i8*\u0026#34;\u0026gt; %92 = llvm.bitcast %91 : !llvm\u0026lt;\u0026#34;i8*\u0026#34;\u0026gt; to !llvm\u0026lt;\u0026#34;float*\u0026#34;\u0026gt; %93 = llvm.mlir.undef : !llvm\u0026lt;\u0026#34;{ float*, float*, i64, [4 x i64], [4 x i64] }\u0026#34;\u0026gt; %94 = llvm.insertvalue %92, %93[0] : !llvm\u0026lt;\u0026#34;{ float*, float*, i64, [4 x i64], [4 x i64] }\u0026#34;\u0026gt; %95 = llvm.insertvalue %92, %94[1] : !llvm\u0026lt;\u0026#34;{ float*, float*, i64, [4 x i64], [4 x i64] }\u0026#34;\u0026gt; %96 = llvm.mlir.constant(0 : index) : !llvm.i64 %97 = llvm.insertvalue %96, %95[2] : !llvm\u0026lt;\u0026#34;{ float*, float*, i64, [4 x i64], [4 x i64] }\u0026#34;\u0026gt; %98 = llvm.mlir.constant(1 : index) : !llvm.i64 %99 = llvm.insertvalue %98, %97[3, 0] : !llvm\u0026lt;\u0026#34;{ float*, float*, i64, [4 x i64], [4 x i64] }\u0026#34;\u0026gt; %100 = llvm.mlir.constant(256 : index) : !llvm.i64 %101 = llvm.insertvalue %100, %99[4, 0] : !llvm\u0026lt;\u0026#34;{ float*, float*, i64, [4 x i64], [4 x i64] }\u0026#34;\u0026gt; %102 = llvm.mlir.constant(16 : index) : !llvm.i64 %103 = llvm.insertvalue %102, %101[3, 1] : !llvm\u0026lt;\u0026#34;{ float*, float*, i64, [4 x i64], [4 x i64] }\u0026#34;\u0026gt; %104 = llvm.mlir.constant(16 : index) : !llvm.i64 %105 = llvm.insertvalue %104, %103[4, 1] : !llvm\u0026lt;\u0026#34;{ float*, float*, i64, [4 x i64], [4 x i64] }\u0026#34;\u0026gt; %106 = llvm.mlir.constant(4 : index) : !llvm.i64 %107 = llvm.insertvalue %106, %105[3, 2] : !llvm\u0026lt;\u0026#34;{ float*, float*, i64, [4 x i64], [4 x i64] }\u0026#34;\u0026gt; %108 = llvm.mlir.constant(4 : index) : !llvm.i64 %109 = llvm.insertvalue %108, %107[4, 2] : !llvm\u0026lt;\u0026#34;{ float*, float*, i64, [4 x i64], [4 x i64] }\u0026#34;\u0026gt; %110 = llvm.mlir.constant(4 : index) : !llvm.i64 %111 = llvm.insertvalue %110, %109[3, 3] : !llvm\u0026lt;\u0026#34;{ float*, float*, i64, [4 x i64], [4 x i64] }\u0026#34;\u0026gt; %112 = llvm.mlir.constant(1 : index) : !llvm.i64 %113 = llvm.insertvalue %112, %111[4, 3] : !llvm\u0026lt;\u0026#34;{ float*, float*, i64, [4 x i64], [4 x i64] }\u0026#34;\u0026gt; %114 = llvm.extractvalue %73[1] : !llvm\u0026lt;\u0026#34;{ i8*, i8*, i64, [1 x i64], [1 x i64] }\u0026#34;\u0026gt; %115 = llvm.getelementptr %114[%34] : (!llvm\u0026lt;\u0026#34;i8*\u0026#34;\u0026gt;, !llvm.i64) -\u0026gt; !llvm\u0026lt;\u0026#34;i8*\u0026#34;\u0026gt; %116 = llvm.bitcast %115 : !llvm\u0026lt;\u0026#34;i8*\u0026#34;\u0026gt; to !llvm\u0026lt;\u0026#34;float*\u0026#34;\u0026gt; %117 = llvm.mlir.undef : !llvm\u0026lt;\u0026#34;{ float*, float*, i64, [4 x i64], [4 x i64] }\u0026#34;\u0026gt; %118 = llvm.insertvalue %116, %117[0] : !llvm\u0026lt;\u0026#34;{ float*, float*, i64, [4 x i64], [4 x i64] }\u0026#34;\u0026gt; %119 = llvm.insertvalue %116, %118[1] : !llvm\u0026lt;\u0026#34;{ float*, float*, i64, [4 x i64], [4 x i64] }\u0026#34;\u0026gt; %120 = llvm.mlir.constant(0 : index) : !llvm.i64 %121 = llvm.insertvalue %120, %119[2] : !llvm\u0026lt;\u0026#34;{ float*, float*, i64, [4 x i64], [4 x i64] }\u0026#34;\u0026gt; %122 = llvm.mlir.constant(1 : index) : !llvm.i64 %123 = llvm.insertvalue %122, %121[3, 0] : !llvm\u0026lt;\u0026#34;{ float*, float*, i64, [4 x i64], [4 x i64] }\u0026#34;\u0026gt; %124 = llvm.mlir.constant(3136 : index) : !llvm.i64 %125 = llvm.insertvalue %124, %123[4, 0] : !llvm\u0026lt;\u0026#34;{ float*, float*, i64, [4 x i64], [4 x i64] }\u0026#34;\u0026gt; %126 = llvm.mlir.constant(16 : index) : !llvm.i64 %127 = llvm.insertvalue %126, %125[3, 1] : !llvm\u0026lt;\u0026#34;{ float*, float*, i64, [4 x i64], [4 x i64] }\u0026#34;\u0026gt; %128 = llvm.mlir.constant(196 : index) : !llvm.i64 %129 = llvm.insertvalue %128, %127[4, 1] : !llvm\u0026lt;\u0026#34;{ float*, float*, i64, [4 x i64], [4 x i64] }\u0026#34;\u0026gt; %130 = llvm.mlir.constant(14 : index) : !llvm.i64 %131 = llvm.insertvalue %130, %129[3, 2] : !llvm\u0026lt;\u0026#34;{ float*, float*, i64, [4 x i64], [4 x i64] }\u0026#34;\u0026gt; %132 = llvm.mlir.constant(14 : index) : !llvm.i64 %133 = llvm.insertvalue %132, %131[4, 2] : !llvm\u0026lt;\u0026#34;{ float*, float*, i64, [4 x i64], [4 x i64] }\u0026#34;\u0026gt; %134 = llvm.mlir.constant(14 : index) : !llvm.i64 %135 = llvm.insertvalue %134, %133[3, 3] : !llvm\u0026lt;\u0026#34;{ float*, float*, i64, [4 x i64], [4 x i64] }\u0026#34;\u0026gt; %136 = llvm.mlir.constant(1 : index) : !llvm.i64 %137 = llvm.insertvalue %136, %135[4, 3] : !llvm\u0026lt;\u0026#34;{ float*, float*, i64, [4 x i64], [4 x i64] }\u0026#34;\u0026gt; %138 = llvm.extractvalue %73[1] : !llvm\u0026lt;\u0026#34;{ i8*, i8*, i64, [1 x i64], [1 x i64] }\u0026#34;\u0026gt; %139 = llvm.getelementptr %138[%33] : (!llvm\u0026lt;\u0026#34;i8*\u0026#34;\u0026gt;, !llvm.i64) -\u0026gt; !llvm\u0026lt;\u0026#34;i8*\u0026#34;\u0026gt; %140 = llvm.bitcast %139 : !llvm\u0026lt;\u0026#34;i8*\u0026#34;\u0026gt; to !llvm\u0026lt;\u0026#34;float*\u0026#34;\u0026gt; %141 = llvm.mlir.undef : !llvm\u0026lt;\u0026#34;{ float*, float*, i64, [4 x i64], [4 x i64] }\u0026#34;\u0026gt; %142 = llvm.insertvalue %140, %141[0] : !llvm\u0026lt;\u0026#34;{ float*, float*, i64, [4 x i64], [4 x i64] }\u0026#34;\u0026gt; %143 = llvm.insertvalue %140, %142[1] : !llvm\u0026lt;\u0026#34;{ float*, float*, i64, [4 x i64], [4 x i64] }\u0026#34;\u0026gt; %144 = llvm.mlir.constant(0 : index) : !llvm.i64 %145 = llvm.insertvalue %144, %143[2] : !llvm\u0026lt;\u0026#34;{ float*, float*, i64, [4 x i64], [4 x i64] }\u0026#34;\u0026gt; %146 = llvm.mlir.constant(1 : index) : !llvm.i64 %147 = llvm.insertvalue %146, %145[3, 0] : !llvm\u0026lt;\u0026#34;{ float*, float*, i64, [4 x i64], [4 x i64] }\u0026#34;\u0026gt; %148 = llvm.mlir.constant(3136 : index) : !llvm.i64 %149 = llvm.insertvalue %148, %147[4, 0] : !llvm\u0026lt;\u0026#34;{ float*, float*, i64, [4 x i64], [4 x i64] }\u0026#34;\u0026gt; %150 = llvm.mlir.constant(16 : index) : !llvm.i64 %151 = llvm.insertvalue %150, %149[3, 1] : !llvm\u0026lt;\u0026#34;{ float*, float*, i64, [4 x i64], [4 x i64] }\u0026#34;\u0026gt; %152 = llvm.mlir.constant(196 : index) : !llvm.i64 %153 = llvm.insertvalue %152, %151[4, 1] : !llvm\u0026lt;\u0026#34;{ float*, float*, i64, [4 x i64], [4 x i64] }\u0026#34;\u0026gt; %154 = llvm.mlir.constant(14 : index) : !llvm.i64 %155 = llvm.insertvalue %154, %153[3, 2] : !llvm\u0026lt;\u0026#34;{ float*, float*, i64, [4 x i64], [4 x i64] }\u0026#34;\u0026gt; %156 = llvm.mlir.constant(14 : index) : !llvm.i64 %157 = llvm.insertvalue %156, %155[4, 2] : !llvm\u0026lt;\u0026#34;{ float*, float*, i64, [4 x i64], [4 x i64] }\u0026#34;\u0026gt; %158 = llvm.mlir.constant(14 : index) : !llvm.i64 %159 = llvm.insertvalue %158, %157[3, 3] : !llvm\u0026lt;\u0026#34;{ float*, float*, i64, [4 x i64], [4 x i64] }\u0026#34;\u0026gt; %160 = llvm.mlir.constant(1 : index) : !llvm.i64 %161 = llvm.insertvalue %160, %159[4, 3] : !llvm\u0026lt;\u0026#34;{ float*, float*, i64, [4 x i64], [4 x i64] }\u0026#34;\u0026gt; %162 = llvm.extractvalue %73[1] : !llvm\u0026lt;\u0026#34;{ i8*, i8*, i64, [1 x i64], [1 x i64] }\u0026#34;\u0026gt; %163 = llvm.getelementptr %162[%32] : (!llvm\u0026lt;\u0026#34;i8*\u0026#34;\u0026gt;, !llvm.i64) -\u0026gt; !llvm\u0026lt;\u0026#34;i8*\u0026#34;\u0026gt; %164 = llvm.bitcast %163 : !llvm\u0026lt;\u0026#34;i8*\u0026#34;\u0026gt; to !llvm\u0026lt;\u0026#34;float*\u0026#34;\u0026gt; %165 = llvm.mlir.undef : !llvm\u0026lt;\u0026#34;{ float*, float*, i64, [4 x i64], [4 x i64] }\u0026#34;\u0026gt; %166 = llvm.insertvalue %164, %165[0] : !llvm\u0026lt;\u0026#34;{ float*, float*, i64, [4 x i64], [4 x i64] }\u0026#34;\u0026gt; %167 = llvm.insertvalue %164, %166[1] : !llvm\u0026lt;\u0026#34;{ float*, float*, i64, [4 x i64], [4 x i64] }\u0026#34;\u0026gt; %168 = llvm.mlir.constant(0 : index) : !llvm.i64 %169 = llvm.insertvalue %168, %167[2] : !llvm\u0026lt;\u0026#34;{ float*, float*, i64, [4 x i64], [4 x i64] }\u0026#34;\u0026gt; %170 = llvm.mlir.constant(1 : index) : !llvm.i64 %171 = llvm.insertvalue %170, %169[3, 0] : !llvm\u0026lt;\u0026#34;{ float*, float*, i64, [4 x i64], [4 x i64] }\u0026#34;\u0026gt; %172 = llvm.mlir.constant(3136 : index) : !llvm.i64 %173 = llvm.insertvalue %172, %171[4, 0] : !llvm\u0026lt;\u0026#34;{ float*, float*, i64, [4 x i64], [4 x i64] }\u0026#34;\u0026gt; %174 = llvm.mlir.constant(16 : index) : !llvm.i64 %175 = llvm.insertvalue %174, %173[3, 1] : !llvm\u0026lt;\u0026#34;{ float*, float*, i64, [4 x i64], [4 x i64] }\u0026#34;\u0026gt; %176 = llvm.mlir.constant(196 : index) : !llvm.i64 %177 = llvm.insertvalue %176, %175[4, 1] : !llvm\u0026lt;\u0026#34;{ float*, float*, i64, [4 x i64], [4 x i64] }\u0026#34;\u0026gt; %178 = llvm.mlir.constant(14 : index) : !llvm.i64 %179 = llvm.insertvalue %178, %177[3, 2] : !llvm\u0026lt;\u0026#34;{ float*, float*, i64, [4 x i64], [4 x i64] }\u0026#34;\u0026gt; %180 = llvm.mlir.constant(14 : index) : !llvm.i64 %181 = llvm.insertvalue %180, %179[4, 2] : !llvm\u0026lt;\u0026#34;{ float*, float*, i64, [4 x i64], [4 x i64] }\u0026#34;\u0026gt; %182 = llvm.mlir.constant(14 : index) : !llvm.i64 %183 = llvm.insertvalue %182, %181[3, 3] : !llvm\u0026lt;\u0026#34;{ float*, float*, i64, [4 x i64], [4 x i64] }\u0026#34;\u0026gt; %184 = llvm.mlir.constant(1 : index) : !llvm.i64 %185 = llvm.insertvalue %184, %183[4, 3] : !llvm\u0026lt;\u0026#34;{ float*, float*, i64, [4 x i64], [4 x i64] }\u0026#34;\u0026gt; %186 = llvm.extractvalue %73[1] : !llvm\u0026lt;\u0026#34;{ i8*, i8*, i64, [1 x i64], [1 x i64] }\u0026#34;\u0026gt; %187 = llvm.getelementptr %186[%31] : (!llvm\u0026lt;\u0026#34;i8*\u0026#34;\u0026gt;, !llvm.i64) -\u0026gt; !llvm\u0026lt;\u0026#34;i8*\u0026#34;\u0026gt; %188 = llvm.bitcast %187 : !llvm\u0026lt;\u0026#34;i8*\u0026#34;\u0026gt; to !llvm\u0026lt;\u0026#34;float*\u0026#34;\u0026gt; %189 = llvm.mlir.undef : !llvm\u0026lt;\u0026#34;{ float*, float*, i64, [4 x i64], [4 x i64] }\u0026#34;\u0026gt; %190 = llvm.insertvalue %188, %189[0] : !llvm\u0026lt;\u0026#34;{ float*, float*, i64, [4 x i64], [4 x i64] }\u0026#34;\u0026gt; %191 = llvm.insertvalue %188, %190[1] : !llvm\u0026lt;\u0026#34;{ float*, float*, i64, [4 x i64], [4 x i64] }\u0026#34;\u0026gt; %192 = llvm.mlir.constant(0 : index) : !llvm.i64 %193 = llvm.insertvalue %192, %191[2] : !llvm\u0026lt;\u0026#34;{ float*, float*, i64, [4 x i64], [4 x i64] }\u0026#34;\u0026gt; %194 = llvm.mlir.constant(1 : index) : !llvm.i64 %195 = llvm.insertvalue %194, %193[3, 0] : !llvm\u0026lt;\u0026#34;{ float*, float*, i64, [4 x i64], [4 x i64] }\u0026#34;\u0026gt; %196 = llvm.mlir.constant(2592 : index) : !llvm.i64 %197 = llvm.insertvalue %196, %195[4, 0] : !llvm\u0026lt;\u0026#34;{ float*, float*, i64, [4 x i64], [4 x i64] }\u0026#34;\u0026gt; %198 = llvm.mlir.constant(8 : index) : !llvm.i64 %199 = llvm.insertvalue %198, %197[3, 1] : !llvm\u0026lt;\u0026#34;{ float*, float*, i64, [4 x i64], [4 x i64] }\u0026#34;\u0026gt; %200 = llvm.mlir.constant(324 : index) : !llvm.i64 %201 = llvm.insertvalue %200, %199[4, 1] : !llvm\u0026lt;\u0026#34;{ float*, float*, i64, [4 x i64], [4 x i64] }\u0026#34;\u0026gt; %202 = llvm.mlir.constant(18 : index) : !llvm.i64 %203 = llvm.insertvalue %202, %201[3, 2] : !llvm\u0026lt;\u0026#34;{ float*, float*, i64, [4 x i64], [4 x i64] }\u0026#34;\u0026gt; %204 = llvm.mlir.constant(18 : index) : !llvm.i64 %205 = llvm.insertvalue %204, %203[4, 2] : !llvm\u0026lt;\u0026#34;{ float*, float*, i64, [4 x i64], [4 x i64] }\u0026#34;\u0026gt; %206 = llvm.mlir.constant(18 : index) : !llvm.i64 %207 = llvm.insertvalue %206, %205[3, 3] : !llvm\u0026lt;\u0026#34;{ float*, float*, i64, [4 x i64], [4 x i64] }\u0026#34;\u0026gt; %208 = llvm.mlir.constant(1 : index) : !llvm.i64 %209 = llvm.insertvalue %208, %207[4, 3] : !llvm\u0026lt;\u0026#34;{ float*, float*, i64, [4 x i64], [4 x i64] }\u0026#34;\u0026gt; %210 = llvm.extractvalue %73[1] : !llvm\u0026lt;\u0026#34;{ i8*, i8*, i64, [1 x i64], [1 x i64] }\u0026#34;\u0026gt; %211 = llvm.getelementptr %210[%30] : (!llvm\u0026lt;\u0026#34;i8*\u0026#34;\u0026gt;, !llvm.i64) -\u0026gt; !llvm\u0026lt;\u0026#34;i8*\u0026#34;\u0026gt; %212 = llvm.bitcast %211 : !llvm\u0026lt;\u0026#34;i8*\u0026#34;\u0026gt; to !llvm\u0026lt;\u0026#34;float*\u0026#34;\u0026gt; %213 = llvm.mlir.undef : !llvm\u0026lt;\u0026#34;{ float*, float*, i64, [4 x i64], [4 x i64] }\u0026#34;\u0026gt; %214 = llvm.insertvalue %212, %213[0] : !llvm\u0026lt;\u0026#34;{ float*, float*, i64, [4 x i64], [4 x i64] }\u0026#34;\u0026gt; %215 = llvm.insertvalue %212, %214[1] : !llvm\u0026lt;\u0026#34;{ float*, float*, i64, [4 x i64], [4 x i64] }\u0026#34;\u0026gt; %216 = llvm.mlir.constant(0 : index) : !llvm.i64 %217 = llvm.insertvalue %216, %215[2] : !llvm\u0026lt;\u0026#34;{ float*, float*, i64, [4 x i64], [4 x i64] }\u0026#34;\u0026gt; %218 = llvm.mlir.constant(1 : index) : !llvm.i64 %219 = llvm.insertvalue %218, %217[3, 0] : !llvm\u0026lt;\u0026#34;{ float*, float*, i64, [4 x i64], [4 x i64] }\u0026#34;\u0026gt; %220 = llvm.mlir.constant(1568 : index) : !llvm.i64 %221 = llvm.insertvalue %220, %219[4, 0] : !llvm\u0026lt;\u0026#34;{ float*, float*, i64, [4 x i64], [4 x i64] }\u0026#34;\u0026gt; %222 = llvm.mlir.constant(8 : index) : !llvm.i64 %223 = llvm.insertvalue %222, %221[3, 1] : !llvm\u0026lt;\u0026#34;{ float*, float*, i64, [4 x i64], [4 x i64] }\u0026#34;\u0026gt; %224 = llvm.mlir.constant(196 : index) : !llvm.i64 %225 = llvm.insertvalue %224, %223[4, 1] : !llvm\u0026lt;\u0026#34;{ float*, float*, i64, [4 x i64], [4 x i64] }\u0026#34;\u0026gt; %226 = llvm.mlir.constant(14 : index) : !llvm.i64 %227 = llvm.insertvalue %226, %225[3, 2] : !llvm\u0026lt;\u0026#34;{ float*, float*, i64, [4 x i64], [4 x i64] }\u0026#34;\u0026gt; %228 = llvm.mlir.constant(14 : index) : !llvm.i64 %229 = llvm.insertvalue %228, %227[4, 2] : !llvm\u0026lt;\u0026#34;{ float*, float*, i64, [4 x i64], [4 x i64] }\u0026#34;\u0026gt; %230 = llvm.mlir.constant(14 : index) : !llvm.i64 %231 = llvm.insertvalue %230, %229[3, 3] : !llvm\u0026lt;\u0026#34;{ float*, float*, i64, [4 x i64], [4 x i64] }\u0026#34;\u0026gt; %232 = llvm.mlir.constant(1 : index) : !llvm.i64 %233 = llvm.insertvalue %232, %231[4, 3] : !llvm\u0026lt;\u0026#34;{ float*, float*, i64, [4 x i64], [4 x i64] }\u0026#34;\u0026gt; %234 = llvm.extractvalue %73[1] : !llvm\u0026lt;\u0026#34;{ i8*, i8*, i64, [1 x i64], [1 x i64] }\u0026#34;\u0026gt; %235 = llvm.getelementptr %234[%29] : (!llvm\u0026lt;\u0026#34;i8*\u0026#34;\u0026gt;, !llvm.i64) -\u0026gt; !llvm\u0026lt;\u0026#34;i8*\u0026#34;\u0026gt; %236 = llvm.bitcast %235 : !llvm\u0026lt;\u0026#34;i8*\u0026#34;\u0026gt; to !llvm\u0026lt;\u0026#34;float*\u0026#34;\u0026gt; %237 = llvm.mlir.undef : !llvm\u0026lt;\u0026#34;{ float*, float*, i64, [4 x i64], [4 x i64] }\u0026#34;\u0026gt; %238 = llvm.insertvalue %236, %237[0] : !llvm\u0026lt;\u0026#34;{ float*, float*, i64, [4 x i64], [4 x i64] }\u0026#34;\u0026gt; %239 = llvm.insertvalue %236, %238[1] : !llvm\u0026lt;\u0026#34;{ float*, float*, i64, [4 x i64], [4 x i64] }\u0026#34;\u0026gt; %240 = llvm.mlir.constant(0 : index) : !llvm.i64 %241 = llvm.insertvalue %240, %239[2] : !llvm\u0026lt;\u0026#34;{ float*, float*, i64, [4 x i64], [4 x i64] }\u0026#34;\u0026gt; %242 = llvm.mlir.constant(1 : index) : !llvm.i64 %243 = llvm.insertvalue %242, %241[3, 0] : !llvm\u0026lt;\u0026#34;{ float*, float*, i64, [4 x i64], [4 x i64] }\u0026#34;\u0026gt; %244 = llvm.mlir.constant(6272 : index) : !llvm.i64 %245 = llvm.insertvalue %244, %243[4, 0] : !llvm\u0026lt;\u0026#34;{ float*, float*, i64, [4 x i64], [4 x i64] }\u0026#34;\u0026gt; %246 = llvm.mlir.constant(8 : index) : !llvm.i64 %247 = llvm.insertvalue %246, %245[3, 1] : !llvm\u0026lt;\u0026#34;{ float*, float*, i64, [4 x i64], [4 x i64] }\u0026#34;\u0026gt; %248 = llvm.mlir.constant(784 : index) : !llvm.i64 %249 = llvm.insertvalue %248, %247[4, 1] : !llvm\u0026lt;\u0026#34;{ float*, float*, i64, [4 x i64], [4 x i64] }\u0026#34;\u0026gt; %250 = llvm.mlir.constant(28 : index) : !llvm.i64 %251 = llvm.insertvalue %250, %249[3, 2] : !llvm\u0026lt;\u0026#34;{ float*, float*, i64, [4 x i64], [4 x i64] }\u0026#34;\u0026gt; %252 = llvm.mlir.constant(28 : index) : !llvm.i64 %253 = llvm.insertvalue %252, %251[4, 2] : !llvm\u0026lt;\u0026#34;{ float*, float*, i64, [4 x i64], [4 x i64] }\u0026#34;\u0026gt; %254 = llvm.mlir.constant(28 : index) : !llvm.i64 %255 = llvm.insertvalue %254, %253[3, 3] : !llvm\u0026lt;\u0026#34;{ float*, float*, i64, [4 x i64], [4 x i64] }\u0026#34;\u0026gt; %256 = llvm.mlir.constant(1 : index) : !llvm.i64 %257 = llvm.insertvalue %256, %255[4, 3] : !llvm\u0026lt;\u0026#34;{ float*, float*, i64, [4 x i64], [4 x i64] }\u0026#34;\u0026gt; %258 = llvm.extractvalue %73[1] : !llvm\u0026lt;\u0026#34;{ i8*, i8*, i64, [1 x i64], [1 x i64] }\u0026#34;\u0026gt; %259 = llvm.getelementptr %258[%28] : (!llvm\u0026lt;\u0026#34;i8*\u0026#34;\u0026gt;, !llvm.i64) -\u0026gt; !llvm\u0026lt;\u0026#34;i8*\u0026#34;\u0026gt; %260 = llvm.bitcast %259 : !llvm\u0026lt;\u0026#34;i8*\u0026#34;\u0026gt; to !llvm\u0026lt;\u0026#34;float*\u0026#34;\u0026gt; %261 = llvm.mlir.undef : !llvm\u0026lt;\u0026#34;{ float*, float*, i64, [4 x i64], [4 x i64] }\u0026#34;\u0026gt; %262 = llvm.insertvalue %260, %261[0] : !llvm\u0026lt;\u0026#34;{ float*, float*, i64, [4 x i64], [4 x i64] }\u0026#34;\u0026gt; %263 = llvm.insertvalue %260, %262[1] : !llvm\u0026lt;\u0026#34;{ float*, float*, i64, [4 x i64], [4 x i64] }\u0026#34;\u0026gt; %264 = llvm.mlir.constant(0 : index) : !llvm.i64 %265 = llvm.insertvalue %264, %263[2] : !llvm\u0026lt;\u0026#34;{ float*, float*, i64, [4 x i64], [4 x i64] }\u0026#34;\u0026gt; %266 = llvm.mlir.constant(1 : index) : !llvm.i64 %267 = llvm.insertvalue %266, %265[3, 0] : !llvm\u0026lt;\u0026#34;{ float*, float*, i64, [4 x i64], [4 x i64] }\u0026#34;\u0026gt; %268 = llvm.mlir.constant(6272 : index) : !llvm.i64 %269 = llvm.insertvalue %268, %267[4, 0] : !llvm\u0026lt;\u0026#34;{ float*, float*, i64, [4 x i64], [4 x i64] }\u0026#34;\u0026gt; %270 = llvm.mlir.constant(8 : index) : !llvm.i64 %271 = llvm.insertvalue %270, %269[3, 1] : !llvm\u0026lt;\u0026#34;{ float*, float*, i64, [4 x i64], [4 x i64] }\u0026#34;\u0026gt; %272 = llvm.mlir.constant(784 : index) : !llvm.i64 %273 = llvm.insertvalue %272, %271[4, 1] : !llvm\u0026lt;\u0026#34;{ float*, float*, i64, [4 x i64], [4 x i64] }\u0026#34;\u0026gt; %274 = llvm.mlir.constant(28 : index) : !llvm.i64 %275 = llvm.insertvalue %274, %273[3, 2] : !llvm\u0026lt;\u0026#34;{ float*, float*, i64, [4 x i64], [4 x i64] }\u0026#34;\u0026gt; %276 = llvm.mlir.constant(28 : index) : !llvm.i64 %277 = llvm.insertvalue %276, %275[4, 2] : !llvm\u0026lt;\u0026#34;{ float*, float*, i64, [4 x i64], [4 x i64] }\u0026#34;\u0026gt; %278 = llvm.mlir.constant(28 : index) : !llvm.i64 %279 = llvm.insertvalue %278, %277[3, 3] : !llvm\u0026lt;\u0026#34;{ float*, float*, i64, [4 x i64], [4 x i64] }\u0026#34;\u0026gt; %280 = llvm.mlir.constant(1 : index) : !llvm.i64 %281 = llvm.insertvalue %280, %279[4, 3] : !llvm\u0026lt;\u0026#34;{ float*, float*, i64, [4 x i64], [4 x i64] }\u0026#34;\u0026gt; %282 = llvm.extractvalue %73[1] : !llvm\u0026lt;\u0026#34;{ i8*, i8*, i64, [1 x i64], [1 x i64] }\u0026#34;\u0026gt; %283 = llvm.getelementptr %282[%27] : (!llvm\u0026lt;\u0026#34;i8*\u0026#34;\u0026gt;, !llvm.i64) -\u0026gt; !llvm\u0026lt;\u0026#34;i8*\u0026#34;\u0026gt; %284 = llvm.bitcast %283 : !llvm\u0026lt;\u0026#34;i8*\u0026#34;\u0026gt; to !llvm\u0026lt;\u0026#34;float*\u0026#34;\u0026gt; %285 = llvm.mlir.undef : !llvm\u0026lt;\u0026#34;{ float*, float*, i64, [4 x i64], [4 x i64] }\u0026#34;\u0026gt; %286 = llvm.insertvalue %284, %285[0] : !llvm\u0026lt;\u0026#34;{ float*, float*, i64, [4 x i64], [4 x i64] }\u0026#34;\u0026gt; %287 = llvm.insertvalue %284, %286[1] : !llvm\u0026lt;\u0026#34;{ float*, float*, i64, [4 x i64], [4 x i64] }\u0026#34;\u0026gt; %288 = llvm.mlir.constant(0 : index) : !llvm.i64 %289 = llvm.insertvalue %288, %287[2] : !llvm\u0026lt;\u0026#34;{ float*, float*, i64, [4 x i64], [4 x i64] }\u0026#34;\u0026gt; %290 = llvm.mlir.constant(1 : index) : !llvm.i64 %291 = llvm.insertvalue %290, %289[3, 0] : !llvm\u0026lt;\u0026#34;{ float*, float*, i64, [4 x i64], [4 x i64] }\u0026#34;\u0026gt; %292 = llvm.mlir.constant(6272 : index) : !llvm.i64 %293 = llvm.insertvalue %292, %291[4, 0] : !llvm\u0026lt;\u0026#34;{ float*, float*, i64, [4 x i64], [4 x i64] }\u0026#34;\u0026gt; %294 = llvm.mlir.constant(8 : index) : !llvm.i64 %295 = llvm.insertvalue %294, %293[3, 1] : !llvm\u0026lt;\u0026#34;{ float*, float*, i64, [4 x i64], [4 x i64] }\u0026#34;\u0026gt; %296 = llvm.mlir.constant(784 : index) : !llvm.i64 %297 = llvm.insertvalue %296, %295[4, 1] : !llvm\u0026lt;\u0026#34;{ float*, float*, i64, [4 x i64], [4 x i64] }\u0026#34;\u0026gt; %298 = llvm.mlir.constant(28 : index) : !llvm.i64 %299 = llvm.insertvalue %298, %297[3, 2] : !llvm\u0026lt;\u0026#34;{ float*, float*, i64, [4 x i64], [4 x i64] }\u0026#34;\u0026gt; %300 = llvm.mlir.constant(28 : index) : !llvm.i64 %301 = llvm.insertvalue %300, %299[4, 2] : !llvm\u0026lt;\u0026#34;{ float*, float*, i64, [4 x i64], [4 x i64] }\u0026#34;\u0026gt; %302 = llvm.mlir.constant(28 : index) : !llvm.i64 %303 = llvm.insertvalue %302, %301[3, 3] : !llvm\u0026lt;\u0026#34;{ float*, float*, i64, [4 x i64], [4 x i64] }\u0026#34;\u0026gt; %304 = llvm.mlir.constant(1 : index) : !llvm.i64 %305 = llvm.insertvalue %304, %303[4, 3] : !llvm\u0026lt;\u0026#34;{ float*, float*, i64, [4 x i64], [4 x i64] }\u0026#34;\u0026gt; %306 = llvm.extractvalue %73[1] : !llvm\u0026lt;\u0026#34;{ i8*, i8*, i64, [1 x i64], [1 x i64] }\u0026#34;\u0026gt; %307 = llvm.getelementptr %306[%26] : (!llvm\u0026lt;\u0026#34;i8*\u0026#34;\u0026gt;, !llvm.i64) -\u0026gt; !llvm\u0026lt;\u0026#34;i8*\u0026#34;\u0026gt; %308 = llvm.bitcast %307 : !llvm\u0026lt;\u0026#34;i8*\u0026#34;\u0026gt; to !llvm\u0026lt;\u0026#34;float*\u0026#34;\u0026gt; %309 = llvm.mlir.undef : !llvm\u0026lt;\u0026#34;{ float*, float*, i64, [4 x i64], [4 x i64] }\u0026#34;\u0026gt; %310 = llvm.insertvalue %308, %309[0] : !llvm\u0026lt;\u0026#34;{ float*, float*, i64, [4 x i64], [4 x i64] }\u0026#34;\u0026gt; %311 = llvm.insertvalue %308, %310[1] : !llvm\u0026lt;\u0026#34;{ float*, float*, i64, [4 x i64], [4 x i64] }\u0026#34;\u0026gt; %312 = llvm.mlir.constant(0 : index) : !llvm.i64 %313 = llvm.insertvalue %312, %311[2] : !llvm\u0026lt;\u0026#34;{ float*, float*, i64, [4 x i64], [4 x i64] }\u0026#34;\u0026gt; %314 = llvm.mlir.constant(1 : index) : !llvm.i64 %315 = llvm.insertvalue %314, %313[3, 0] : !llvm\u0026lt;\u0026#34;{ float*, float*, i64, [4 x i64], [4 x i64] }\u0026#34;\u0026gt; %316 = llvm.mlir.constant(1024 : index) : !llvm.i64 %317 = llvm.insertvalue %316, %315[4, 0] : !llvm\u0026lt;\u0026#34;{ float*, float*, i64, [4 x i64], [4 x i64] }\u0026#34;\u0026gt; %318 = llvm.mlir.constant(1 : index) : !llvm.i64 %319 = llvm.insertvalue %318, %317[3, 1] : !llvm\u0026lt;\u0026#34;{ float*, float*, i64, [4 x i64], [4 x i64] }\u0026#34;\u0026gt; %320 = llvm.mlir.constant(1024 : index) : !llvm.i64 %321 = llvm.insertvalue %320, %319[4, 1] : !llvm\u0026lt;\u0026#34;{ float*, float*, i64, [4 x i64], [4 x i64] }\u0026#34;\u0026gt; %322 = llvm.mlir.constant(32 : index) : !llvm.i64 %323 = llvm.insertvalue %322, %321[3, 2] : !llvm\u0026lt;\u0026#34;{ float*, float*, i64, [4 x i64], [4 x i64] }\u0026#34;\u0026gt; %324 = llvm.mlir.constant(32 : index) : !llvm.i64 %325 = llvm.insertvalue %324, %323[4, 2] : !llvm\u0026lt;\u0026#34;{ float*, float*, i64, [4 x i64], [4 x i64] }\u0026#34;\u0026gt; %326 = llvm.mlir.constant(32 : index) : !llvm.i64 %327 = llvm.insertvalue %326, %325[3, 3] : !llvm\u0026lt;\u0026#34;{ float*, float*, i64, [4 x i64], [4 x i64] }\u0026#34;\u0026gt; %328 = llvm.mlir.constant(1 : index) : !llvm.i64 %329 = llvm.insertvalue %328, %327[4, 3] : !llvm\u0026lt;\u0026#34;{ float*, float*, i64, [4 x i64], [4 x i64] }\u0026#34;\u0026gt; %330 = llvm.extractvalue %73[1] : !llvm\u0026lt;\u0026#34;{ i8*, i8*, i64, [1 x i64], [1 x i64] }\u0026#34;\u0026gt; %331 = llvm.getelementptr %330[%25] : (!llvm\u0026lt;\u0026#34;i8*\u0026#34;\u0026gt;, !llvm.i64) -\u0026gt; !llvm\u0026lt;\u0026#34;i8*\u0026#34;\u0026gt; %332 = llvm.bitcast %331 : !llvm\u0026lt;\u0026#34;i8*\u0026#34;\u0026gt; to !llvm\u0026lt;\u0026#34;float*\u0026#34;\u0026gt; %333 = llvm.mlir.undef : !llvm\u0026lt;\u0026#34;{ float*, float*, i64, [2 x i64], [2 x i64] }\u0026#34;\u0026gt; %334 = llvm.insertvalue %332, %333[0] : !llvm\u0026lt;\u0026#34;{ float*, float*, i64, [2 x i64], [2 x i64] }\u0026#34;\u0026gt; %335 = llvm.insertvalue %332, %334[1] : !llvm\u0026lt;\u0026#34;{ float*, float*, i64, [2 x i64], [2 x i64] }\u0026#34;\u0026gt; %336 = llvm.mlir.constant(0 : index) : !llvm.i64 %337 = llvm.insertvalue %336, %335[2] : !llvm\u0026lt;\u0026#34;{ float*, float*, i64, [2 x i64], [2 x i64] }\u0026#34;\u0026gt; %338 = llvm.mlir.constant(256 : index) : !llvm.i64 %339 = llvm.insertvalue %338, %337[3, 0] : !llvm\u0026lt;\u0026#34;{ float*, float*, i64, [2 x i64], [2 x i64] }\u0026#34;\u0026gt; %340 = llvm.mlir.constant(10 : index) : !llvm.i64 %341 = llvm.insertvalue %340, %339[4, 0] : !llvm\u0026lt;\u0026#34;{ float*, float*, i64, [2 x i64], [2 x i64] }\u0026#34;\u0026gt; %342 = llvm.mlir.constant(10 : index) : !llvm.i64 %343 = llvm.insertvalue %342, %341[3, 1] : !llvm\u0026lt;\u0026#34;{ float*, float*, i64, [2 x i64], [2 x i64] }\u0026#34;\u0026gt; %344 = llvm.mlir.constant(1 : index) : !llvm.i64 %345 = llvm.insertvalue %344, %343[4, 1] : !llvm\u0026lt;\u0026#34;{ float*, float*, i64, [2 x i64], [2 x i64] }\u0026#34;\u0026gt; %346 = llvm.mlir.constant(1 : i64) : !llvm.i64 %347 = llvm.mlir.addressof @packedConst : !llvm\u0026lt;\u0026#34;i8**\u0026#34;\u0026gt; %348 = llvm.load %347 : !llvm\u0026lt;\u0026#34;i8**\u0026#34;\u0026gt; %349 = llvm.mlir.constant(0 : i64) : !llvm.i64 %350 = llvm.getelementptr %348[%349] : (!llvm\u0026lt;\u0026#34;i8*\u0026#34;\u0026gt;, !llvm.i64) -\u0026gt; !llvm\u0026lt;\u0026#34;i8*\u0026#34;\u0026gt; %351 = llvm.bitcast %350 : !llvm\u0026lt;\u0026#34;i8*\u0026#34;\u0026gt; to !llvm\u0026lt;\u0026#34;float*\u0026#34;\u0026gt; %352 = llvm.mlir.undef : !llvm\u0026lt;\u0026#34;{ float*, float*, i64, [4 x i64], [4 x i64] }\u0026#34;\u0026gt; %353 = llvm.insertvalue %351, %352[0] : !llvm\u0026lt;\u0026#34;{ float*, float*, i64, [4 x i64], [4 x i64] }\u0026#34;\u0026gt; %354 = llvm.insertvalue %351, %353[1] : !llvm\u0026lt;\u0026#34;{ float*, float*, i64, [4 x i64], [4 x i64] }\u0026#34;\u0026gt; %355 = llvm.mlir.constant(0 : index) : !llvm.i64 %356 = llvm.insertvalue %355, %354[2] : !llvm\u0026lt;\u0026#34;{ float*, float*, i64, [4 x i64], [4 x i64] }\u0026#34;\u0026gt; %357 = llvm.mlir.constant(16 : index) : !llvm.i64 %358 = llvm.insertvalue %357, %356[3, 0] : !llvm\u0026lt;\u0026#34;{ float*, float*, i64, [4 x i64], [4 x i64] }\u0026#34;\u0026gt; %359 = llvm.mlir.constant(160 : index) : !llvm.i64 %360 = llvm.insertvalue %359, %358[4, 0] : !llvm\u0026lt;\u0026#34;{ float*, float*, i64, [4 x i64], [4 x i64] }\u0026#34;\u0026gt; %361 = llvm.mlir.constant(4 : index) : !llvm.i64 %362 = llvm.insertvalue %361, %360[3, 1] : !llvm\u0026lt;\u0026#34;{ float*, float*, i64, [4 x i64], [4 x i64] }\u0026#34;\u0026gt; %363 = llvm.mlir.constant(40 : index) : !llvm.i64 %364 = llvm.insertvalue %363, %362[4, 1] : !llvm\u0026lt;\u0026#34;{ float*, float*, i64, [4 x i64], [4 x i64] }\u0026#34;\u0026gt; %365 = llvm.mlir.constant(4 : index) : !llvm.i64 %366 = llvm.insertvalue %365, %364[3, 2] : !llvm\u0026lt;\u0026#34;{ float*, float*, i64, [4 x i64], [4 x i64] }\u0026#34;\u0026gt; %367 = llvm.mlir.constant(10 : index) : !llvm.i64 %368 = llvm.insertvalue %367, %366[4, 2] : !llvm\u0026lt;\u0026#34;{ float*, float*, i64, [4 x i64], [4 x i64] }\u0026#34;\u0026gt; %369 = llvm.mlir.constant(10 : index) : !llvm.i64 %370 = llvm.insertvalue %369, %368[3, 3] : !llvm\u0026lt;\u0026#34;{ float*, float*, i64, [4 x i64], [4 x i64] }\u0026#34;\u0026gt; %371 = llvm.mlir.constant(1 : index) : !llvm.i64 %372 = llvm.insertvalue %371, %370[4, 3] : !llvm\u0026lt;\u0026#34;{ float*, float*, i64, [4 x i64], [4 x i64] }\u0026#34;\u0026gt; %373 = llvm.extractvalue %345[1] : !llvm\u0026lt;\u0026#34;{ float*, float*, i64, [2 x i64], [2 x i64] }\u0026#34;\u0026gt; %374 = llvm.bitcast %373 : !llvm\u0026lt;\u0026#34;float*\u0026#34;\u0026gt; to !llvm\u0026lt;\u0026#34;i8*\u0026#34;\u0026gt; %375 = llvm.extractvalue %372[1] : !llvm\u0026lt;\u0026#34;{ float*, float*, i64, [4 x i64], [4 x i64] }\u0026#34;\u0026gt; %376 = llvm.bitcast %375 : !llvm\u0026lt;\u0026#34;float*\u0026#34;\u0026gt; to !llvm\u0026lt;\u0026#34;i8*\u0026#34;\u0026gt; %377 = llvm.sext %26 : !llvm.i64 to !llvm.i64 %378 = llvm.mlir.constant(false) : !llvm.i1 %379 = llvm.call @llvm.memcpy.p0i8.p0i8.i64(%374, %376, %377, %378) : (!llvm\u0026lt;\u0026#34;i8*\u0026#34;\u0026gt;, !llvm\u0026lt;\u0026#34;i8*\u0026#34;\u0026gt;, !llvm.i64, !llvm.i1) -\u0026gt; !llvm.void %380 = llvm.mlir.constant(1 : i64) : !llvm.i64 %381 = llvm.mlir.addressof @packedConst : !llvm\u0026lt;\u0026#34;i8**\u0026#34;\u0026gt; %382 = llvm.load %381 : !llvm\u0026lt;\u0026#34;i8**\u0026#34;\u0026gt; %383 = llvm.mlir.constant(10240 : i64) : !llvm.i64 %384 = llvm.getelementptr %382[%383] : (!llvm\u0026lt;\u0026#34;i8*\u0026#34;\u0026gt;, !llvm.i64) -\u0026gt; !llvm\u0026lt;\u0026#34;i8*\u0026#34;\u0026gt; %385 = llvm.bitcast %384 : !llvm\u0026lt;\u0026#34;i8*\u0026#34;\u0026gt; to !llvm\u0026lt;\u0026#34;float*\u0026#34;\u0026gt; %386 = llvm.mlir.undef : !llvm\u0026lt;\u0026#34;{ float*, float*, i64, [4 x i64], [4 x i64] }\u0026#34;\u0026gt; %387 = llvm.insertvalue %385, %386[0] : !llvm\u0026lt;\u0026#34;{ float*, float*, i64, [4 x i64], [4 x i64] }\u0026#34;\u0026gt; %388 = llvm.insertvalue %385, %387[1] : !llvm\u0026lt;\u0026#34;{ float*, float*, i64, [4 x i64], [4 x i64] }\u0026#34;\u0026gt; %389 = llvm.mlir.constant(0 : index) : !llvm.i64 %390 = llvm.insertvalue %389, %388[2] : !llvm\u0026lt;\u0026#34;{ float*, float*, i64, [4 x i64], [4 x i64] }\u0026#34;\u0026gt; %391 = llvm.mlir.constant(8 : index) : !llvm.i64 %392 = llvm.insertvalue %391, %390[3, 0] : !llvm\u0026lt;\u0026#34;{ float*, float*, i64, [4 x i64], [4 x i64] }\u0026#34;\u0026gt; %393 = llvm.mlir.constant(25 : index) : !llvm.i64 %394 = llvm.insertvalue %393, %392[4, 0] : !llvm\u0026lt;\u0026#34;{ float*, float*, i64, [4 x i64], [4 x i64] }\u0026#34;\u0026gt; %395 = llvm.mlir.constant(1 : index) : !llvm.i64 %396 = llvm.insertvalue %395, %394[3, 1] : !llvm\u0026lt;\u0026#34;{ float*, float*, i64, [4 x i64], [4 x i64] }\u0026#34;\u0026gt; %397 = llvm.mlir.constant(25 : index) : !llvm.i64 %398 = llvm.insertvalue %397, %396[4, 1] : !llvm\u0026lt;\u0026#34;{ float*, float*, i64, [4 x i64], [4 x i64] }\u0026#34;\u0026gt; %399 = llvm.mlir.constant(5 : index) : !llvm.i64 %400 = llvm.insertvalue %399, %398[3, 2] : !llvm\u0026lt;\u0026#34;{ float*, float*, i64, [4 x i64], [4 x i64] }\u0026#34;\u0026gt; %401 = llvm.mlir.constant(5 : index) : !llvm.i64 %402 = llvm.insertvalue %401, %400[4, 2] : !llvm\u0026lt;\u0026#34;{ float*, float*, i64, [4 x i64], [4 x i64] }\u0026#34;\u0026gt; %403 = llvm.mlir.constant(5 : index) : !llvm.i64 %404 = llvm.insertvalue %403, %402[3, 3] : !llvm\u0026lt;\u0026#34;{ float*, float*, i64, [4 x i64], [4 x i64] }\u0026#34;\u0026gt; %405 = llvm.mlir.constant(1 : index) : !llvm.i64 %406 = llvm.insertvalue %405, %404[4, 3] : !llvm\u0026lt;\u0026#34;{ float*, float*, i64, [4 x i64], [4 x i64] }\u0026#34;\u0026gt; %407 = llvm.mlir.constant(0 : index) : !llvm.i64 %408 = llvm.mlir.constant(1 : index) : !llvm.i64 %409 = llvm.mlir.constant(1 : index) : !llvm.i64 llvm.br ^bb1(%407 : !llvm.i64) ^bb1(%410: !llvm.i64): // 2 preds: ^bb0, ^bb11 %411 = llvm.icmp \u0026#34;slt\u0026#34; %410, %408 : !llvm.i64 llvm.cond_br %411, ^bb2, ^bb12 ^bb2: // pred: ^bb1 %412 = llvm.mlir.constant(0 : index) : !llvm.i64 %413 = llvm.mlir.constant(1 : index) : !llvm.i64 %414 = llvm.mlir.constant(1 : index) : !llvm.i64 llvm.br ^bb3(%412 : !llvm.i64) ^bb3(%415: !llvm.i64): // 2 preds: ^bb2, ^bb10 %416 = llvm.icmp \u0026#34;slt\u0026#34; %415, %413 : !llvm.i64 llvm.cond_br %416, ^bb4, ^bb11 ^bb4: // pred: ^bb3 %417 = llvm.mlir.constant(0 : index) : !llvm.i64 %418 = llvm.mlir.constant(32 : index) : !llvm.i64 %419 = llvm.mlir.constant(1 : index) : !llvm.i64 llvm.br ^bb5(%417 : !llvm.i64) ^bb5(%420: !llvm.i64): // 2 preds: ^bb4, ^bb9 %421 = llvm.icmp \u0026#34;slt\u0026#34; %420, %418 : !llvm.i64 llvm.cond_br %421, ^bb6, ^bb10 ^bb6: // pred: ^bb5 %422 = llvm.mlir.constant(0 : index) : !llvm.i64 %423 = llvm.mlir.constant(32 : index) : !llvm.i64 %424 = llvm.mlir.constant(1 : index) : !llvm.i64 llvm.br ^bb7(%422 : !llvm.i64) ^bb7(%425: !llvm.i64): // 2 preds: ^bb6, ^bb8 %426 = llvm.icmp \u0026#34;slt\u0026#34; %425, %423 : !llvm.i64 llvm.cond_br %426, ^bb8, ^bb9 ^bb8: // pred: ^bb7 %427 = llvm.extractvalue %329[1] : !llvm\u0026lt;\u0026#34;{ float*, float*, i64, [4 x i64], [4 x i64] }\u0026#34;\u0026gt; %428 = llvm.mlir.constant(0 : index) : !llvm.i64 %429 = llvm.mlir.constant(1024 : index) : !llvm.i64 %430 = llvm.mul %410, %429 : !llvm.i64 %431 = llvm.add %428, %430 : !llvm.i64 %432 = llvm.mlir.constant(1024 : index) : !llvm.i64 %433 = llvm.mul %415, %432 : !llvm.i64 %434 = llvm.add %431, %433 : !llvm.i64 %435 = llvm.mlir.constant(32 : index) : !llvm.i64 %436 = llvm.mul %420, %435 : !llvm.i64 %437 = llvm.add %434, %436 : !llvm.i64 %438 = llvm.mlir.constant(1 : index) : !llvm.i64 %439 = llvm.mul %425, %438 : !llvm.i64 %440 = llvm.add %437, %439 : !llvm.i64 %441 = llvm.getelementptr %427[%440] : (!llvm\u0026lt;\u0026#34;float*\u0026#34;\u0026gt;, !llvm.i64) -\u0026gt; !llvm\u0026lt;\u0026#34;float*\u0026#34;\u0026gt; llvm.store %23, %441 : !llvm\u0026lt;\u0026#34;float*\u0026#34;\u0026gt; %442 = llvm.add %425, %424 : !llvm.i64 llvm.br ^bb7(%442 : !llvm.i64) ^bb9: // pred: ^bb7 %443 = llvm.add %420, %419 : !llvm.i64 llvm.br ^bb5(%443 : !llvm.i64) ^bb10: // pred: ^bb5 %444 = llvm.add %415, %414 : !llvm.i64 llvm.br ^bb3(%444 : !llvm.i64) ^bb11: // pred: ^bb3 %445 = llvm.add %410, %409 : !llvm.i64 llvm.br ^bb1(%445 : !llvm.i64) ^bb12: // pred: ^bb1 %446 = llvm.mlir.constant(0 : index) : !llvm.i64 %447 = llvm.mlir.constant(1 : index) : !llvm.i64 %448 = llvm.mlir.constant(1 : index) : !llvm.i64 llvm.br ^bb13(%446 : !llvm.i64) ^bb13(%449: !llvm.i64): // 2 preds: ^bb12, ^bb23 %450 = llvm.icmp \u0026#34;slt\u0026#34; %449, %447 : !llvm.i64 llvm.cond_br %450, ^bb14, ^bb24 ^bb14: // pred: ^bb13 %451 = llvm.mlir.constant(0 : index) : !llvm.i64 %452 = llvm.mlir.constant(1 : index) : !llvm.i64 %453 = llvm.mlir.constant(1 : index) : !llvm.i64 llvm.br ^bb15(%451 : !llvm.i64) ^bb15(%454: !llvm.i64): // 2 preds: ^bb14, ^bb22 %455 = llvm.icmp \u0026#34;slt\u0026#34; %454, %452 : !llvm.i64 llvm.cond_br %455, ^bb16, ^bb23 ^bb16: // pred: ^bb15 %456 = llvm.mlir.constant(0 : index) : !llvm.i64 %457 = llvm.mlir.constant(28 : index) : !llvm.i64 %458 = llvm.mlir.constant(1 : index) : !llvm.i64 llvm.br ^bb17(%456 : !llvm.i64) ^bb17(%459: !llvm.i64): // 2 preds: ^bb16, ^bb21 %460 = llvm.icmp \u0026#34;slt\u0026#34; %459, %457 : !llvm.i64 llvm.cond_br %460, ^bb18, ^bb22 ^bb18: // pred: ^bb17 %461 = llvm.mlir.constant(0 : index) : !llvm.i64 %462 = llvm.mlir.constant(28 : index) : !llvm.i64 %463 = llvm.mlir.constant(1 : index) : !llvm.i64 llvm.br ^bb19(%461 : !llvm.i64) ^bb19(%464: !llvm.i64): // 2 preds: ^bb18, ^bb20 %465 = llvm.icmp \u0026#34;slt\u0026#34; %464, %462 : !llvm.i64 llvm.cond_br %465, ^bb20, ^bb21 ^bb20: // pred: ^bb19 %466 = llvm.extractvalue %11[1] : !llvm\u0026lt;\u0026#34;{ float*, float*, i64, [4 x i64], [4 x i64] }\u0026#34;\u0026gt; %467 = llvm.mlir.constant(0 : index) : !llvm.i64 %468 = llvm.mlir.constant(784 : index) : !llvm.i64 %469 = llvm.mul %449, %468 : !llvm.i64 %470 = llvm.add %467, %469 : !llvm.i64 %471 = llvm.mlir.constant(784 : index) : !llvm.i64 %472 = llvm.mul %454, %471 : !llvm.i64 %473 = llvm.add %470, %472 : !llvm.i64 %474 = llvm.mlir.constant(28 : index) : !llvm.i64 %475 = llvm.mul %459, %474 : !llvm.i64 %476 = llvm.add %473, %475 : !llvm.i64 %477 = llvm.mlir.constant(1 : index) : !llvm.i64 %478 = llvm.mul %464, %477 : !llvm.i64 %479 = llvm.add %476, %478 : !llvm.i64 %480 = llvm.getelementptr %466[%479] : (!llvm\u0026lt;\u0026#34;float*\u0026#34;\u0026gt;, !llvm.i64) -\u0026gt; !llvm\u0026lt;\u0026#34;float*\u0026#34;\u0026gt; %481 = llvm.load %480 : !llvm\u0026lt;\u0026#34;float*\u0026#34;\u0026gt; %482 = llvm.mlir.constant(2 : index) : !llvm.i64 %483 = llvm.add %459, %482 : !llvm.i64 %484 = llvm.mlir.constant(2 : index) : !llvm.i64 %485 = llvm.add %464, %484 : !llvm.i64 %486 = llvm.extractvalue %329[1] : !llvm\u0026lt;\u0026#34;{ float*, float*, i64, [4 x i64], [4 x i64] }\u0026#34;\u0026gt; %487 = llvm.mlir.constant(0 : index) : !llvm.i64 %488 = llvm.mlir.constant(1024 : index) : !llvm.i64 %489 = llvm.mul %449, %488 : !llvm.i64 %490 = llvm.add %487, %489 : !llvm.i64 %491 = llvm.mlir.constant(1024 : index) : !llvm.i64 %492 = llvm.mul %454, %491 : !llvm.i64 %493 = llvm.add %490, %492 : !llvm.i64 %494 = llvm.mlir.constant(32 : index) : !llvm.i64 %495 = llvm.mul %483, %494 : !llvm.i64 %496 = llvm.add %493, %495 : !llvm.i64 %497 = llvm.mlir.constant(1 : index) : !llvm.i64 %498 = llvm.mul %485, %497 : !llvm.i64 %499 = llvm.add %496, %498 : !llvm.i64 %500 = llvm.getelementptr %486[%499] : (!llvm\u0026lt;\u0026#34;float*\u0026#34;\u0026gt;, !llvm.i64) -\u0026gt; !llvm\u0026lt;\u0026#34;float*\u0026#34;\u0026gt; llvm.store %481, %500 : !llvm\u0026lt;\u0026#34;float*\u0026#34;\u0026gt; %501 = llvm.add %464, %463 : !llvm.i64 llvm.br ^bb19(%501 : !llvm.i64) ^bb21: // pred: ^bb19 %502 = llvm.add %459, %458 : !llvm.i64 llvm.br ^bb17(%502 : !llvm.i64) ^bb22: // pred: ^bb17 %503 = llvm.add %454, %453 : !llvm.i64 llvm.br ^bb15(%503 : !llvm.i64) ^bb23: // pred: ^bb15 %504 = llvm.add %449, %448 : !llvm.i64 llvm.br ^bb13(%504 : !llvm.i64) ^bb24: // pred: ^bb13 %505 = llvm.mlir.constant(0 : index) : !llvm.i64 %506 = llvm.mlir.constant(1 : index) : !llvm.i64 %507 = llvm.mlir.constant(1 : index) : !llvm.i64 llvm.br ^bb25(%505 : !llvm.i64) ^bb25(%508: !llvm.i64): // 2 preds: ^bb24, ^bb44 %509 = llvm.icmp \u0026#34;slt\u0026#34; %508, %506 : !llvm.i64 llvm.cond_br %509, ^bb26, ^bb45 ^bb26: // pred: ^bb25 %510 = llvm.mlir.constant(0 : index) : !llvm.i64 %511 = llvm.mlir.constant(8 : index) : !llvm.i64 %512 = llvm.mlir.constant(1 : index) : !llvm.i64 llvm.br ^bb27(%510 : !llvm.i64) ^bb27(%513: !llvm.i64): // 2 preds: ^bb26, ^bb43 %514 = llvm.icmp \u0026#34;slt\u0026#34; %513, %511 : !llvm.i64 llvm.cond_br %514, ^bb28, ^bb44 ^bb28: // pred: ^bb27 %515 = llvm.mlir.constant(0 : index) : !llvm.i64 %516 = llvm.mlir.constant(28 : index) : !llvm.i64 %517 = llvm.mlir.constant(1 : index) : !llvm.i64 llvm.br ^bb29(%515 : !llvm.i64) ^bb29(%518: !llvm.i64): // 2 preds: ^bb28, ^bb42 %519 = llvm.icmp \u0026#34;slt\u0026#34; %518, %516 : !llvm.i64 llvm.cond_br %519, ^bb30, ^bb43 ^bb30: // pred: ^bb29 %520 = llvm.mlir.constant(0 : index) : !llvm.i64 %521 = llvm.mlir.constant(28 : index) : !llvm.i64 %522 = llvm.mlir.constant(1 : index) : !llvm.i64 llvm.br ^bb31(%520 : !llvm.i64) ^bb31(%523: !llvm.i64): // 2 preds: ^bb30, ^bb41 %524 = llvm.icmp \u0026#34;slt\u0026#34; %523, %521 : !llvm.i64 llvm.cond_br %524, ^bb32, ^bb42 ^bb32: // pred: ^bb31 %525 = llvm.extractvalue %305[1] : !llvm\u0026lt;\u0026#34;{ float*, float*, i64, [4 x i64], [4 x i64] }\u0026#34;\u0026gt; %526 = llvm.mlir.constant(0 : index) : !llvm.i64 %527 = llvm.mlir.constant(6272 : index) : !llvm.i64 %528 = llvm.mul %508, %527 : !llvm.i64 %529 = llvm.add %526, %528 : !llvm.i64 %530 = llvm.mlir.constant(784 : index) : !llvm.i64 %531 = llvm.mul %513, %530 : !llvm.i64 %532 = llvm.add %529, %531 : !llvm.i64 %533 = llvm.mlir.constant(28 : index) : !llvm.i64 %534 = llvm.mul %518, %533 : !llvm.i64 %535 = llvm.add %532, %534 : !llvm.i64 %536 = llvm.mlir.constant(1 : index) : !llvm.i64 %537 = llvm.mul %523, %536 : !llvm.i64 %538 = llvm.add %535, %537 : !llvm.i64 %539 = llvm.getelementptr %525[%538] : (!llvm\u0026lt;\u0026#34;float*\u0026#34;\u0026gt;, !llvm.i64) -\u0026gt; !llvm\u0026lt;\u0026#34;float*\u0026#34;\u0026gt; llvm.store %23, %539 : !llvm\u0026lt;\u0026#34;float*\u0026#34;\u0026gt; %540 = llvm.mlir.constant(0 : index) : !llvm.i64 %541 = llvm.mlir.constant(1 : index) : !llvm.i64 %542 = llvm.mlir.constant(1 : index) : !llvm.i64 llvm.br ^bb33(%540 : !llvm.i64) ^bb33(%543: !llvm.i64): // 2 preds: ^bb32, ^bb40 %544 = llvm.icmp \u0026#34;slt\u0026#34; %543, %541 : !llvm.i64 llvm.cond_br %544, ^bb34, ^bb41 ^bb34: // pred: ^bb33 %545 = llvm.mlir.constant(0 : index) : !llvm.i64 %546 = llvm.mlir.constant(5 : index) : !llvm.i64 %547 = llvm.mlir.constant(1 : index) : !llvm.i64 llvm.br ^bb35(%545 : !llvm.i64) ^bb35(%548: !llvm.i64): // 2 preds: ^bb34, ^bb39 %549 = llvm.icmp \u0026#34;slt\u0026#34; %548, %546 : !llvm.i64 llvm.cond_br %549, ^bb36, ^bb40 ^bb36: // pred: ^bb35 %550 = llvm.mlir.constant(0 : index) : !llvm.i64 %551 = llvm.mlir.constant(5 : index) : !llvm.i64 %552 = llvm.mlir.constant(1 : index) : !llvm.i64 llvm.br ^bb37(%550 : !llvm.i64) ^bb37(%553: !llvm.i64): // 2 preds: ^bb36, ^bb38 %554 = llvm.icmp \u0026#34;slt\u0026#34; %553, %551 : !llvm.i64 llvm.cond_br %554, ^bb38, ^bb39 ^bb38: // pred: ^bb37 %555 = llvm.add %518, %548 : !llvm.i64 %556 = llvm.add %523, %553 : !llvm.i64 %557 = llvm.extractvalue %329[1] : !llvm\u0026lt;\u0026#34;{ float*, float*, i64, [4 x i64], [4 x i64] }\u0026#34;\u0026gt; %558 = llvm.mlir.constant(0 : index) : !llvm.i64 %559 = llvm.mlir.constant(1024 : index) : !llvm.i64 %560 = llvm.mul %508, %559 : !llvm.i64 %561 = llvm.add %558, %560 : !llvm.i64 %562 = llvm.mlir.constant(1024 : index) : !llvm.i64 %563 = llvm.mul %543, %562 : !llvm.i64 %564 = llvm.add %561, %563 : !llvm.i64 %565 = llvm.mlir.constant(32 : index) : !llvm.i64 %566 = llvm.mul %555, %565 : !llvm.i64 %567 = llvm.add %564, %566 : !llvm.i64 %568 = llvm.mlir.constant(1 : index) : !llvm.i64 %569 = llvm.mul %556, %568 : !llvm.i64 %570 = llvm.add %567, %569 : !llvm.i64 %571 = llvm.getelementptr %557[%570] : (!llvm\u0026lt;\u0026#34;float*\u0026#34;\u0026gt;, !llvm.i64) -\u0026gt; !llvm\u0026lt;\u0026#34;float*\u0026#34;\u0026gt; %572 = llvm.load %571 : !llvm\u0026lt;\u0026#34;float*\u0026#34;\u0026gt; %573 = llvm.extractvalue %406[1] : !llvm\u0026lt;\u0026#34;{ float*, float*, i64, [4 x i64], [4 x i64] }\u0026#34;\u0026gt; %574 = llvm.mlir.constant(0 : index) : !llvm.i64 %575 = llvm.mlir.constant(25 : index) : !llvm.i64 %576 = llvm.mul %513, %575 : !llvm.i64 %577 = llvm.add %574, %576 : !llvm.i64 %578 = llvm.mlir.constant(25 : index) : !llvm.i64 %579 = llvm.mul %543, %578 : !llvm.i64 %580 = llvm.add %577, %579 : !llvm.i64 %581 = llvm.mlir.constant(5 : index) : !llvm.i64 %582 = llvm.mul %548, %581 : !llvm.i64 %583 = llvm.add %580, %582 : !llvm.i64 %584 = llvm.mlir.constant(1 : index) : !llvm.i64 %585 = llvm.mul %553, %584 : !llvm.i64 %586 = llvm.add %583, %585 : !llvm.i64 %587 = llvm.getelementptr %573[%586] : (!llvm\u0026lt;\u0026#34;float*\u0026#34;\u0026gt;, !llvm.i64) -\u0026gt; !llvm\u0026lt;\u0026#34;float*\u0026#34;\u0026gt; %588 = llvm.load %587 : !llvm\u0026lt;\u0026#34;float*\u0026#34;\u0026gt; %589 = llvm.extractvalue %305[1] : !llvm\u0026lt;\u0026#34;{ float*, float*, i64, [4 x i64], [4 x i64] }\u0026#34;\u0026gt; %590 = llvm.mlir.constant(0 : index) : !llvm.i64 %591 = llvm.mlir.constant(6272 : index) : !llvm.i64 %592 = llvm.mul %508, %591 : !llvm.i64 %593 = llvm.add %590, %592 : !llvm.i64 %594 = llvm.mlir.constant(784 : index) : !llvm.i64 %595 = llvm.mul %513, %594 : !llvm.i64 %596 = llvm.add %593, %595 : !llvm.i64 %597 = llvm.mlir.constant(28 : index) : !llvm.i64 %598 = llvm.mul %518, %597 : !llvm.i64 %599 = llvm.add %596, %598 : !llvm.i64 %600 = llvm.mlir.constant(1 : index) : !llvm.i64 %601 = llvm.mul %523, %600 : !llvm.i64 %602 = llvm.add %599, %601 : !llvm.i64 %603 = llvm.getelementptr %589[%602] : (!llvm\u0026lt;\u0026#34;float*\u0026#34;\u0026gt;, !llvm.i64) -\u0026gt; !llvm\u0026lt;\u0026#34;float*\u0026#34;\u0026gt; %604 = llvm.load %603 : !llvm\u0026lt;\u0026#34;float*\u0026#34;\u0026gt; %605 = llvm.fmul %572, %588 : !llvm.float %606 = llvm.fadd %604, %605 : !llvm.float %607 = llvm.extractvalue %305[1] : !llvm\u0026lt;\u0026#34;{ float*, float*, i64, [4 x i64], [4 x i64] }\u0026#34;\u0026gt; %608 = llvm.mlir.constant(0 : index) : !llvm.i64 %609 = llvm.mlir.constant(6272 : index) : !llvm.i64 %610 = llvm.mul %508, %609 : !llvm.i64 %611 = llvm.add %608, %610 : !llvm.i64 %612 = llvm.mlir.constant(784 : index) : !llvm.i64 %613 = llvm.mul %513, %612 : !llvm.i64 %614 = llvm.add %611, %613 : !llvm.i64 %615 = llvm.mlir.constant(28 : index) : !llvm.i64 %616 = llvm.mul %518, %615 : !llvm.i64 %617 = llvm.add %614, %616 : !llvm.i64 %618 = llvm.mlir.constant(1 : index) : !llvm.i64 %619 = llvm.mul %523, %618 : !llvm.i64 %620 = llvm.add %617, %619 : !llvm.i64 %621 = llvm.getelementptr %607[%620] : (!llvm\u0026lt;\u0026#34;float*\u0026#34;\u0026gt;, !llvm.i64) -\u0026gt; !llvm\u0026lt;\u0026#34;float*\u0026#34;\u0026gt; llvm.store %606, %621 : !llvm\u0026lt;\u0026#34;float*\u0026#34;\u0026gt; %622 = llvm.add %553, %552 : !llvm.i64 llvm.br ^bb37(%622 : !llvm.i64) ^bb39: // pred: ^bb37 %623 = llvm.add %548, %547 : !llvm.i64 llvm.br ^bb35(%623 : !llvm.i64) ^bb40: // pred: ^bb35 %624 = llvm.add %543, %542 : !llvm.i64 llvm.br ^bb33(%624 : !llvm.i64) ^bb41: // pred: ^bb33 %625 = llvm.add %523, %522 : !llvm.i64 llvm.br ^bb31(%625 : !llvm.i64) ^bb42: // pred: ^bb31 %626 = llvm.add %518, %517 : !llvm.i64 llvm.br ^bb29(%626 : !llvm.i64) ^bb43: // pred: ^bb29 %627 = llvm.add %513, %512 : !llvm.i64 llvm.br ^bb27(%627 : !llvm.i64) ^bb44: // pred: ^bb27 %628 = llvm.add %508, %507 : !llvm.i64 llvm.br ^bb25(%628 : !llvm.i64) ^bb45: // pred: ^bb25 %629 = llvm.mlir.constant(1 : i64) : !llvm.i64 %630 = llvm.alloca %629 x !llvm\u0026lt;\u0026#34;[8 x [1 x [1 x float]]]\u0026#34;\u0026gt; : (!llvm.i64) -\u0026gt; !llvm\u0026lt;\u0026#34;[8 x [1 x [1 x float]]]*\u0026#34;\u0026gt; %631 = llvm.bitcast %630 : !llvm\u0026lt;\u0026#34;[8 x [1 x [1 x float]]]*\u0026#34;\u0026gt; to !llvm\u0026lt;\u0026#34;i8*\u0026#34;\u0026gt; %632 = llvm.mlir.addressof @constant_2 : !llvm\u0026lt;\u0026#34;[8 x [1 x [1 x float]]]*\u0026#34;\u0026gt; %633 = llvm.bitcast %632 : !llvm\u0026lt;\u0026#34;[8 x [1 x [1 x float]]]*\u0026#34;\u0026gt; to !llvm\u0026lt;\u0026#34;i8*\u0026#34;\u0026gt; %634 = llvm.mlir.constant(4 : i64) : !llvm.i64 %635 = llvm.mlir.constant(8 : i64) : !llvm.i64 %636 = llvm.mul %634, %635 : !llvm.i64 %637 = llvm.sext %636 : !llvm.i64 to !llvm.i64 %638 = llvm.mlir.constant(false) : !llvm.i1 %639 = llvm.call @llvm.memcpy.p0i8.p0i8.i64(%631, %633, %637, %638) : (!llvm\u0026lt;\u0026#34;i8*\u0026#34;\u0026gt;, !llvm\u0026lt;\u0026#34;i8*\u0026#34;\u0026gt;, !llvm.i64, !llvm.i1) -\u0026gt; !llvm.void %640 = llvm.bitcast %630 : !llvm\u0026lt;\u0026#34;[8 x [1 x [1 x float]]]*\u0026#34;\u0026gt; to !llvm\u0026lt;\u0026#34;float*\u0026#34;\u0026gt; %641 = llvm.mlir.undef : !llvm\u0026lt;\u0026#34;{ float*, float*, i64, [3 x i64], [3 x i64] }\u0026#34;\u0026gt; %642 = llvm.insertvalue %640, %641[0] : !llvm\u0026lt;\u0026#34;{ float*, float*, i64, [3 x i64], [3 x i64] }\u0026#34;\u0026gt; %643 = llvm.insertvalue %640, %642[1] : !llvm\u0026lt;\u0026#34;{ float*, float*, i64, [3 x i64], [3 x i64] }\u0026#34;\u0026gt; %644 = llvm.mlir.constant(0 : index) : !llvm.i64 %645 = llvm.insertvalue %644, %643[2] : !llvm\u0026lt;\u0026#34;{ float*, float*, i64, [3 x i64], [3 x i64] }\u0026#34;\u0026gt; %646 = llvm.mlir.constant(8 : index) : !llvm.i64 %647 = llvm.insertvalue %646, %645[3, 0] : !llvm\u0026lt;\u0026#34;{ float*, float*, i64, [3 x i64], [3 x i64] }\u0026#34;\u0026gt; %648 = llvm.mlir.constant(1 : index) : !llvm.i64 %649 = llvm.insertvalue %648, %647[4, 0] : !llvm\u0026lt;\u0026#34;{ float*, float*, i64, [3 x i64], [3 x i64] }\u0026#34;\u0026gt; %650 = llvm.mlir.constant(1 : index) : !llvm.i64 %651 = llvm.insertvalue %650, %649[3, 1] : !llvm\u0026lt;\u0026#34;{ float*, float*, i64, [3 x i64], [3 x i64] }\u0026#34;\u0026gt; %652 = llvm.mlir.constant(1 : index) : !llvm.i64 %653 = llvm.insertvalue %652, %651[4, 1] : !llvm\u0026lt;\u0026#34;{ float*, float*, i64, [3 x i64], [3 x i64] }\u0026#34;\u0026gt; %654 = llvm.mlir.constant(1 : index) : !llvm.i64 %655 = llvm.insertvalue %654, %653[3, 2] : !llvm\u0026lt;\u0026#34;{ float*, float*, i64, [3 x i64], [3 x i64] }\u0026#34;\u0026gt; %656 = llvm.mlir.constant(1 : index) : !llvm.i64 %657 = llvm.insertvalue %656, %655[4, 2] : !llvm\u0026lt;\u0026#34;{ float*, float*, i64, [3 x i64], [3 x i64] }\u0026#34;\u0026gt; %658 = llvm.mlir.constant(0 : index) : !llvm.i64 %659 = llvm.mlir.constant(1 : index) : !llvm.i64 %660 = llvm.mlir.constant(1 : index) : !llvm.i64 llvm.br ^bb46(%658 : !llvm.i64) ^bb46(%661: !llvm.i64): // 2 preds: ^bb45, ^bb56 %662 = llvm.icmp \u0026#34;slt\u0026#34; %661, %659 : !llvm.i64 llvm.cond_br %662, ^bb47, ^bb57 ^bb47: // pred: ^bb46 %663 = llvm.mlir.constant(0 : index) : !llvm.i64 %664 = llvm.mlir.constant(8 : index) : !llvm.i64 %665 = llvm.mlir.constant(1 : index) : !llvm.i64 llvm.br ^bb48(%663 : !llvm.i64) ^bb48(%666: !llvm.i64): // 2 preds: ^bb47, ^bb55 %667 = llvm.icmp \u0026#34;slt\u0026#34; %666, %664 : !llvm.i64 llvm.cond_br %667, ^bb49, ^bb56 ^bb49: // pred: ^bb48 %668 = llvm.mlir.constant(0 : index) : !llvm.i64 %669 = llvm.mlir.constant(28 : index) : !llvm.i64 %670 = llvm.mlir.constant(1 : index) : !llvm.i64 llvm.br ^bb50(%668 : !llvm.i64) ^bb50(%671: !llvm.i64): // 2 preds: ^bb49, ^bb54 %672 = llvm.icmp \u0026#34;slt\u0026#34; %671, %669 : !llvm.i64 llvm.cond_br %672, ^bb51, ^bb55 ^bb51: // pred: ^bb50 %673 = llvm.mlir.constant(0 : index) : !llvm.i64 %674 = llvm.mlir.constant(28 : index) : !llvm.i64 %675 = llvm.mlir.constant(1 : index) : !llvm.i64 llvm.br ^bb52(%673 : !llvm.i64) ^bb52(%676: !llvm.i64): // 2 preds: ^bb51, ^bb53 %677 = llvm.icmp \u0026#34;slt\u0026#34; %676, %674 : !llvm.i64 llvm.cond_br %677, ^bb53, ^bb54 ^bb53: // pred: ^bb52 %678 = llvm.mlir.constant(0 : index) : !llvm.i64 %679 = llvm.extractvalue %305[1] : !llvm\u0026lt;\u0026#34;{ float*, float*, i64, [4 x i64], [4 x i64] }\u0026#34;\u0026gt; %680 = llvm.mlir.constant(0 : index) : !llvm.i64 %681 = llvm.mlir.constant(6272 : index) : !llvm.i64 %682 = llvm.mul %678, %681 : !llvm.i64 %683 = llvm.add %680, %682 : !llvm.i64 %684 = llvm.mlir.constant(784 : index) : !llvm.i64 %685 = llvm.mul %666, %684 : !llvm.i64 %686 = llvm.add %683, %685 : !llvm.i64 %687 = llvm.mlir.constant(28 : index) : !llvm.i64 %688 = llvm.mul %671, %687 : !llvm.i64 %689 = llvm.add %686, %688 : !llvm.i64 %690 = llvm.mlir.constant(1 : index) : !llvm.i64 %691 = llvm.mul %676, %690 : !llvm.i64 %692 = llvm.add %689, %691 : !llvm.i64 %693 = llvm.getelementptr %679[%692] : (!llvm\u0026lt;\u0026#34;float*\u0026#34;\u0026gt;, !llvm.i64) -\u0026gt; !llvm\u0026lt;\u0026#34;float*\u0026#34;\u0026gt; %694 = llvm.load %693 : !llvm\u0026lt;\u0026#34;float*\u0026#34;\u0026gt; %695 = llvm.mlir.constant(0 : index) : !llvm.i64 %696 = llvm.mlir.constant(0 : index) : !llvm.i64 %697 = llvm.extractvalue %657[1] : !llvm\u0026lt;\u0026#34;{ float*, float*, i64, [3 x i64], [3 x i64] }\u0026#34;\u0026gt; %698 = llvm.mlir.constant(0 : index) : !llvm.i64 %699 = llvm.mlir.constant(1 : index) : !llvm.i64 %700 = llvm.mul %666, %699 : !llvm.i64 %701 = llvm.add %698, %700 : !llvm.i64 %702 = llvm.mlir.constant(1 : index) : !llvm.i64 %703 = llvm.mul %695, %702 : !llvm.i64 %704 = llvm.add %701, %703 : !llvm.i64 %705 = llvm.mlir.constant(1 : index) : !llvm.i64 %706 = llvm.mul %696, %705 : !llvm.i64 %707 = llvm.add %704, %706 : !llvm.i64 %708 = llvm.getelementptr %697[%707] : (!llvm\u0026lt;\u0026#34;float*\u0026#34;\u0026gt;, !llvm.i64) -\u0026gt; !llvm\u0026lt;\u0026#34;float*\u0026#34;\u0026gt; %709 = llvm.load %708 : !llvm\u0026lt;\u0026#34;float*\u0026#34;\u0026gt; %710 = llvm.fadd %694, %709 : !llvm.float %711 = llvm.extractvalue %281[1] : !llvm\u0026lt;\u0026#34;{ float*, float*, i64, [4 x i64], [4 x i64] }\u0026#34;\u0026gt; %712 = llvm.mlir.constant(0 : index) : !llvm.i64 %713 = llvm.mlir.constant(6272 : index) : !llvm.i64 %714 = llvm.mul %661, %713 : !llvm.i64 %715 = llvm.add %712, %714 : !llvm.i64 %716 = llvm.mlir.constant(784 : index) : !llvm.i64 %717 = llvm.mul %666, %716 : !llvm.i64 %718 = llvm.add %715, %717 : !llvm.i64 %719 = llvm.mlir.constant(28 : index) : !llvm.i64 %720 = llvm.mul %671, %719 : !llvm.i64 %721 = llvm.add %718, %720 : !llvm.i64 %722 = llvm.mlir.constant(1 : index) : !llvm.i64 %723 = llvm.mul %676, %722 : !llvm.i64 %724 = llvm.add %721, %723 : !llvm.i64 %725 = llvm.getelementptr %711[%724] : (!llvm\u0026lt;\u0026#34;float*\u0026#34;\u0026gt;, !llvm.i64) -\u0026gt; !llvm\u0026lt;\u0026#34;float*\u0026#34;\u0026gt; llvm.store %710, %725 : !llvm\u0026lt;\u0026#34;float*\u0026#34;\u0026gt; %726 = llvm.add %676, %675 : !llvm.i64 llvm.br ^bb52(%726 : !llvm.i64) ^bb54: // pred: ^bb52 %727 = llvm.add %671, %670 : !llvm.i64 llvm.br ^bb50(%727 : !llvm.i64) ^bb55: // pred: ^bb50 %728 = llvm.add %666, %665 : !llvm.i64 llvm.br ^bb48(%728 : !llvm.i64) ^bb56: // pred: ^bb48 %729 = llvm.add %661, %660 : !llvm.i64 llvm.br ^bb46(%729 : !llvm.i64) ^bb57: // pred: ^bb46 %730 = llvm.mlir.constant(0 : index) : !llvm.i64 %731 = llvm.mlir.constant(1 : index) : !llvm.i64 %732 = llvm.mlir.constant(1 : index) : !llvm.i64 llvm.br ^bb58(%730 : !llvm.i64) ^bb58(%733: !llvm.i64): // 2 preds: ^bb57, ^bb68 %734 = llvm.icmp \u0026#34;slt\u0026#34; %733, %731 : !llvm.i64 llvm.cond_br %734, ^bb59, ^bb69 ^bb59: // pred: ^bb58 %735 = llvm.mlir.constant(0 : index) : !llvm.i64 %736 = llvm.mlir.constant(8 : index) : !llvm.i64 %737 = llvm.mlir.constant(1 : index) : !llvm.i64 llvm.br ^bb60(%735 : !llvm.i64) ^bb60(%738: !llvm.i64): // 2 preds: ^bb59, ^bb67 %739 = llvm.icmp \u0026#34;slt\u0026#34; %738, %736 : !llvm.i64 llvm.cond_br %739, ^bb61, ^bb68 ^bb61: // pred: ^bb60 %740 = llvm.mlir.constant(0 : index) : !llvm.i64 %741 = llvm.mlir.constant(28 : index) : !llvm.i64 %742 = llvm.mlir.constant(1 : index) : !llvm.i64 llvm.br ^bb62(%740 : !llvm.i64) ^bb62(%743: !llvm.i64): // 2 preds: ^bb61, ^bb66 %744 = llvm.icmp \u0026#34;slt\u0026#34; %743, %741 : !llvm.i64 llvm.cond_br %744, ^bb63, ^bb67 ^bb63: // pred: ^bb62 %745 = llvm.mlir.constant(0 : index) : !llvm.i64 %746 = llvm.mlir.constant(28 : index) : !llvm.i64 %747 = llvm.mlir.constant(1 : index) : !llvm.i64 llvm.br ^bb64(%745 : !llvm.i64) ^bb64(%748: !llvm.i64): // 2 preds: ^bb63, ^bb65 %749 = llvm.icmp \u0026#34;slt\u0026#34; %748, %746 : !llvm.i64 llvm.cond_br %749, ^bb65, ^bb66 ^bb65: // pred: ^bb64 %750 = llvm.extractvalue %281[1] : !llvm\u0026lt;\u0026#34;{ float*, float*, i64, [4 x i64], [4 x i64] }\u0026#34;\u0026gt; %751 = llvm.mlir.constant(0 : index) : !llvm.i64 %752 = llvm.mlir.constant(6272 : index) : !llvm.i64 %753 = llvm.mul %733, %752 : !llvm.i64 %754 = llvm.add %751, %753 : !llvm.i64 %755 = llvm.mlir.constant(784 : index) : !llvm.i64 %756 = llvm.mul %738, %755 : !llvm.i64 %757 = llvm.add %754, %756 : !llvm.i64 %758 = llvm.mlir.constant(28 : index) : !llvm.i64 %759 = llvm.mul %743, %758 : !llvm.i64 %760 = llvm.add %757, %759 : !llvm.i64 %761 = llvm.mlir.constant(1 : index) : !llvm.i64 %762 = llvm.mul %748, %761 : !llvm.i64 %763 = llvm.add %760, %762 : !llvm.i64 %764 = llvm.getelementptr %750[%763] : (!llvm\u0026lt;\u0026#34;float*\u0026#34;\u0026gt;, !llvm.i64) -\u0026gt; !llvm\u0026lt;\u0026#34;float*\u0026#34;\u0026gt; %765 = llvm.load %764 : !llvm\u0026lt;\u0026#34;float*\u0026#34;\u0026gt; %766 = llvm.fcmp \u0026#34;olt\u0026#34; %765, %23 : !llvm.float %767 = llvm.select %766, %23, %765 : !llvm.i1, !llvm.float %768 = llvm.extractvalue %257[1] : !llvm\u0026lt;\u0026#34;{ float*, float*, i64, [4 x i64], [4 x i64] }\u0026#34;\u0026gt; %769 = llvm.mlir.constant(0 : index) : !llvm.i64 %770 = llvm.mlir.constant(6272 : index) : !llvm.i64 %771 = llvm.mul %733, %770 : !llvm.i64 %772 = llvm.add %769, %771 : !llvm.i64 %773 = llvm.mlir.constant(784 : index) : !llvm.i64 %774 = llvm.mul %738, %773 : !llvm.i64 %775 = llvm.add %772, %774 : !llvm.i64 %776 = llvm.mlir.constant(28 : index) : !llvm.i64 %777 = llvm.mul %743, %776 : !llvm.i64 %778 = llvm.add %775, %777 : !llvm.i64 %779 = llvm.mlir.constant(1 : index) : !llvm.i64 %780 = llvm.mul %748, %779 : !llvm.i64 %781 = llvm.add %778, %780 : !llvm.i64 %782 = llvm.getelementptr %768[%781] : (!llvm\u0026lt;\u0026#34;float*\u0026#34;\u0026gt;, !llvm.i64) -\u0026gt; !llvm\u0026lt;\u0026#34;float*\u0026#34;\u0026gt; llvm.store %767, %782 : !llvm\u0026lt;\u0026#34;float*\u0026#34;\u0026gt; %783 = llvm.add %748, %747 : !llvm.i64 llvm.br ^bb64(%783 : !llvm.i64) ^bb66: // pred: ^bb64 %784 = llvm.add %743, %742 : !llvm.i64 llvm.br ^bb62(%784 : !llvm.i64) ^bb67: // pred: ^bb62 %785 = llvm.add %738, %737 : !llvm.i64 llvm.br ^bb60(%785 : !llvm.i64) ^bb68: // pred: ^bb60 %786 = llvm.add %733, %732 : !llvm.i64 llvm.br ^bb58(%786 : !llvm.i64) ^bb69: // pred: ^bb58 %787 = llvm.mlir.constant(0 : index) : !llvm.i64 %788 = llvm.mlir.constant(1 : index) : !llvm.i64 %789 = llvm.mlir.constant(1 : index) : !llvm.i64 llvm.br ^bb70(%787 : !llvm.i64) ^bb70(%790: !llvm.i64): // 2 preds: ^bb69, ^bb86 %791 = llvm.icmp \u0026#34;slt\u0026#34; %790, %788 : !llvm.i64 llvm.cond_br %791, ^bb71, ^bb87 ^bb71: // pred: ^bb70 %792 = llvm.mlir.constant(0 : index) : !llvm.i64 %793 = llvm.mlir.constant(8 : index) : !llvm.i64 %794 = llvm.mlir.constant(1 : index) : !llvm.i64 llvm.br ^bb72(%792 : !llvm.i64) ^bb72(%795: !llvm.i64): // 2 preds: ^bb71, ^bb85 %796 = llvm.icmp \u0026#34;slt\u0026#34; %795, %793 : !llvm.i64 llvm.cond_br %796, ^bb73, ^bb86 ^bb73: // pred: ^bb72 %797 = llvm.mlir.constant(0 : index) : !llvm.i64 %798 = llvm.mlir.constant(14 : index) : !llvm.i64 %799 = llvm.mlir.constant(1 : index) : !llvm.i64 llvm.br ^bb74(%797 : !llvm.i64) ^bb74(%800: !llvm.i64): // 2 preds: ^bb73, ^bb84 %801 = llvm.icmp \u0026#34;slt\u0026#34; %800, %798 : !llvm.i64 llvm.cond_br %801, ^bb75, ^bb85 ^bb75: // pred: ^bb74 %802 = llvm.mlir.constant(0 : index) : !llvm.i64 %803 = llvm.mlir.constant(14 : index) : !llvm.i64 %804 = llvm.mlir.constant(1 : index) : !llvm.i64 llvm.br ^bb76(%802 : !llvm.i64) ^bb76(%805: !llvm.i64): // 2 preds: ^bb75, ^bb83 %806 = llvm.icmp \u0026#34;slt\u0026#34; %805, %803 : !llvm.i64 llvm.cond_br %806, ^bb77, ^bb84 ^bb77: // pred: ^bb76 %807 = llvm.extractvalue %233[1] : !llvm\u0026lt;\u0026#34;{ float*, float*, i64, [4 x i64], [4 x i64] }\u0026#34;\u0026gt; %808 = llvm.mlir.constant(0 : index) : !llvm.i64 %809 = llvm.mlir.constant(1568 : index) : !llvm.i64 %810 = llvm.mul %790, %809 : !llvm.i64 %811 = llvm.add %808, %810 : !llvm.i64 %812 = llvm.mlir.constant(196 : index) : !llvm.i64 %813 = llvm.mul %795, %812 : !llvm.i64 %814 = llvm.add %811, %813 : !llvm.i64 %815 = llvm.mlir.constant(14 : index) : !llvm.i64 %816 = llvm.mul %800, %815 : !llvm.i64 %817 = llvm.add %814, %816 : !llvm.i64 %818 = llvm.mlir.constant(1 : index) : !llvm.i64 %819 = llvm.mul %805, %818 : !llvm.i64 %820 = llvm.add %817, %819 : !llvm.i64 %821 = llvm.getelementptr %807[%820] : (!llvm\u0026lt;\u0026#34;float*\u0026#34;\u0026gt;, !llvm.i64) -\u0026gt; !llvm\u0026lt;\u0026#34;float*\u0026#34;\u0026gt; llvm.store %17, %821 : !llvm\u0026lt;\u0026#34;float*\u0026#34;\u0026gt; %822 = llvm.mlir.constant(0 : index) : !llvm.i64 %823 = llvm.mlir.constant(2 : index) : !llvm.i64 %824 = llvm.mul %800, %823 : !llvm.i64 %825 = llvm.icmp \u0026#34;sgt\u0026#34; %822, %824 : !llvm.i64 %826 = llvm.select %825, %822, %824 : !llvm.i1, !llvm.i64 %827 = llvm.mlir.constant(0 : index) : !llvm.i64 %828 = llvm.mlir.constant(2 : index) : !llvm.i64 %829 = llvm.mul %805, %828 : !llvm.i64 %830 = llvm.icmp \u0026#34;sgt\u0026#34; %827, %829 : !llvm.i64 %831 = llvm.select %830, %827, %829 : !llvm.i1, !llvm.i64 %832 = llvm.mlir.constant(0 : index) : !llvm.i64 %833 = llvm.mlir.constant(28 : index) : !llvm.i64 %834 = llvm.mlir.constant(-2 : index) : !llvm.i64 %835 = llvm.mul %800, %834 : !llvm.i64 %836 = llvm.mlir.constant(28 : index) : !llvm.i64 %837 = llvm.add %835, %836 : !llvm.i64 %838 = llvm.mlir.constant(2 : index) : !llvm.i64 %839 = llvm.mul %800, %838 : !llvm.i64 %840 = llvm.mlir.constant(2 : index) : !llvm.i64 %841 = llvm.add %839, %840 : !llvm.i64 %842 = llvm.mlir.constant(2 : index) : !llvm.i64 %843 = llvm.icmp \u0026#34;slt\u0026#34; %833, %837 : !llvm.i64 %844 = llvm.select %843, %833, %837 : !llvm.i1, !llvm.i64 %845 = llvm.icmp \u0026#34;slt\u0026#34; %844, %841 : !llvm.i64 %846 = llvm.select %845, %844, %841 : !llvm.i1, !llvm.i64 %847 = llvm.icmp \u0026#34;slt\u0026#34; %846, %842 : !llvm.i64 %848 = llvm.select %847, %846, %842 : !llvm.i1, !llvm.i64 %849 = llvm.mlir.constant(1 : index) : !llvm.i64 llvm.br ^bb78(%832 : !llvm.i64) ^bb78(%850: !llvm.i64): // 2 preds: ^bb77, ^bb82 %851 = llvm.icmp \u0026#34;slt\u0026#34; %850, %848 : !llvm.i64 llvm.cond_br %851, ^bb79, ^bb83 ^bb79: // pred: ^bb78 %852 = llvm.mlir.constant(0 : index) : !llvm.i64 %853 = llvm.mlir.constant(28 : index) : !llvm.i64 %854 = llvm.mlir.constant(-2 : index) : !llvm.i64 %855 = llvm.mul %805, %854 : !llvm.i64 %856 = llvm.mlir.constant(28 : index) : !llvm.i64 %857 = llvm.add %855, %856 : !llvm.i64 %858 = llvm.mlir.constant(2 : index) : !llvm.i64 %859 = llvm.mul %805, %858 : !llvm.i64 %860 = llvm.mlir.constant(2 : index) : !llvm.i64 %861 = llvm.add %859, %860 : !llvm.i64 %862 = llvm.mlir.constant(2 : index) : !llvm.i64 %863 = llvm.icmp \u0026#34;slt\u0026#34; %853, %857 : !llvm.i64 %864 = llvm.select %863, %853, %857 : !llvm.i1, !llvm.i64 %865 = llvm.icmp \u0026#34;slt\u0026#34; %864, %861 : !llvm.i64 %866 = llvm.select %865, %864, %861 : !llvm.i1, !llvm.i64 %867 = llvm.icmp \u0026#34;slt\u0026#34; %866, %862 : !llvm.i64 %868 = llvm.select %867, %866, %862 : !llvm.i1, !llvm.i64 %869 = llvm.mlir.constant(1 : index) : !llvm.i64 llvm.br ^bb80(%852 : !llvm.i64) ^bb80(%870: !llvm.i64): // 2 preds: ^bb79, ^bb81 %871 = llvm.icmp \u0026#34;slt\u0026#34; %870, %868 : !llvm.i64 llvm.cond_br %871, ^bb81, ^bb82 ^bb81: // pred: ^bb80 %872 = llvm.add %850, %826 : !llvm.i64 %873 = llvm.add %870, %831 : !llvm.i64 %874 = llvm.extractvalue %257[1] : !llvm\u0026lt;\u0026#34;{ float*, float*, i64, [4 x i64], [4 x i64] }\u0026#34;\u0026gt; %875 = llvm.mlir.constant(0 : index) : !llvm.i64 %876 = llvm.mlir.constant(6272 : index) : !llvm.i64 %877 = llvm.mul %790, %876 : !llvm.i64 %878 = llvm.add %875, %877 : !llvm.i64 %879 = llvm.mlir.constant(784 : index) : !llvm.i64 %880 = llvm.mul %795, %879 : !llvm.i64 %881 = llvm.add %878, %880 : !llvm.i64 %882 = llvm.mlir.constant(28 : index) : !llvm.i64 %883 = llvm.mul %872, %882 : !llvm.i64 %884 = llvm.add %881, %883 : !llvm.i64 %885 = llvm.mlir.constant(1 : index) : !llvm.i64 %886 = llvm.mul %873, %885 : !llvm.i64 %887 = llvm.add %884, %886 : !llvm.i64 %888 = llvm.getelementptr %874[%887] : (!llvm\u0026lt;\u0026#34;float*\u0026#34;\u0026gt;, !llvm.i64) -\u0026gt; !llvm\u0026lt;\u0026#34;float*\u0026#34;\u0026gt; %889 = llvm.load %888 : !llvm\u0026lt;\u0026#34;float*\u0026#34;\u0026gt; %890 = llvm.extractvalue %233[1] : !llvm\u0026lt;\u0026#34;{ float*, float*, i64, [4 x i64], [4 x i64] }\u0026#34;\u0026gt; %891 = llvm.mlir.constant(0 : index) : !llvm.i64 %892 = llvm.mlir.constant(1568 : index) : !llvm.i64 %893 = llvm.mul %790, %892 : !llvm.i64 %894 = llvm.add %891, %893 : !llvm.i64 %895 = llvm.mlir.constant(196 : index) : !llvm.i64 %896 = llvm.mul %795, %895 : !llvm.i64 %897 = llvm.add %894, %896 : !llvm.i64 %898 = llvm.mlir.constant(14 : index) : !llvm.i64 %899 = llvm.mul %800, %898 : !llvm.i64 %900 = llvm.add %897, %899 : !llvm.i64 %901 = llvm.mlir.constant(1 : index) : !llvm.i64 %902 = llvm.mul %805, %901 : !llvm.i64 %903 = llvm.add %900, %902 : !llvm.i64 %904 = llvm.getelementptr %890[%903] : (!llvm\u0026lt;\u0026#34;float*\u0026#34;\u0026gt;, !llvm.i64) -\u0026gt; !llvm\u0026lt;\u0026#34;float*\u0026#34;\u0026gt; %905 = llvm.load %904 : !llvm\u0026lt;\u0026#34;float*\u0026#34;\u0026gt; %906 = llvm.fcmp \u0026#34;ogt\u0026#34; %905, %889 : !llvm.float %907 = llvm.select %906, %905, %889 : !llvm.i1, !llvm.float %908 = llvm.extractvalue %233[1] : !llvm\u0026lt;\u0026#34;{ float*, float*, i64, [4 x i64], [4 x i64] }\u0026#34;\u0026gt; %909 = llvm.mlir.constant(0 : index) : !llvm.i64 %910 = llvm.mlir.constant(1568 : index) : !llvm.i64 %911 = llvm.mul %790, %910 : !llvm.i64 %912 = llvm.add %909, %911 : !llvm.i64 %913 = llvm.mlir.constant(196 : index) : !llvm.i64 %914 = llvm.mul %795, %913 : !llvm.i64 %915 = llvm.add %912, %914 : !llvm.i64 %916 = llvm.mlir.constant(14 : index) : !llvm.i64 %917 = llvm.mul %800, %916 : !llvm.i64 %918 = llvm.add %915, %917 : !llvm.i64 %919 = llvm.mlir.constant(1 : index) : !llvm.i64 %920 = llvm.mul %805, %919 : !llvm.i64 %921 = llvm.add %918, %920 : !llvm.i64 %922 = llvm.getelementptr %908[%921] : (!llvm\u0026lt;\u0026#34;float*\u0026#34;\u0026gt;, !llvm.i64) -\u0026gt; !llvm\u0026lt;\u0026#34;float*\u0026#34;\u0026gt; llvm.store %907, %922 : !llvm\u0026lt;\u0026#34;float*\u0026#34;\u0026gt; %923 = llvm.add %870, %869 : !llvm.i64 llvm.br ^bb80(%923 : !llvm.i64) ^bb82: // pred: ^bb80 %924 = llvm.add %850, %849 : !llvm.i64 llvm.br ^bb78(%924 : !llvm.i64) ^bb83: // pred: ^bb78 %925 = llvm.add %805, %804 : !llvm.i64 llvm.br ^bb76(%925 : !llvm.i64) ^bb84: // pred: ^bb76 %926 = llvm.add %800, %799 : !llvm.i64 llvm.br ^bb74(%926 : !llvm.i64) ^bb85: // pred: ^bb74 %927 = llvm.add %795, %794 : !llvm.i64 llvm.br ^bb72(%927 : !llvm.i64) ^bb86: // pred: ^bb72 %928 = llvm.add %790, %789 : !llvm.i64 llvm.br ^bb70(%928 : !llvm.i64) ^bb87: // pred: ^bb70 %929 = llvm.mlir.constant(1 : i64) : !llvm.i64 %930 = llvm.mlir.addressof @packedConst : !llvm\u0026lt;\u0026#34;i8**\u0026#34;\u0026gt; %931 = llvm.load %930 : !llvm\u0026lt;\u0026#34;i8**\u0026#34;\u0026gt; %932 = llvm.mlir.constant(11040 : i64) : !llvm.i64 %933 = llvm.getelementptr %931[%932] : (!llvm\u0026lt;\u0026#34;i8*\u0026#34;\u0026gt;, !llvm.i64) -\u0026gt; !llvm\u0026lt;\u0026#34;i8*\u0026#34;\u0026gt; %934 = llvm.bitcast %933 : !llvm\u0026lt;\u0026#34;i8*\u0026#34;\u0026gt; to !llvm\u0026lt;\u0026#34;float*\u0026#34;\u0026gt; %935 = llvm.mlir.undef : !llvm\u0026lt;\u0026#34;{ float*, float*, i64, [4 x i64], [4 x i64] }\u0026#34;\u0026gt; %936 = llvm.insertvalue %934, %935[0] : !llvm\u0026lt;\u0026#34;{ float*, float*, i64, [4 x i64], [4 x i64] }\u0026#34;\u0026gt; %937 = llvm.insertvalue %934, %936[1] : !llvm\u0026lt;\u0026#34;{ float*, float*, i64, [4 x i64], [4 x i64] }\u0026#34;\u0026gt; %938 = llvm.mlir.constant(0 : index) : !llvm.i64 %939 = llvm.insertvalue %938, %937[2] : !llvm\u0026lt;\u0026#34;{ float*, float*, i64, [4 x i64], [4 x i64] }\u0026#34;\u0026gt; %940 = llvm.mlir.constant(16 : index) : !llvm.i64 %941 = llvm.insertvalue %940, %939[3, 0] : !llvm\u0026lt;\u0026#34;{ float*, float*, i64, [4 x i64], [4 x i64] }\u0026#34;\u0026gt; %942 = llvm.mlir.constant(200 : index) : !llvm.i64 %943 = llvm.insertvalue %942, %941[4, 0] : !llvm\u0026lt;\u0026#34;{ float*, float*, i64, [4 x i64], [4 x i64] }\u0026#34;\u0026gt; %944 = llvm.mlir.constant(8 : index) : !llvm.i64 %945 = llvm.insertvalue %944, %943[3, 1] : !llvm\u0026lt;\u0026#34;{ float*, float*, i64, [4 x i64], [4 x i64] }\u0026#34;\u0026gt; %946 = llvm.mlir.constant(25 : index) : !llvm.i64 %947 = llvm.insertvalue %946, %945[4, 1] : !llvm\u0026lt;\u0026#34;{ float*, float*, i64, [4 x i64], [4 x i64] }\u0026#34;\u0026gt; %948 = llvm.mlir.constant(5 : index) : !llvm.i64 %949 = llvm.insertvalue %948, %947[3, 2] : !llvm\u0026lt;\u0026#34;{ float*, float*, i64, [4 x i64], [4 x i64] }\u0026#34;\u0026gt; %950 = llvm.mlir.constant(5 : index) : !llvm.i64 %951 = llvm.insertvalue %950, %949[4, 2] : !llvm\u0026lt;\u0026#34;{ float*, float*, i64, [4 x i64], [4 x i64] }\u0026#34;\u0026gt; %952 = llvm.mlir.constant(5 : index) : !llvm.i64 %953 = llvm.insertvalue %952, %951[3, 3] : !llvm\u0026lt;\u0026#34;{ float*, float*, i64, [4 x i64], [4 x i64] }\u0026#34;\u0026gt; %954 = llvm.mlir.constant(1 : index) : !llvm.i64 %955 = llvm.insertvalue %954, %953[4, 3] : !llvm\u0026lt;\u0026#34;{ float*, float*, i64, [4 x i64], [4 x i64] }\u0026#34;\u0026gt; %956 = llvm.mlir.constant(0 : index) : !llvm.i64 %957 = llvm.mlir.constant(1 : index) : !llvm.i64 %958 = llvm.mlir.constant(1 : index) : !llvm.i64 llvm.br ^bb88(%956 : !llvm.i64) ^bb88(%959: !llvm.i64): // 2 preds: ^bb87, ^bb98 %960 = llvm.icmp \u0026#34;slt\u0026#34; %959, %957 : !llvm.i64 llvm.cond_br %960, ^bb89, ^bb99 ^bb89: // pred: ^bb88 %961 = llvm.mlir.constant(0 : index) : !llvm.i64 %962 = llvm.mlir.constant(8 : index) : !llvm.i64 %963 = llvm.mlir.constant(1 : index) : !llvm.i64 llvm.br ^bb90(%961 : !llvm.i64) ^bb90(%964: !llvm.i64): // 2 preds: ^bb89, ^bb97 %965 = llvm.icmp \u0026#34;slt\u0026#34; %964, %962 : !llvm.i64 llvm.cond_br %965, ^bb91, ^bb98 ^bb91: // pred: ^bb90 %966 = llvm.mlir.constant(0 : index) : !llvm.i64 %967 = llvm.mlir.constant(18 : index) : !llvm.i64 %968 = llvm.mlir.constant(1 : index) : !llvm.i64 llvm.br ^bb92(%966 : !llvm.i64) ^bb92(%969: !llvm.i64): // 2 preds: ^bb91, ^bb96 %970 = llvm.icmp \u0026#34;slt\u0026#34; %969, %967 : !llvm.i64 llvm.cond_br %970, ^bb93, ^bb97 ^bb93: // pred: ^bb92 %971 = llvm.mlir.constant(0 : index) : !llvm.i64 %972 = llvm.mlir.constant(18 : index) : !llvm.i64 %973 = llvm.mlir.constant(1 : index) : !llvm.i64 llvm.br ^bb94(%971 : !llvm.i64) ^bb94(%974: !llvm.i64): // 2 preds: ^bb93, ^bb95 %975 = llvm.icmp \u0026#34;slt\u0026#34; %974, %972 : !llvm.i64 llvm.cond_br %975, ^bb95, ^bb96 ^bb95: // pred: ^bb94 %976 = llvm.extractvalue %209[1] : !llvm\u0026lt;\u0026#34;{ float*, float*, i64, [4 x i64], [4 x i64] }\u0026#34;\u0026gt; %977 = llvm.mlir.constant(0 : index) : !llvm.i64 %978 = llvm.mlir.constant(2592 : index) : !llvm.i64 %979 = llvm.mul %959, %978 : !llvm.i64 %980 = llvm.add %977, %979 : !llvm.i64 %981 = llvm.mlir.constant(324 : index) : !llvm.i64 %982 = llvm.mul %964, %981 : !llvm.i64 %983 = llvm.add %980, %982 : !llvm.i64 %984 = llvm.mlir.constant(18 : index) : !llvm.i64 %985 = llvm.mul %969, %984 : !llvm.i64 %986 = llvm.add %983, %985 : !llvm.i64 %987 = llvm.mlir.constant(1 : index) : !llvm.i64 %988 = llvm.mul %974, %987 : !llvm.i64 %989 = llvm.add %986, %988 : !llvm.i64 %990 = llvm.getelementptr %976[%989] : (!llvm\u0026lt;\u0026#34;float*\u0026#34;\u0026gt;, !llvm.i64) -\u0026gt; !llvm\u0026lt;\u0026#34;float*\u0026#34;\u0026gt; llvm.store %23, %990 : !llvm\u0026lt;\u0026#34;float*\u0026#34;\u0026gt; %991 = llvm.add %974, %973 : !llvm.i64 llvm.br ^bb94(%991 : !llvm.i64) ^bb96: // pred: ^bb94 %992 = llvm.add %969, %968 : !llvm.i64 llvm.br ^bb92(%992 : !llvm.i64) ^bb97: // pred: ^bb92 %993 = llvm.add %964, %963 : !llvm.i64 llvm.br ^bb90(%993 : !llvm.i64) ^bb98: // pred: ^bb90 %994 = llvm.add %959, %958 : !llvm.i64 llvm.br ^bb88(%994 : !llvm.i64) ^bb99: // pred: ^bb88 %995 = llvm.mlir.constant(0 : index) : !llvm.i64 %996 = llvm.mlir.constant(1 : index) : !llvm.i64 %997 = llvm.mlir.constant(1 : index) : !llvm.i64 llvm.br ^bb100(%995 : !llvm.i64) ^bb100(%998: !llvm.i64): // 2 preds: ^bb99, ^bb110 %999 = llvm.icmp \u0026#34;slt\u0026#34; %998, %996 : !llvm.i64 llvm.cond_br %999, ^bb101, ^bb111 ^bb101: // pred: ^bb100 %1000 = llvm.mlir.constant(0 : index) : !llvm.i64 %1001 = llvm.mlir.constant(8 : index) : !llvm.i64 %1002 = llvm.mlir.constant(1 : index) : !llvm.i64 llvm.br ^bb102(%1000 : !llvm.i64) ^bb102(%1003: !llvm.i64): // 2 preds: ^bb101, ^bb109 %1004 = llvm.icmp \u0026#34;slt\u0026#34; %1003, %1001 : !llvm.i64 llvm.cond_br %1004, ^bb103, ^bb110 ^bb103: // pred: ^bb102 %1005 = llvm.mlir.constant(0 : index) : !llvm.i64 %1006 = llvm.mlir.constant(14 : index) : !llvm.i64 %1007 = llvm.mlir.constant(1 : index) : !llvm.i64 llvm.br ^bb104(%1005 : !llvm.i64) ^bb104(%1008: !llvm.i64): // 2 preds: ^bb103, ^bb108 %1009 = llvm.icmp \u0026#34;slt\u0026#34; %1008, %1006 : !llvm.i64 llvm.cond_br %1009, ^bb105, ^bb109 ^bb105: // pred: ^bb104 %1010 = llvm.mlir.constant(0 : index) : !llvm.i64 %1011 = llvm.mlir.constant(14 : index) : !llvm.i64 %1012 = llvm.mlir.constant(1 : index) : !llvm.i64 llvm.br ^bb106(%1010 : !llvm.i64) ^bb106(%1013: !llvm.i64): // 2 preds: ^bb105, ^bb107 %1014 = llvm.icmp \u0026#34;slt\u0026#34; %1013, %1011 : !llvm.i64 llvm.cond_br %1014, ^bb107, ^bb108 ^bb107: // pred: ^bb106 %1015 = llvm.extractvalue %233[1] : !llvm\u0026lt;\u0026#34;{ float*, float*, i64, [4 x i64], [4 x i64] }\u0026#34;\u0026gt; %1016 = llvm.mlir.constant(0 : index) : !llvm.i64 %1017 = llvm.mlir.constant(1568 : index) : !llvm.i64 %1018 = llvm.mul %998, %1017 : !llvm.i64 %1019 = llvm.add %1016, %1018 : !llvm.i64 %1020 = llvm.mlir.constant(196 : index) : !llvm.i64 %1021 = llvm.mul %1003, %1020 : !llvm.i64 %1022 = llvm.add %1019, %1021 : !llvm.i64 %1023 = llvm.mlir.constant(14 : index) : !llvm.i64 %1024 = llvm.mul %1008, %1023 : !llvm.i64 %1025 = llvm.add %1022, %1024 : !llvm.i64 %1026 = llvm.mlir.constant(1 : index) : !llvm.i64 %1027 = llvm.mul %1013, %1026 : !llvm.i64 %1028 = llvm.add %1025, %1027 : !llvm.i64 %1029 = llvm.getelementptr %1015[%1028] : (!llvm\u0026lt;\u0026#34;float*\u0026#34;\u0026gt;, !llvm.i64) -\u0026gt; !llvm\u0026lt;\u0026#34;float*\u0026#34;\u0026gt; %1030 = llvm.load %1029 : !llvm\u0026lt;\u0026#34;float*\u0026#34;\u0026gt; %1031 = llvm.mlir.constant(2 : index) : !llvm.i64 %1032 = llvm.add %1008, %1031 : !llvm.i64 %1033 = llvm.mlir.constant(2 : index) : !llvm.i64 %1034 = llvm.add %1013, %1033 : !llvm.i64 %1035 = llvm.extractvalue %209[1] : !llvm\u0026lt;\u0026#34;{ float*, float*, i64, [4 x i64], [4 x i64] }\u0026#34;\u0026gt; %1036 = llvm.mlir.constant(0 : index) : !llvm.i64 %1037 = llvm.mlir.constant(2592 : index) : !llvm.i64 %1038 = llvm.mul %998, %1037 : !llvm.i64 %1039 = llvm.add %1036, %1038 : !llvm.i64 %1040 = llvm.mlir.constant(324 : index) : !llvm.i64 %1041 = llvm.mul %1003, %1040 : !llvm.i64 %1042 = llvm.add %1039, %1041 : !llvm.i64 %1043 = llvm.mlir.constant(18 : index) : !llvm.i64 %1044 = llvm.mul %1032, %1043 : !llvm.i64 %1045 = llvm.add %1042, %1044 : !llvm.i64 %1046 = llvm.mlir.constant(1 : index) : !llvm.i64 %1047 = llvm.mul %1034, %1046 : !llvm.i64 %1048 = llvm.add %1045, %1047 : !llvm.i64 %1049 = llvm.getelementptr %1035[%1048] : (!llvm\u0026lt;\u0026#34;float*\u0026#34;\u0026gt;, !llvm.i64) -\u0026gt; !llvm\u0026lt;\u0026#34;float*\u0026#34;\u0026gt; llvm.store %1030, %1049 : !llvm\u0026lt;\u0026#34;float*\u0026#34;\u0026gt; %1050 = llvm.add %1013, %1012 : !llvm.i64 llvm.br ^bb106(%1050 : !llvm.i64) ^bb108: // pred: ^bb106 %1051 = llvm.add %1008, %1007 : !llvm.i64 llvm.br ^bb104(%1051 : !llvm.i64) ^bb109: // pred: ^bb104 %1052 = llvm.add %1003, %1002 : !llvm.i64 llvm.br ^bb102(%1052 : !llvm.i64) ^bb110: // pred: ^bb102 %1053 = llvm.add %998, %997 : !llvm.i64 llvm.br ^bb100(%1053 : !llvm.i64) ^bb111: // pred: ^bb100 %1054 = llvm.mlir.constant(0 : index) : !llvm.i64 %1055 = llvm.mlir.constant(1 : index) : !llvm.i64 %1056 = llvm.mlir.constant(1 : index) : !llvm.i64 llvm.br ^bb112(%1054 : !llvm.i64) ^bb112(%1057: !llvm.i64): // 2 preds: ^bb111, ^bb131 %1058 = llvm.icmp \u0026#34;slt\u0026#34; %1057, %1055 : !llvm.i64 llvm.cond_br %1058, ^bb113, ^bb132 ^bb113: // pred: ^bb112 %1059 = llvm.mlir.constant(0 : index) : !llvm.i64 %1060 = llvm.mlir.constant(16 : index) : !llvm.i64 %1061 = llvm.mlir.constant(1 : index) : !llvm.i64 llvm.br ^bb114(%1059 : !llvm.i64) ^bb114(%1062: !llvm.i64): // 2 preds: ^bb113, ^bb130 %1063 = llvm.icmp \u0026#34;slt\u0026#34; %1062, %1060 : !llvm.i64 llvm.cond_br %1063, ^bb115, ^bb131 ^bb115: // pred: ^bb114 %1064 = llvm.mlir.constant(0 : index) : !llvm.i64 %1065 = llvm.mlir.constant(14 : index) : !llvm.i64 %1066 = llvm.mlir.constant(1 : index) : !llvm.i64 llvm.br ^bb116(%1064 : !llvm.i64) ^bb116(%1067: !llvm.i64): // 2 preds: ^bb115, ^bb129 %1068 = llvm.icmp \u0026#34;slt\u0026#34; %1067, %1065 : !llvm.i64 llvm.cond_br %1068, ^bb117, ^bb130 ^bb117: // pred: ^bb116 %1069 = llvm.mlir.constant(0 : index) : !llvm.i64 %1070 = llvm.mlir.constant(14 : index) : !llvm.i64 %1071 = llvm.mlir.constant(1 : index) : !llvm.i64 llvm.br ^bb118(%1069 : !llvm.i64) ^bb118(%1072: !llvm.i64): // 2 preds: ^bb117, ^bb128 %1073 = llvm.icmp \u0026#34;slt\u0026#34; %1072, %1070 : !llvm.i64 llvm.cond_br %1073, ^bb119, ^bb129 ^bb119: // pred: ^bb118 %1074 = llvm.extractvalue %185[1] : !llvm\u0026lt;\u0026#34;{ float*, float*, i64, [4 x i64], [4 x i64] }\u0026#34;\u0026gt; %1075 = llvm.mlir.constant(0 : index) : !llvm.i64 %1076 = llvm.mlir.constant(3136 : index) : !llvm.i64 %1077 = llvm.mul %1057, %1076 : !llvm.i64 %1078 = llvm.add %1075, %1077 : !llvm.i64 %1079 = llvm.mlir.constant(196 : index) : !llvm.i64 %1080 = llvm.mul %1062, %1079 : !llvm.i64 %1081 = llvm.add %1078, %1080 : !llvm.i64 %1082 = llvm.mlir.constant(14 : index) : !llvm.i64 %1083 = llvm.mul %1067, %1082 : !llvm.i64 %1084 = llvm.add %1081, %1083 : !llvm.i64 %1085 = llvm.mlir.constant(1 : index) : !llvm.i64 %1086 = llvm.mul %1072, %1085 : !llvm.i64 %1087 = llvm.add %1084, %1086 : !llvm.i64 %1088 = llvm.getelementptr %1074[%1087] : (!llvm\u0026lt;\u0026#34;float*\u0026#34;\u0026gt;, !llvm.i64) -\u0026gt; !llvm\u0026lt;\u0026#34;float*\u0026#34;\u0026gt; llvm.store %23, %1088 : !llvm\u0026lt;\u0026#34;float*\u0026#34;\u0026gt; %1089 = llvm.mlir.constant(0 : index) : !llvm.i64 %1090 = llvm.mlir.constant(8 : index) : !llvm.i64 %1091 = llvm.mlir.constant(1 : index) : !llvm.i64 llvm.br ^bb120(%1089 : !llvm.i64) ^bb120(%1092: !llvm.i64): // 2 preds: ^bb119, ^bb127 %1093 = llvm.icmp \u0026#34;slt\u0026#34; %1092, %1090 : !llvm.i64 llvm.cond_br %1093, ^bb121, ^bb128 ^bb121: // pred: ^bb120 %1094 = llvm.mlir.constant(0 : index) : !llvm.i64 %1095 = llvm.mlir.constant(5 : index) : !llvm.i64 %1096 = llvm.mlir.constant(1 : index) : !llvm.i64 llvm.br ^bb122(%1094 : !llvm.i64) ^bb122(%1097: !llvm.i64): // 2 preds: ^bb121, ^bb126 %1098 = llvm.icmp \u0026#34;slt\u0026#34; %1097, %1095 : !llvm.i64 llvm.cond_br %1098, ^bb123, ^bb127 ^bb123: // pred: ^bb122 %1099 = llvm.mlir.constant(0 : index) : !llvm.i64 %1100 = llvm.mlir.constant(5 : index) : !llvm.i64 %1101 = llvm.mlir.constant(1 : index) : !llvm.i64 llvm.br ^bb124(%1099 : !llvm.i64) ^bb124(%1102: !llvm.i64): // 2 preds: ^bb123, ^bb125 %1103 = llvm.icmp \u0026#34;slt\u0026#34; %1102, %1100 : !llvm.i64 llvm.cond_br %1103, ^bb125, ^bb126 ^bb125: // pred: ^bb124 %1104 = llvm.add %1067, %1097 : !llvm.i64 %1105 = llvm.add %1072, %1102 : !llvm.i64 %1106 = llvm.extractvalue %209[1] : !llvm\u0026lt;\u0026#34;{ float*, float*, i64, [4 x i64], [4 x i64] }\u0026#34;\u0026gt; %1107 = llvm.mlir.constant(0 : index) : !llvm.i64 %1108 = llvm.mlir.constant(2592 : index) : !llvm.i64 %1109 = llvm.mul %1057, %1108 : !llvm.i64 %1110 = llvm.add %1107, %1109 : !llvm.i64 %1111 = llvm.mlir.constant(324 : index) : !llvm.i64 %1112 = llvm.mul %1092, %1111 : !llvm.i64 %1113 = llvm.add %1110, %1112 : !llvm.i64 %1114 = llvm.mlir.constant(18 : index) : !llvm.i64 %1115 = llvm.mul %1104, %1114 : !llvm.i64 %1116 = llvm.add %1113, %1115 : !llvm.i64 %1117 = llvm.mlir.constant(1 : index) : !llvm.i64 %1118 = llvm.mul %1105, %1117 : !llvm.i64 %1119 = llvm.add %1116, %1118 : !llvm.i64 %1120 = llvm.getelementptr %1106[%1119] : (!llvm\u0026lt;\u0026#34;float*\u0026#34;\u0026gt;, !llvm.i64) -\u0026gt; !llvm\u0026lt;\u0026#34;float*\u0026#34;\u0026gt; %1121 = llvm.load %1120 : !llvm\u0026lt;\u0026#34;float*\u0026#34;\u0026gt; %1122 = llvm.extractvalue %955[1] : !llvm\u0026lt;\u0026#34;{ float*, float*, i64, [4 x i64], [4 x i64] }\u0026#34;\u0026gt; %1123 = llvm.mlir.constant(0 : index) : !llvm.i64 %1124 = llvm.mlir.constant(200 : index) : !llvm.i64 %1125 = llvm.mul %1062, %1124 : !llvm.i64 %1126 = llvm.add %1123, %1125 : !llvm.i64 %1127 = llvm.mlir.constant(25 : index) : !llvm.i64 %1128 = llvm.mul %1092, %1127 : !llvm.i64 %1129 = llvm.add %1126, %1128 : !llvm.i64 %1130 = llvm.mlir.constant(5 : index) : !llvm.i64 %1131 = llvm.mul %1097, %1130 : !llvm.i64 %1132 = llvm.add %1129, %1131 : !llvm.i64 %1133 = llvm.mlir.constant(1 : index) : !llvm.i64 %1134 = llvm.mul %1102, %1133 : !llvm.i64 %1135 = llvm.add %1132, %1134 : !llvm.i64 %1136 = llvm.getelementptr %1122[%1135] : (!llvm\u0026lt;\u0026#34;float*\u0026#34;\u0026gt;, !llvm.i64) -\u0026gt; !llvm\u0026lt;\u0026#34;float*\u0026#34;\u0026gt; %1137 = llvm.load %1136 : !llvm\u0026lt;\u0026#34;float*\u0026#34;\u0026gt; %1138 = llvm.extractvalue %185[1] : !llvm\u0026lt;\u0026#34;{ float*, float*, i64, [4 x i64], [4 x i64] }\u0026#34;\u0026gt; %1139 = llvm.mlir.constant(0 : index) : !llvm.i64 %1140 = llvm.mlir.constant(3136 : index) : !llvm.i64 %1141 = llvm.mul %1057, %1140 : !llvm.i64 %1142 = llvm.add %1139, %1141 : !llvm.i64 %1143 = llvm.mlir.constant(196 : index) : !llvm.i64 %1144 = llvm.mul %1062, %1143 : !llvm.i64 %1145 = llvm.add %1142, %1144 : !llvm.i64 %1146 = llvm.mlir.constant(14 : index) : !llvm.i64 %1147 = llvm.mul %1067, %1146 : !llvm.i64 %1148 = llvm.add %1145, %1147 : !llvm.i64 %1149 = llvm.mlir.constant(1 : index) : !llvm.i64 %1150 = llvm.mul %1072, %1149 : !llvm.i64 %1151 = llvm.add %1148, %1150 : !llvm.i64 %1152 = llvm.getelementptr %1138[%1151] : (!llvm\u0026lt;\u0026#34;float*\u0026#34;\u0026gt;, !llvm.i64) -\u0026gt; !llvm\u0026lt;\u0026#34;float*\u0026#34;\u0026gt; %1153 = llvm.load %1152 : !llvm\u0026lt;\u0026#34;float*\u0026#34;\u0026gt; %1154 = llvm.fmul %1121, %1137 : !llvm.float %1155 = llvm.fadd %1153, %1154 : !llvm.float %1156 = llvm.extractvalue %185[1] : !llvm\u0026lt;\u0026#34;{ float*, float*, i64, [4 x i64], [4 x i64] }\u0026#34;\u0026gt; %1157 = llvm.mlir.constant(0 : index) : !llvm.i64 %1158 = llvm.mlir.constant(3136 : index) : !llvm.i64 %1159 = llvm.mul %1057, %1158 : !llvm.i64 %1160 = llvm.add %1157, %1159 : !llvm.i64 %1161 = llvm.mlir.constant(196 : index) : !llvm.i64 %1162 = llvm.mul %1062, %1161 : !llvm.i64 %1163 = llvm.add %1160, %1162 : !llvm.i64 %1164 = llvm.mlir.constant(14 : index) : !llvm.i64 %1165 = llvm.mul %1067, %1164 : !llvm.i64 %1166 = llvm.add %1163, %1165 : !llvm.i64 %1167 = llvm.mlir.constant(1 : index) : !llvm.i64 %1168 = llvm.mul %1072, %1167 : !llvm.i64 %1169 = llvm.add %1166, %1168 : !llvm.i64 %1170 = llvm.getelementptr %1156[%1169] : (!llvm\u0026lt;\u0026#34;float*\u0026#34;\u0026gt;, !llvm.i64) -\u0026gt; !llvm\u0026lt;\u0026#34;float*\u0026#34;\u0026gt; llvm.store %1155, %1170 : !llvm\u0026lt;\u0026#34;float*\u0026#34;\u0026gt; %1171 = llvm.add %1102, %1101 : !llvm.i64 llvm.br ^bb124(%1171 : !llvm.i64) ^bb126: // pred: ^bb124 %1172 = llvm.add %1097, %1096 : !llvm.i64 llvm.br ^bb122(%1172 : !llvm.i64) ^bb127: // pred: ^bb122 %1173 = llvm.add %1092, %1091 : !llvm.i64 llvm.br ^bb120(%1173 : !llvm.i64) ^bb128: // pred: ^bb120 %1174 = llvm.add %1072, %1071 : !llvm.i64 llvm.br ^bb118(%1174 : !llvm.i64) ^bb129: // pred: ^bb118 %1175 = llvm.add %1067, %1066 : !llvm.i64 llvm.br ^bb116(%1175 : !llvm.i64) ^bb130: // pred: ^bb116 %1176 = llvm.add %1062, %1061 : !llvm.i64 llvm.br ^bb114(%1176 : !llvm.i64) ^bb131: // pred: ^bb114 %1177 = llvm.add %1057, %1056 : !llvm.i64 llvm.br ^bb112(%1177 : !llvm.i64) ^bb132: // pred: ^bb112 %1178 = llvm.mlir.constant(1 : i64) : !llvm.i64 %1179 = llvm.alloca %1178 x !llvm\u0026lt;\u0026#34;[16 x [1 x [1 x float]]]\u0026#34;\u0026gt; : (!llvm.i64) -\u0026gt; !llvm\u0026lt;\u0026#34;[16 x [1 x [1 x float]]]*\u0026#34;\u0026gt; %1180 = llvm.bitcast %1179 : !llvm\u0026lt;\u0026#34;[16 x [1 x [1 x float]]]*\u0026#34;\u0026gt; to !llvm\u0026lt;\u0026#34;i8*\u0026#34;\u0026gt; %1181 = llvm.mlir.addressof @constant_4 : !llvm\u0026lt;\u0026#34;[16 x [1 x [1 x float]]]*\u0026#34;\u0026gt; %1182 = llvm.bitcast %1181 : !llvm\u0026lt;\u0026#34;[16 x [1 x [1 x float]]]*\u0026#34;\u0026gt; to !llvm\u0026lt;\u0026#34;i8*\u0026#34;\u0026gt; %1183 = llvm.mlir.constant(4 : i64) : !llvm.i64 %1184 = llvm.mlir.constant(16 : i64) : !llvm.i64 %1185 = llvm.mul %1183, %1184 : !llvm.i64 %1186 = llvm.sext %1185 : !llvm.i64 to !llvm.i64 %1187 = llvm.mlir.constant(false) : !llvm.i1 %1188 = llvm.call @llvm.memcpy.p0i8.p0i8.i64(%1180, %1182, %1186, %1187) : (!llvm\u0026lt;\u0026#34;i8*\u0026#34;\u0026gt;, !llvm\u0026lt;\u0026#34;i8*\u0026#34;\u0026gt;, !llvm.i64, !llvm.i1) -\u0026gt; !llvm.void %1189 = llvm.bitcast %1179 : !llvm\u0026lt;\u0026#34;[16 x [1 x [1 x float]]]*\u0026#34;\u0026gt; to !llvm\u0026lt;\u0026#34;float*\u0026#34;\u0026gt; %1190 = llvm.mlir.undef : !llvm\u0026lt;\u0026#34;{ float*, float*, i64, [3 x i64], [3 x i64] }\u0026#34;\u0026gt; %1191 = llvm.insertvalue %1189, %1190[0] : !llvm\u0026lt;\u0026#34;{ float*, float*, i64, [3 x i64], [3 x i64] }\u0026#34;\u0026gt; %1192 = llvm.insertvalue %1189, %1191[1] : !llvm\u0026lt;\u0026#34;{ float*, float*, i64, [3 x i64], [3 x i64] }\u0026#34;\u0026gt; %1193 = llvm.mlir.constant(0 : index) : !llvm.i64 %1194 = llvm.insertvalue %1193, %1192[2] : !llvm\u0026lt;\u0026#34;{ float*, float*, i64, [3 x i64], [3 x i64] }\u0026#34;\u0026gt; %1195 = llvm.mlir.constant(16 : index) : !llvm.i64 %1196 = llvm.insertvalue %1195, %1194[3, 0] : !llvm\u0026lt;\u0026#34;{ float*, float*, i64, [3 x i64], [3 x i64] }\u0026#34;\u0026gt; %1197 = llvm.mlir.constant(1 : index) : !llvm.i64 %1198 = llvm.insertvalue %1197, %1196[4, 0] : !llvm\u0026lt;\u0026#34;{ float*, float*, i64, [3 x i64], [3 x i64] }\u0026#34;\u0026gt; %1199 = llvm.mlir.constant(1 : index) : !llvm.i64 %1200 = llvm.insertvalue %1199, %1198[3, 1] : !llvm\u0026lt;\u0026#34;{ float*, float*, i64, [3 x i64], [3 x i64] }\u0026#34;\u0026gt; %1201 = llvm.mlir.constant(1 : index) : !llvm.i64 %1202 = llvm.insertvalue %1201, %1200[4, 1] : !llvm\u0026lt;\u0026#34;{ float*, float*, i64, [3 x i64], [3 x i64] }\u0026#34;\u0026gt; %1203 = llvm.mlir.constant(1 : index) : !llvm.i64 %1204 = llvm.insertvalue %1203, %1202[3, 2] : !llvm\u0026lt;\u0026#34;{ float*, float*, i64, [3 x i64], [3 x i64] }\u0026#34;\u0026gt; %1205 = llvm.mlir.constant(1 : index) : !llvm.i64 %1206 = llvm.insertvalue %1205, %1204[4, 2] : !llvm\u0026lt;\u0026#34;{ float*, float*, i64, [3 x i64], [3 x i64] }\u0026#34;\u0026gt; %1207 = llvm.mlir.constant(0 : index) : !llvm.i64 %1208 = llvm.mlir.constant(1 : index) : !llvm.i64 %1209 = llvm.mlir.constant(1 : index) : !llvm.i64 llvm.br ^bb133(%1207 : !llvm.i64) ^bb133(%1210: !llvm.i64): // 2 preds: ^bb132, ^bb143 %1211 = llvm.icmp \u0026#34;slt\u0026#34; %1210, %1208 : !llvm.i64 llvm.cond_br %1211, ^bb134, ^bb144 ^bb134: // pred: ^bb133 %1212 = llvm.mlir.constant(0 : index) : !llvm.i64 %1213 = llvm.mlir.constant(16 : index) : !llvm.i64 %1214 = llvm.mlir.constant(1 : index) : !llvm.i64 llvm.br ^bb135(%1212 : !llvm.i64) ^bb135(%1215: !llvm.i64): // 2 preds: ^bb134, ^bb142 %1216 = llvm.icmp \u0026#34;slt\u0026#34; %1215, %1213 : !llvm.i64 llvm.cond_br %1216, ^bb136, ^bb143 ^bb136: // pred: ^bb135 %1217 = llvm.mlir.constant(0 : index) : !llvm.i64 %1218 = llvm.mlir.constant(14 : index) : !llvm.i64 %1219 = llvm.mlir.constant(1 : index) : !llvm.i64 llvm.br ^bb137(%1217 : !llvm.i64) ^bb137(%1220: !llvm.i64): // 2 preds: ^bb136, ^bb141 %1221 = llvm.icmp \u0026#34;slt\u0026#34; %1220, %1218 : !llvm.i64 llvm.cond_br %1221, ^bb138, ^bb142 ^bb138: // pred: ^bb137 %1222 = llvm.mlir.constant(0 : index) : !llvm.i64 %1223 = llvm.mlir.constant(14 : index) : !llvm.i64 %1224 = llvm.mlir.constant(1 : index) : !llvm.i64 llvm.br ^bb139(%1222 : !llvm.i64) ^bb139(%1225: !llvm.i64): // 2 preds: ^bb138, ^bb140 %1226 = llvm.icmp \u0026#34;slt\u0026#34; %1225, %1223 : !llvm.i64 llvm.cond_br %1226, ^bb140, ^bb141 ^bb140: // pred: ^bb139 %1227 = llvm.mlir.constant(0 : index) : !llvm.i64 %1228 = llvm.extractvalue %185[1] : !llvm\u0026lt;\u0026#34;{ float*, float*, i64, [4 x i64], [4 x i64] }\u0026#34;\u0026gt; %1229 = llvm.mlir.constant(0 : index) : !llvm.i64 %1230 = llvm.mlir.constant(3136 : index) : !llvm.i64 %1231 = llvm.mul %1227, %1230 : !llvm.i64 %1232 = llvm.add %1229, %1231 : !llvm.i64 %1233 = llvm.mlir.constant(196 : index) : !llvm.i64 %1234 = llvm.mul %1215, %1233 : !llvm.i64 %1235 = llvm.add %1232, %1234 : !llvm.i64 %1236 = llvm.mlir.constant(14 : index) : !llvm.i64 %1237 = llvm.mul %1220, %1236 : !llvm.i64 %1238 = llvm.add %1235, %1237 : !llvm.i64 %1239 = llvm.mlir.constant(1 : index) : !llvm.i64 %1240 = llvm.mul %1225, %1239 : !llvm.i64 %1241 = llvm.add %1238, %1240 : !llvm.i64 %1242 = llvm.getelementptr %1228[%1241] : (!llvm\u0026lt;\u0026#34;float*\u0026#34;\u0026gt;, !llvm.i64) -\u0026gt; !llvm\u0026lt;\u0026#34;float*\u0026#34;\u0026gt; %1243 = llvm.load %1242 : !llvm\u0026lt;\u0026#34;float*\u0026#34;\u0026gt; %1244 = llvm.mlir.constant(0 : index) : !llvm.i64 %1245 = llvm.mlir.constant(0 : index) : !llvm.i64 %1246 = llvm.extractvalue %1206[1] : !llvm\u0026lt;\u0026#34;{ float*, float*, i64, [3 x i64], [3 x i64] }\u0026#34;\u0026gt; %1247 = llvm.mlir.constant(0 : index) : !llvm.i64 %1248 = llvm.mlir.constant(1 : index) : !llvm.i64 %1249 = llvm.mul %1215, %1248 : !llvm.i64 %1250 = llvm.add %1247, %1249 : !llvm.i64 %1251 = llvm.mlir.constant(1 : index) : !llvm.i64 %1252 = llvm.mul %1244, %1251 : !llvm.i64 %1253 = llvm.add %1250, %1252 : !llvm.i64 %1254 = llvm.mlir.constant(1 : index) : !llvm.i64 %1255 = llvm.mul %1245, %1254 : !llvm.i64 %1256 = llvm.add %1253, %1255 : !llvm.i64 %1257 = llvm.getelementptr %1246[%1256] : (!llvm\u0026lt;\u0026#34;float*\u0026#34;\u0026gt;, !llvm.i64) -\u0026gt; !llvm\u0026lt;\u0026#34;float*\u0026#34;\u0026gt; %1258 = llvm.load %1257 : !llvm\u0026lt;\u0026#34;float*\u0026#34;\u0026gt; %1259 = llvm.fadd %1243, %1258 : !llvm.float %1260 = llvm.extractvalue %161[1] : !llvm\u0026lt;\u0026#34;{ float*, float*, i64, [4 x i64], [4 x i64] }\u0026#34;\u0026gt; %1261 = llvm.mlir.constant(0 : index) : !llvm.i64 %1262 = llvm.mlir.constant(3136 : index) : !llvm.i64 %1263 = llvm.mul %1210, %1262 : !llvm.i64 %1264 = llvm.add %1261, %1263 : !llvm.i64 %1265 = llvm.mlir.constant(196 : index) : !llvm.i64 %1266 = llvm.mul %1215, %1265 : !llvm.i64 %1267 = llvm.add %1264, %1266 : !llvm.i64 %1268 = llvm.mlir.constant(14 : index) : !llvm.i64 %1269 = llvm.mul %1220, %1268 : !llvm.i64 %1270 = llvm.add %1267, %1269 : !llvm.i64 %1271 = llvm.mlir.constant(1 : index) : !llvm.i64 %1272 = llvm.mul %1225, %1271 : !llvm.i64 %1273 = llvm.add %1270, %1272 : !llvm.i64 %1274 = llvm.getelementptr %1260[%1273] : (!llvm\u0026lt;\u0026#34;float*\u0026#34;\u0026gt;, !llvm.i64) -\u0026gt; !llvm\u0026lt;\u0026#34;float*\u0026#34;\u0026gt; llvm.store %1259, %1274 : !llvm\u0026lt;\u0026#34;float*\u0026#34;\u0026gt; %1275 = llvm.add %1225, %1224 : !llvm.i64 llvm.br ^bb139(%1275 : !llvm.i64) ^bb141: // pred: ^bb139 %1276 = llvm.add %1220, %1219 : !llvm.i64 llvm.br ^bb137(%1276 : !llvm.i64) ^bb142: // pred: ^bb137 %1277 = llvm.add %1215, %1214 : !llvm.i64 llvm.br ^bb135(%1277 : !llvm.i64) ^bb143: // pred: ^bb135 %1278 = llvm.add %1210, %1209 : !llvm.i64 llvm.br ^bb133(%1278 : !llvm.i64) ^bb144: // pred: ^bb133 %1279 = llvm.mlir.constant(0 : index) : !llvm.i64 %1280 = llvm.mlir.constant(1 : index) : !llvm.i64 %1281 = llvm.mlir.constant(1 : index) : !llvm.i64 llvm.br ^bb145(%1279 : !llvm.i64) ^bb145(%1282: !llvm.i64): // 2 preds: ^bb144, ^bb155 %1283 = llvm.icmp \u0026#34;slt\u0026#34; %1282, %1280 : !llvm.i64 llvm.cond_br %1283, ^bb146, ^bb156 ^bb146: // pred: ^bb145 %1284 = llvm.mlir.constant(0 : index) : !llvm.i64 %1285 = llvm.mlir.constant(16 : index) : !llvm.i64 %1286 = llvm.mlir.constant(1 : index) : !llvm.i64 llvm.br ^bb147(%1284 : !llvm.i64) ^bb147(%1287: !llvm.i64): // 2 preds: ^bb146, ^bb154 %1288 = llvm.icmp \u0026#34;slt\u0026#34; %1287, %1285 : !llvm.i64 llvm.cond_br %1288, ^bb148, ^bb155 ^bb148: // pred: ^bb147 %1289 = llvm.mlir.constant(0 : index) : !llvm.i64 %1290 = llvm.mlir.constant(14 : index) : !llvm.i64 %1291 = llvm.mlir.constant(1 : index) : !llvm.i64 llvm.br ^bb149(%1289 : !llvm.i64) ^bb149(%1292: !llvm.i64): // 2 preds: ^bb148, ^bb153 %1293 = llvm.icmp \u0026#34;slt\u0026#34; %1292, %1290 : !llvm.i64 llvm.cond_br %1293, ^bb150, ^bb154 ^bb150: // pred: ^bb149 %1294 = llvm.mlir.constant(0 : index) : !llvm.i64 %1295 = llvm.mlir.constant(14 : index) : !llvm.i64 %1296 = llvm.mlir.constant(1 : index) : !llvm.i64 llvm.br ^bb151(%1294 : !llvm.i64) ^bb151(%1297: !llvm.i64): // 2 preds: ^bb150, ^bb152 %1298 = llvm.icmp \u0026#34;slt\u0026#34; %1297, %1295 : !llvm.i64 llvm.cond_br %1298, ^bb152, ^bb153 ^bb152: // pred: ^bb151 %1299 = llvm.extractvalue %161[1] : !llvm\u0026lt;\u0026#34;{ float*, float*, i64, [4 x i64], [4 x i64] }\u0026#34;\u0026gt; %1300 = llvm.mlir.constant(0 : index) : !llvm.i64 %1301 = llvm.mlir.constant(3136 : index) : !llvm.i64 %1302 = llvm.mul %1282, %1301 : !llvm.i64 %1303 = llvm.add %1300, %1302 : !llvm.i64 %1304 = llvm.mlir.constant(196 : index) : !llvm.i64 %1305 = llvm.mul %1287, %1304 : !llvm.i64 %1306 = llvm.add %1303, %1305 : !llvm.i64 %1307 = llvm.mlir.constant(14 : index) : !llvm.i64 %1308 = llvm.mul %1292, %1307 : !llvm.i64 %1309 = llvm.add %1306, %1308 : !llvm.i64 %1310 = llvm.mlir.constant(1 : index) : !llvm.i64 %1311 = llvm.mul %1297, %1310 : !llvm.i64 %1312 = llvm.add %1309, %1311 : !llvm.i64 %1313 = llvm.getelementptr %1299[%1312] : (!llvm\u0026lt;\u0026#34;float*\u0026#34;\u0026gt;, !llvm.i64) -\u0026gt; !llvm\u0026lt;\u0026#34;float*\u0026#34;\u0026gt; %1314 = llvm.load %1313 : !llvm\u0026lt;\u0026#34;float*\u0026#34;\u0026gt; %1315 = llvm.fcmp \u0026#34;olt\u0026#34; %1314, %23 : !llvm.float %1316 = llvm.select %1315, %23, %1314 : !llvm.i1, !llvm.float %1317 = llvm.extractvalue %137[1] : !llvm\u0026lt;\u0026#34;{ float*, float*, i64, [4 x i64], [4 x i64] }\u0026#34;\u0026gt; %1318 = llvm.mlir.constant(0 : index) : !llvm.i64 %1319 = llvm.mlir.constant(3136 : index) : !llvm.i64 %1320 = llvm.mul %1282, %1319 : !llvm.i64 %1321 = llvm.add %1318, %1320 : !llvm.i64 %1322 = llvm.mlir.constant(196 : index) : !llvm.i64 %1323 = llvm.mul %1287, %1322 : !llvm.i64 %1324 = llvm.add %1321, %1323 : !llvm.i64 %1325 = llvm.mlir.constant(14 : index) : !llvm.i64 %1326 = llvm.mul %1292, %1325 : !llvm.i64 %1327 = llvm.add %1324, %1326 : !llvm.i64 %1328 = llvm.mlir.constant(1 : index) : !llvm.i64 %1329 = llvm.mul %1297, %1328 : !llvm.i64 %1330 = llvm.add %1327, %1329 : !llvm.i64 %1331 = llvm.getelementptr %1317[%1330] : (!llvm\u0026lt;\u0026#34;float*\u0026#34;\u0026gt;, !llvm.i64) -\u0026gt; !llvm\u0026lt;\u0026#34;float*\u0026#34;\u0026gt; llvm.store %1316, %1331 : !llvm\u0026lt;\u0026#34;float*\u0026#34;\u0026gt; %1332 = llvm.add %1297, %1296 : !llvm.i64 llvm.br ^bb151(%1332 : !llvm.i64) ^bb153: // pred: ^bb151 %1333 = llvm.add %1292, %1291 : !llvm.i64 llvm.br ^bb149(%1333 : !llvm.i64) ^bb154: // pred: ^bb149 %1334 = llvm.add %1287, %1286 : !llvm.i64 llvm.br ^bb147(%1334 : !llvm.i64) ^bb155: // pred: ^bb147 %1335 = llvm.add %1282, %1281 : !llvm.i64 llvm.br ^bb145(%1335 : !llvm.i64) ^bb156: // pred: ^bb145 %1336 = llvm.mlir.constant(0 : index) : !llvm.i64 %1337 = llvm.mlir.constant(1 : index) : !llvm.i64 %1338 = llvm.mlir.constant(1 : index) : !llvm.i64 llvm.br ^bb157(%1336 : !llvm.i64) ^bb157(%1339: !llvm.i64): // 2 preds: ^bb156, ^bb173 %1340 = llvm.icmp \u0026#34;slt\u0026#34; %1339, %1337 : !llvm.i64 llvm.cond_br %1340, ^bb158, ^bb174 ^bb158: // pred: ^bb157 %1341 = llvm.mlir.constant(0 : index) : !llvm.i64 %1342 = llvm.mlir.constant(16 : index) : !llvm.i64 %1343 = llvm.mlir.constant(1 : index) : !llvm.i64 llvm.br ^bb159(%1341 : !llvm.i64) ^bb159(%1344: !llvm.i64): // 2 preds: ^bb158, ^bb172 %1345 = llvm.icmp \u0026#34;slt\u0026#34; %1344, %1342 : !llvm.i64 llvm.cond_br %1345, ^bb160, ^bb173 ^bb160: // pred: ^bb159 %1346 = llvm.mlir.constant(0 : index) : !llvm.i64 %1347 = llvm.mlir.constant(4 : index) : !llvm.i64 %1348 = llvm.mlir.constant(1 : index) : !llvm.i64 llvm.br ^bb161(%1346 : !llvm.i64) ^bb161(%1349: !llvm.i64): // 2 preds: ^bb160, ^bb171 %1350 = llvm.icmp \u0026#34;slt\u0026#34; %1349, %1347 : !llvm.i64 llvm.cond_br %1350, ^bb162, ^bb172 ^bb162: // pred: ^bb161 %1351 = llvm.mlir.constant(0 : index) : !llvm.i64 %1352 = llvm.mlir.constant(4 : index) : !llvm.i64 %1353 = llvm.mlir.constant(1 : index) : !llvm.i64 llvm.br ^bb163(%1351 : !llvm.i64) ^bb163(%1354: !llvm.i64): // 2 preds: ^bb162, ^bb170 %1355 = llvm.icmp \u0026#34;slt\u0026#34; %1354, %1352 : !llvm.i64 llvm.cond_br %1355, ^bb164, ^bb171 ^bb164: // pred: ^bb163 %1356 = llvm.extractvalue %113[1] : !llvm\u0026lt;\u0026#34;{ float*, float*, i64, [4 x i64], [4 x i64] }\u0026#34;\u0026gt; %1357 = llvm.mlir.constant(0 : index) : !llvm.i64 %1358 = llvm.mlir.constant(256 : index) : !llvm.i64 %1359 = llvm.mul %1339, %1358 : !llvm.i64 %1360 = llvm.add %1357, %1359 : !llvm.i64 %1361 = llvm.mlir.constant(16 : index) : !llvm.i64 %1362 = llvm.mul %1344, %1361 : !llvm.i64 %1363 = llvm.add %1360, %1362 : !llvm.i64 %1364 = llvm.mlir.constant(4 : index) : !llvm.i64 %1365 = llvm.mul %1349, %1364 : !llvm.i64 %1366 = llvm.add %1363, %1365 : !llvm.i64 %1367 = llvm.mlir.constant(1 : index) : !llvm.i64 %1368 = llvm.mul %1354, %1367 : !llvm.i64 %1369 = llvm.add %1366, %1368 : !llvm.i64 %1370 = llvm.getelementptr %1356[%1369] : (!llvm\u0026lt;\u0026#34;float*\u0026#34;\u0026gt;, !llvm.i64) -\u0026gt; !llvm\u0026lt;\u0026#34;float*\u0026#34;\u0026gt; llvm.store %17, %1370 : !llvm\u0026lt;\u0026#34;float*\u0026#34;\u0026gt; %1371 = llvm.mlir.constant(0 : index) : !llvm.i64 %1372 = llvm.mlir.constant(3 : index) : !llvm.i64 %1373 = llvm.mul %1349, %1372 : !llvm.i64 %1374 = llvm.icmp \u0026#34;sgt\u0026#34; %1371, %1373 : !llvm.i64 %1375 = llvm.select %1374, %1371, %1373 : !llvm.i1, !llvm.i64 %1376 = llvm.mlir.constant(0 : index) : !llvm.i64 %1377 = llvm.mlir.constant(3 : index) : !llvm.i64 %1378 = llvm.mul %1354, %1377 : !llvm.i64 %1379 = llvm.icmp \u0026#34;sgt\u0026#34; %1376, %1378 : !llvm.i64 %1380 = llvm.select %1379, %1376, %1378 : !llvm.i1, !llvm.i64 %1381 = llvm.mlir.constant(0 : index) : !llvm.i64 %1382 = llvm.mlir.constant(14 : index) : !llvm.i64 %1383 = llvm.mlir.constant(-3 : index) : !llvm.i64 %1384 = llvm.mul %1349, %1383 : !llvm.i64 %1385 = llvm.mlir.constant(14 : index) : !llvm.i64 %1386 = llvm.add %1384, %1385 : !llvm.i64 %1387 = llvm.mlir.constant(3 : index) : !llvm.i64 %1388 = llvm.mul %1349, %1387 : !llvm.i64 %1389 = llvm.mlir.constant(3 : index) : !llvm.i64 %1390 = llvm.add %1388, %1389 : !llvm.i64 %1391 = llvm.mlir.constant(3 : index) : !llvm.i64 %1392 = llvm.icmp \u0026#34;slt\u0026#34; %1382, %1386 : !llvm.i64 %1393 = llvm.select %1392, %1382, %1386 : !llvm.i1, !llvm.i64 %1394 = llvm.icmp \u0026#34;slt\u0026#34; %1393, %1390 : !llvm.i64 %1395 = llvm.select %1394, %1393, %1390 : !llvm.i1, !llvm.i64 %1396 = llvm.icmp \u0026#34;slt\u0026#34; %1395, %1391 : !llvm.i64 %1397 = llvm.select %1396, %1395, %1391 : !llvm.i1, !llvm.i64 %1398 = llvm.mlir.constant(1 : index) : !llvm.i64 llvm.br ^bb165(%1381 : !llvm.i64) ^bb165(%1399: !llvm.i64): // 2 preds: ^bb164, ^bb169 %1400 = llvm.icmp \u0026#34;slt\u0026#34; %1399, %1397 : !llvm.i64 llvm.cond_br %1400, ^bb166, ^bb170 ^bb166: // pred: ^bb165 %1401 = llvm.mlir.constant(0 : index) : !llvm.i64 %1402 = llvm.mlir.constant(14 : index) : !llvm.i64 %1403 = llvm.mlir.constant(-3 : index) : !llvm.i64 %1404 = llvm.mul %1354, %1403 : !llvm.i64 %1405 = llvm.mlir.constant(14 : index) : !llvm.i64 %1406 = llvm.add %1404, %1405 : !llvm.i64 %1407 = llvm.mlir.constant(3 : index) : !llvm.i64 %1408 = llvm.mul %1354, %1407 : !llvm.i64 %1409 = llvm.mlir.constant(3 : index) : !llvm.i64 %1410 = llvm.add %1408, %1409 : !llvm.i64 %1411 = llvm.mlir.constant(3 : index) : !llvm.i64 %1412 = llvm.icmp \u0026#34;slt\u0026#34; %1402, %1406 : !llvm.i64 %1413 = llvm.select %1412, %1402, %1406 : !llvm.i1, !llvm.i64 %1414 = llvm.icmp \u0026#34;slt\u0026#34; %1413, %1410 : !llvm.i64 %1415 = llvm.select %1414, %1413, %1410 : !llvm.i1, !llvm.i64 %1416 = llvm.icmp \u0026#34;slt\u0026#34; %1415, %1411 : !llvm.i64 %1417 = llvm.select %1416, %1415, %1411 : !llvm.i1, !llvm.i64 %1418 = llvm.mlir.constant(1 : index) : !llvm.i64 llvm.br ^bb167(%1401 : !llvm.i64) ^bb167(%1419: !llvm.i64): // 2 preds: ^bb166, ^bb168 %1420 = llvm.icmp \u0026#34;slt\u0026#34; %1419, %1417 : !llvm.i64 llvm.cond_br %1420, ^bb168, ^bb169 ^bb168: // pred: ^bb167 %1421 = llvm.add %1399, %1375 : !llvm.i64 %1422 = llvm.add %1419, %1380 : !llvm.i64 %1423 = llvm.extractvalue %137[1] : !llvm\u0026lt;\u0026#34;{ float*, float*, i64, [4 x i64], [4 x i64] }\u0026#34;\u0026gt; %1424 = llvm.mlir.constant(0 : index) : !llvm.i64 %1425 = llvm.mlir.constant(3136 : index) : !llvm.i64 %1426 = llvm.mul %1339, %1425 : !llvm.i64 %1427 = llvm.add %1424, %1426 : !llvm.i64 %1428 = llvm.mlir.constant(196 : index) : !llvm.i64 %1429 = llvm.mul %1344, %1428 : !llvm.i64 %1430 = llvm.add %1427, %1429 : !llvm.i64 %1431 = llvm.mlir.constant(14 : index) : !llvm.i64 %1432 = llvm.mul %1421, %1431 : !llvm.i64 %1433 = llvm.add %1430, %1432 : !llvm.i64 %1434 = llvm.mlir.constant(1 : index) : !llvm.i64 %1435 = llvm.mul %1422, %1434 : !llvm.i64 %1436 = llvm.add %1433, %1435 : !llvm.i64 %1437 = llvm.getelementptr %1423[%1436] : (!llvm\u0026lt;\u0026#34;float*\u0026#34;\u0026gt;, !llvm.i64) -\u0026gt; !llvm\u0026lt;\u0026#34;float*\u0026#34;\u0026gt; %1438 = llvm.load %1437 : !llvm\u0026lt;\u0026#34;float*\u0026#34;\u0026gt; %1439 = llvm.extractvalue %113[1] : !llvm\u0026lt;\u0026#34;{ float*, float*, i64, [4 x i64], [4 x i64] }\u0026#34;\u0026gt; %1440 = llvm.mlir.constant(0 : index) : !llvm.i64 %1441 = llvm.mlir.constant(256 : index) : !llvm.i64 %1442 = llvm.mul %1339, %1441 : !llvm.i64 %1443 = llvm.add %1440, %1442 : !llvm.i64 %1444 = llvm.mlir.constant(16 : index) : !llvm.i64 %1445 = llvm.mul %1344, %1444 : !llvm.i64 %1446 = llvm.add %1443, %1445 : !llvm.i64 %1447 = llvm.mlir.constant(4 : index) : !llvm.i64 %1448 = llvm.mul %1349, %1447 : !llvm.i64 %1449 = llvm.add %1446, %1448 : !llvm.i64 %1450 = llvm.mlir.constant(1 : index) : !llvm.i64 %1451 = llvm.mul %1354, %1450 : !llvm.i64 %1452 = llvm.add %1449, %1451 : !llvm.i64 %1453 = llvm.getelementptr %1439[%1452] : (!llvm\u0026lt;\u0026#34;float*\u0026#34;\u0026gt;, !llvm.i64) -\u0026gt; !llvm\u0026lt;\u0026#34;float*\u0026#34;\u0026gt; %1454 = llvm.load %1453 : !llvm\u0026lt;\u0026#34;float*\u0026#34;\u0026gt; %1455 = llvm.fcmp \u0026#34;ogt\u0026#34; %1454, %1438 : !llvm.float %1456 = llvm.select %1455, %1454, %1438 : !llvm.i1, !llvm.float %1457 = llvm.extractvalue %113[1] : !llvm\u0026lt;\u0026#34;{ float*, float*, i64, [4 x i64], [4 x i64] }\u0026#34;\u0026gt; %1458 = llvm.mlir.constant(0 : index) : !llvm.i64 %1459 = llvm.mlir.constant(256 : index) : !llvm.i64 %1460 = llvm.mul %1339, %1459 : !llvm.i64 %1461 = llvm.add %1458, %1460 : !llvm.i64 %1462 = llvm.mlir.constant(16 : index) : !llvm.i64 %1463 = llvm.mul %1344, %1462 : !llvm.i64 %1464 = llvm.add %1461, %1463 : !llvm.i64 %1465 = llvm.mlir.constant(4 : index) : !llvm.i64 %1466 = llvm.mul %1349, %1465 : !llvm.i64 %1467 = llvm.add %1464, %1466 : !llvm.i64 %1468 = llvm.mlir.constant(1 : index) : !llvm.i64 %1469 = llvm.mul %1354, %1468 : !llvm.i64 %1470 = llvm.add %1467, %1469 : !llvm.i64 %1471 = llvm.getelementptr %1457[%1470] : (!llvm\u0026lt;\u0026#34;float*\u0026#34;\u0026gt;, !llvm.i64) -\u0026gt; !llvm\u0026lt;\u0026#34;float*\u0026#34;\u0026gt; llvm.store %1456, %1471 : !llvm\u0026lt;\u0026#34;float*\u0026#34;\u0026gt; %1472 = llvm.add %1419, %1418 : !llvm.i64 llvm.br ^bb167(%1472 : !llvm.i64) ^bb169: // pred: ^bb167 %1473 = llvm.add %1399, %1398 : !llvm.i64 llvm.br ^bb165(%1473 : !llvm.i64) ^bb170: // pred: ^bb165 %1474 = llvm.add %1354, %1353 : !llvm.i64 llvm.br ^bb163(%1474 : !llvm.i64) ^bb171: // pred: ^bb163 %1475 = llvm.add %1349, %1348 : !llvm.i64 llvm.br ^bb161(%1475 : !llvm.i64) ^bb172: // pred: ^bb161 %1476 = llvm.add %1344, %1343 : !llvm.i64 llvm.br ^bb159(%1476 : !llvm.i64) ^bb173: // pred: ^bb159 %1477 = llvm.add %1339, %1338 : !llvm.i64 llvm.br ^bb157(%1477 : !llvm.i64) ^bb174: // pred: ^bb157 %1478 = llvm.extractvalue %89[1] : !llvm\u0026lt;\u0026#34;{ float*, float*, i64, [2 x i64], [2 x i64] }\u0026#34;\u0026gt; %1479 = llvm.bitcast %1478 : !llvm\u0026lt;\u0026#34;float*\u0026#34;\u0026gt; to !llvm\u0026lt;\u0026#34;i8*\u0026#34;\u0026gt; %1480 = llvm.extractvalue %113[1] : !llvm\u0026lt;\u0026#34;{ float*, float*, i64, [4 x i64], [4 x i64] }\u0026#34;\u0026gt; %1481 = llvm.bitcast %1480 : !llvm\u0026lt;\u0026#34;float*\u0026#34;\u0026gt; to !llvm\u0026lt;\u0026#34;i8*\u0026#34;\u0026gt; %1482 = llvm.sext %21 : !llvm.i64 to !llvm.i64 %1483 = llvm.mlir.constant(false) : !llvm.i1 %1484 = llvm.call @llvm.memcpy.p0i8.p0i8.i64(%1479, %1481, %1482, %1483) : (!llvm\u0026lt;\u0026#34;i8*\u0026#34;\u0026gt;, !llvm\u0026lt;\u0026#34;i8*\u0026#34;\u0026gt;, !llvm.i64, !llvm.i1) -\u0026gt; !llvm.void %1485 = llvm.mlir.constant(1 : i64) : !llvm.i64 %1486 = llvm.alloca %1485 x !llvm\u0026lt;\u0026#34;[1 x [10 x float]]\u0026#34;\u0026gt; : (!llvm.i64) -\u0026gt; !llvm\u0026lt;\u0026#34;[1 x [10 x float]]*\u0026#34;\u0026gt; %1487 = llvm.bitcast %1486 : !llvm\u0026lt;\u0026#34;[1 x [10 x float]]*\u0026#34;\u0026gt; to !llvm\u0026lt;\u0026#34;i8*\u0026#34;\u0026gt; %1488 = llvm.mlir.addressof @constant_5 : !llvm\u0026lt;\u0026#34;[1 x [10 x float]]*\u0026#34;\u0026gt; %1489 = llvm.bitcast %1488 : !llvm\u0026lt;\u0026#34;[1 x [10 x float]]*\u0026#34;\u0026gt; to !llvm\u0026lt;\u0026#34;i8*\u0026#34;\u0026gt; %1490 = llvm.mlir.constant(4 : i64) : !llvm.i64 %1491 = llvm.mlir.constant(10 : i64) : !llvm.i64 %1492 = llvm.mul %1490, %1491 : !llvm.i64 %1493 = llvm.sext %1492 : !llvm.i64 to !llvm.i64 %1494 = llvm.mlir.constant(false) : !llvm.i1 %1495 = llvm.call @llvm.memcpy.p0i8.p0i8.i64(%1487, %1489, %1493, %1494) : (!llvm\u0026lt;\u0026#34;i8*\u0026#34;\u0026gt;, !llvm\u0026lt;\u0026#34;i8*\u0026#34;\u0026gt;, !llvm.i64, !llvm.i1) -\u0026gt; !llvm.void %1496 = llvm.bitcast %1486 : !llvm\u0026lt;\u0026#34;[1 x [10 x float]]*\u0026#34;\u0026gt; to !llvm\u0026lt;\u0026#34;float*\u0026#34;\u0026gt; %1497 = llvm.mlir.undef : !llvm\u0026lt;\u0026#34;{ float*, float*, i64, [2 x i64], [2 x i64] }\u0026#34;\u0026gt; %1498 = llvm.insertvalue %1496, %1497[0] : !llvm\u0026lt;\u0026#34;{ float*, float*, i64, [2 x i64], [2 x i64] }\u0026#34;\u0026gt; %1499 = llvm.insertvalue %1496, %1498[1] : !llvm\u0026lt;\u0026#34;{ float*, float*, i64, [2 x i64], [2 x i64] }\u0026#34;\u0026gt; %1500 = llvm.mlir.constant(0 : index) : !llvm.i64 %1501 = llvm.insertvalue %1500, %1499[2] : !llvm\u0026lt;\u0026#34;{ float*, float*, i64, [2 x i64], [2 x i64] }\u0026#34;\u0026gt; %1502 = llvm.mlir.constant(1 : index) : !llvm.i64 %1503 = llvm.insertvalue %1502, %1501[3, 0] : !llvm\u0026lt;\u0026#34;{ float*, float*, i64, [2 x i64], [2 x i64] }\u0026#34;\u0026gt; %1504 = llvm.mlir.constant(10 : index) : !llvm.i64 %1505 = llvm.insertvalue %1504, %1503[4, 0] : !llvm\u0026lt;\u0026#34;{ float*, float*, i64, [2 x i64], [2 x i64] }\u0026#34;\u0026gt; %1506 = llvm.mlir.constant(10 : index) : !llvm.i64 %1507 = llvm.insertvalue %1506, %1505[3, 1] : !llvm\u0026lt;\u0026#34;{ float*, float*, i64, [2 x i64], [2 x i64] }\u0026#34;\u0026gt; %1508 = llvm.mlir.constant(1 : index) : !llvm.i64 %1509 = llvm.insertvalue %1508, %1507[4, 1] : !llvm\u0026lt;\u0026#34;{ float*, float*, i64, [2 x i64], [2 x i64] }\u0026#34;\u0026gt; %1510 = llvm.mlir.constant(0 : index) : !llvm.i64 %1511 = llvm.mlir.constant(1 : index) : !llvm.i64 %1512 = llvm.mlir.constant(1 : index) : !llvm.i64 llvm.br ^bb175(%1510 : !llvm.i64) ^bb175(%1513: !llvm.i64): // 2 preds: ^bb174, ^bb182 %1514 = llvm.icmp \u0026#34;slt\u0026#34; %1513, %1511 : !llvm.i64 llvm.cond_br %1514, ^bb176, ^bb183 ^bb176: // pred: ^bb175 %1515 = llvm.mlir.constant(0 : index) : !llvm.i64 %1516 = llvm.mlir.constant(10 : index) : !llvm.i64 %1517 = llvm.mlir.constant(1 : index) : !llvm.i64 llvm.br ^bb177(%1515 : !llvm.i64) ^bb177(%1518: !llvm.i64): // 2 preds: ^bb176, ^bb181 %1519 = llvm.icmp \u0026#34;slt\u0026#34; %1518, %1516 : !llvm.i64 llvm.cond_br %1519, ^bb178, ^bb182 ^bb178: // pred: ^bb177 %1520 = llvm.extractvalue %57[1] : !llvm\u0026lt;\u0026#34;{ float*, float*, i64, [2 x i64], [2 x i64] }\u0026#34;\u0026gt; %1521 = llvm.mlir.constant(0 : index) : !llvm.i64 %1522 = llvm.mlir.constant(10 : index) : !llvm.i64 %1523 = llvm.mul %1513, %1522 : !llvm.i64 %1524 = llvm.add %1521, %1523 : !llvm.i64 %1525 = llvm.mlir.constant(1 : index) : !llvm.i64 %1526 = llvm.mul %1518, %1525 : !llvm.i64 %1527 = llvm.add %1524, %1526 : !llvm.i64 %1528 = llvm.getelementptr %1520[%1527] : (!llvm\u0026lt;\u0026#34;float*\u0026#34;\u0026gt;, !llvm.i64) -\u0026gt; !llvm\u0026lt;\u0026#34;float*\u0026#34;\u0026gt; llvm.store %23, %1528 : !llvm\u0026lt;\u0026#34;float*\u0026#34;\u0026gt; %1529 = llvm.mlir.constant(0 : index) : !llvm.i64 %1530 = llvm.mlir.constant(256 : index) : !llvm.i64 %1531 = llvm.mlir.constant(1 : index) : !llvm.i64 llvm.br ^bb179(%1529 : !llvm.i64) ^bb179(%1532: !llvm.i64): // 2 preds: ^bb178, ^bb180 %1533 = llvm.icmp \u0026#34;slt\u0026#34; %1532, %1530 : !llvm.i64 llvm.cond_br %1533, ^bb180, ^bb181 ^bb180: // pred: ^bb179 %1534 = llvm.extractvalue %89[1] : !llvm\u0026lt;\u0026#34;{ float*, float*, i64, [2 x i64], [2 x i64] }\u0026#34;\u0026gt; %1535 = llvm.mlir.constant(0 : index) : !llvm.i64 %1536 = llvm.mlir.constant(256 : index) : !llvm.i64 %1537 = llvm.mul %1513, %1536 : !llvm.i64 %1538 = llvm.add %1535, %1537 : !llvm.i64 %1539 = llvm.mlir.constant(1 : index) : !llvm.i64 %1540 = llvm.mul %1532, %1539 : !llvm.i64 %1541 = llvm.add %1538, %1540 : !llvm.i64 %1542 = llvm.getelementptr %1534[%1541] : (!llvm\u0026lt;\u0026#34;float*\u0026#34;\u0026gt;, !llvm.i64) -\u0026gt; !llvm\u0026lt;\u0026#34;float*\u0026#34;\u0026gt; %1543 = llvm.load %1542 : !llvm\u0026lt;\u0026#34;float*\u0026#34;\u0026gt; %1544 = llvm.extractvalue %345[1] : !llvm\u0026lt;\u0026#34;{ float*, float*, i64, [2 x i64], [2 x i64] }\u0026#34;\u0026gt; %1545 = llvm.mlir.constant(0 : index) : !llvm.i64 %1546 = llvm.mlir.constant(10 : index) : !llvm.i64 %1547 = llvm.mul %1532, %1546 : !llvm.i64 %1548 = llvm.add %1545, %1547 : !llvm.i64 %1549 = llvm.mlir.constant(1 : index) : !llvm.i64 %1550 = llvm.mul %1518, %1549 : !llvm.i64 %1551 = llvm.add %1548, %1550 : !llvm.i64 %1552 = llvm.getelementptr %1544[%1551] : (!llvm\u0026lt;\u0026#34;float*\u0026#34;\u0026gt;, !llvm.i64) -\u0026gt; !llvm\u0026lt;\u0026#34;float*\u0026#34;\u0026gt; %1553 = llvm.load %1552 : !llvm\u0026lt;\u0026#34;float*\u0026#34;\u0026gt; %1554 = llvm.extractvalue %57[1] : !llvm\u0026lt;\u0026#34;{ float*, float*, i64, [2 x i64], [2 x i64] }\u0026#34;\u0026gt; %1555 = llvm.mlir.constant(0 : index) : !llvm.i64 %1556 = llvm.mlir.constant(10 : index) : !llvm.i64 %1557 = llvm.mul %1513, %1556 : !llvm.i64 %1558 = llvm.add %1555, %1557 : !llvm.i64 %1559 = llvm.mlir.constant(1 : index) : !llvm.i64 %1560 = llvm.mul %1518, %1559 : !llvm.i64 %1561 = llvm.add %1558, %1560 : !llvm.i64 %1562 = llvm.getelementptr %1554[%1561] : (!llvm\u0026lt;\u0026#34;float*\u0026#34;\u0026gt;, !llvm.i64) -\u0026gt; !llvm\u0026lt;\u0026#34;float*\u0026#34;\u0026gt; %1563 = llvm.load %1562 : !llvm\u0026lt;\u0026#34;float*\u0026#34;\u0026gt; %1564 = llvm.fmul %1543, %1553 : !llvm.float %1565 = llvm.fadd %1563, %1564 : !llvm.float %1566 = llvm.extractvalue %57[1] : !llvm\u0026lt;\u0026#34;{ float*, float*, i64, [2 x i64], [2 x i64] }\u0026#34;\u0026gt; %1567 = llvm.mlir.constant(0 : index) : !llvm.i64 %1568 = llvm.mlir.constant(10 : index) : !llvm.i64 %1569 = llvm.mul %1513, %1568 : !llvm.i64 %1570 = llvm.add %1567, %1569 : !llvm.i64 %1571 = llvm.mlir.constant(1 : index) : !llvm.i64 %1572 = llvm.mul %1518, %1571 : !llvm.i64 %1573 = llvm.add %1570, %1572 : !llvm.i64 %1574 = llvm.getelementptr %1566[%1573] : (!llvm\u0026lt;\u0026#34;float*\u0026#34;\u0026gt;, !llvm.i64) -\u0026gt; !llvm\u0026lt;\u0026#34;float*\u0026#34;\u0026gt; llvm.store %1565, %1574 : !llvm\u0026lt;\u0026#34;float*\u0026#34;\u0026gt; %1575 = llvm.add %1532, %1531 : !llvm.i64 llvm.br ^bb179(%1575 : !llvm.i64) ^bb181: // pred: ^bb179 %1576 = llvm.extractvalue %57[1] : !llvm\u0026lt;\u0026#34;{ float*, float*, i64, [2 x i64], [2 x i64] }\u0026#34;\u0026gt; %1577 = llvm.mlir.constant(0 : index) : !llvm.i64 %1578 = llvm.mlir.constant(10 : index) : !llvm.i64 %1579 = llvm.mul %1513, %1578 : !llvm.i64 %1580 = llvm.add %1577, %1579 : !llvm.i64 %1581 = llvm.mlir.constant(1 : index) : !llvm.i64 %1582 = llvm.mul %1518, %1581 : !llvm.i64 %1583 = llvm.add %1580, %1582 : !llvm.i64 %1584 = llvm.getelementptr %1576[%1583] : (!llvm\u0026lt;\u0026#34;float*\u0026#34;\u0026gt;, !llvm.i64) -\u0026gt; !llvm\u0026lt;\u0026#34;float*\u0026#34;\u0026gt; %1585 = llvm.load %1584 : !llvm\u0026lt;\u0026#34;float*\u0026#34;\u0026gt; %1586 = llvm.fmul %22, %1585 : !llvm.float %1587 = llvm.mlir.constant(0 : index) : !llvm.i64 %1588 = llvm.extractvalue %1509[1] : !llvm\u0026lt;\u0026#34;{ float*, float*, i64, [2 x i64], [2 x i64] }\u0026#34;\u0026gt; %1589 = llvm.mlir.constant(0 : index) : !llvm.i64 %1590 = llvm.mlir.constant(10 : index) : !llvm.i64 %1591 = llvm.mul %1587, %1590 : !llvm.i64 %1592 = llvm.add %1589, %1591 : !llvm.i64 %1593 = llvm.mlir.constant(1 : index) : !llvm.i64 %1594 = llvm.mul %1518, %1593 : !llvm.i64 %1595 = llvm.add %1592, %1594 : !llvm.i64 %1596 = llvm.getelementptr %1588[%1595] : (!llvm\u0026lt;\u0026#34;float*\u0026#34;\u0026gt;, !llvm.i64) -\u0026gt; !llvm\u0026lt;\u0026#34;float*\u0026#34;\u0026gt; %1597 = llvm.load %1596 : !llvm\u0026lt;\u0026#34;float*\u0026#34;\u0026gt; %1598 = llvm.fmul %22, %1597 : !llvm.float %1599 = llvm.fadd %1586, %1598 : !llvm.float %1600 = llvm.extractvalue %57[1] : !llvm\u0026lt;\u0026#34;{ float*, float*, i64, [2 x i64], [2 x i64] }\u0026#34;\u0026gt; %1601 = llvm.mlir.constant(0 : index) : !llvm.i64 %1602 = llvm.mlir.constant(10 : index) : !llvm.i64 %1603 = llvm.mul %1513, %1602 : !llvm.i64 %1604 = llvm.add %1601, %1603 : !llvm.i64 %1605 = llvm.mlir.constant(1 : index) : !llvm.i64 %1606 = llvm.mul %1518, %1605 : !llvm.i64 %1607 = llvm.add %1604, %1606 : !llvm.i64 %1608 = llvm.getelementptr %1600[%1607] : (!llvm\u0026lt;\u0026#34;float*\u0026#34;\u0026gt;, !llvm.i64) -\u0026gt; !llvm\u0026lt;\u0026#34;float*\u0026#34;\u0026gt; llvm.store %1599, %1608 : !llvm\u0026lt;\u0026#34;float*\u0026#34;\u0026gt; %1609 = llvm.add %1518, %1517 : !llvm.i64 llvm.br ^bb177(%1609 : !llvm.i64) ^bb182: // pred: ^bb177 %1610 = llvm.add %1513, %1512 : !llvm.i64 llvm.br ^bb175(%1610 : !llvm.i64) ^bb183: // pred: ^bb175 %1611 = llvm.extractvalue %73[0] : !llvm\u0026lt;\u0026#34;{ i8*, i8*, i64, [1 x i64], [1 x i64] }\u0026#34;\u0026gt; %1612 = llvm.bitcast %1611 : !llvm\u0026lt;\u0026#34;i8*\u0026#34;\u0026gt; to !llvm\u0026lt;\u0026#34;i8*\u0026#34;\u0026gt; llvm.call @free(%1612) : (!llvm\u0026lt;\u0026#34;i8*\u0026#34;\u0026gt;) -\u0026gt; () llvm.return %57 : !llvm\u0026lt;\u0026#34;{ float*, float*, i64, [2 x i64], [2 x i64] }\u0026#34;\u0026gt; } llvm.func @_mlir_ciface_main_graph(%arg0: !llvm\u0026lt;\u0026#34;{ float*, float*, i64, [4 x i64], [4 x i64] }*\u0026#34;\u0026gt;) -\u0026gt; !llvm\u0026lt;\u0026#34;{ float*, float*, i64, [2 x i64], [2 x i64] }\u0026#34;\u0026gt; { %0 = llvm.load %arg0 : !llvm\u0026lt;\u0026#34;{ float*, float*, i64, [4 x i64], [4 x i64] }*\u0026#34;\u0026gt; %1 = llvm.extractvalue %0[0] : !llvm\u0026lt;\u0026#34;{ float*, float*, i64, [4 x i64], [4 x i64] }\u0026#34;\u0026gt; %2 = llvm.extractvalue %0[1] : !llvm\u0026lt;\u0026#34;{ float*, float*, i64, [4 x i64], [4 x i64] }\u0026#34;\u0026gt; %3 = llvm.extractvalue %0[2] : !llvm\u0026lt;\u0026#34;{ float*, float*, i64, [4 x i64], [4 x i64] }\u0026#34;\u0026gt; %4 = llvm.extractvalue %0[3, 0] : !llvm\u0026lt;\u0026#34;{ float*, float*, i64, [4 x i64], [4 x i64] }\u0026#34;\u0026gt; %5 = llvm.extractvalue %0[3, 1] : !llvm\u0026lt;\u0026#34;{ float*, float*, i64, [4 x i64], [4 x i64] }\u0026#34;\u0026gt; %6 = llvm.extractvalue %0[3, 2] : !llvm\u0026lt;\u0026#34;{ float*, float*, i64, [4 x i64], [4 x i64] }\u0026#34;\u0026gt; %7 = llvm.extractvalue %0[3, 3] : !llvm\u0026lt;\u0026#34;{ float*, float*, i64, [4 x i64], [4 x i64] }\u0026#34;\u0026gt; %8 = llvm.extractvalue %0[4, 0] : !llvm\u0026lt;\u0026#34;{ float*, float*, i64, [4 x i64], [4 x i64] }\u0026#34;\u0026gt; %9 = llvm.extractvalue %0[4, 1] : !llvm\u0026lt;\u0026#34;{ float*, float*, i64, [4 x i64], [4 x i64] }\u0026#34;\u0026gt; %10 = llvm.extractvalue %0[4, 2] : !llvm\u0026lt;\u0026#34;{ float*, float*, i64, [4 x i64], [4 x i64] }\u0026#34;\u0026gt; %11 = llvm.extractvalue %0[4, 3] : !llvm\u0026lt;\u0026#34;{ float*, float*, i64, [4 x i64], [4 x i64] }\u0026#34;\u0026gt; %12 = llvm.call @main_graph(%1, %2, %3, %4, %5, %6, %7, %8, %9, %10, %11) : (!llvm\u0026lt;\u0026#34;float*\u0026#34;\u0026gt;, !llvm\u0026lt;\u0026#34;float*\u0026#34;\u0026gt;, !llvm.i64, !llvm.i64, !llvm.i64, !llvm.i64, !llvm.i64, !llvm.i64, !llvm.i64, !llvm.i64, !llvm.i64) -\u0026gt; !llvm\u0026lt;\u0026#34;{ float*, float*, i64, [2 x i64], [2 x i64] }\u0026#34;\u0026gt; llvm.return %12 : !llvm\u0026lt;\u0026#34;{ float*, float*, i64, [2 x i64], [2 x i64] }\u0026#34;\u0026gt; } llvm.func @_dyn_entry_point_main_graph(%arg0: !llvm\u0026lt;\u0026#34;i8*\u0026#34;\u0026gt;) -\u0026gt; !llvm\u0026lt;\u0026#34;i8*\u0026#34;\u0026gt; { %0 = llvm.mlir.constant(0 : i32) : !llvm.i32 %1 = llvm.call @getRtMemRef(%arg0, %0) : (!llvm\u0026lt;\u0026#34;i8*\u0026#34;\u0026gt;, !llvm.i32) -\u0026gt; !llvm\u0026lt;\u0026#34;i8*\u0026#34;\u0026gt; %2 = llvm.mlir.constant(1 : i32) : !llvm.i32 %3 = llvm.alloca %2 x !llvm\u0026lt;\u0026#34;{ float*, float*, i64, [4 x i64], [4 x i64] }\u0026#34;\u0026gt; : (!llvm.i32) -\u0026gt; !llvm\u0026lt;\u0026#34;{ float*, float*, i64, [4 x i64], [4 x i64] }*\u0026#34;\u0026gt; %4 = llvm.load %3 : !llvm\u0026lt;\u0026#34;{ float*, float*, i64, [4 x i64], [4 x i64] }*\u0026#34;\u0026gt; %5 = llvm.call @getData(%1) : (!llvm\u0026lt;\u0026#34;i8*\u0026#34;\u0026gt;) -\u0026gt; !llvm\u0026lt;\u0026#34;i8*\u0026#34;\u0026gt; %6 = llvm.bitcast %5 : !llvm\u0026lt;\u0026#34;i8*\u0026#34;\u0026gt; to !llvm\u0026lt;\u0026#34;float*\u0026#34;\u0026gt; %7 = llvm.insertvalue %6, %4[0 : i32] : !llvm\u0026lt;\u0026#34;{ float*, float*, i64, [4 x i64], [4 x i64] }*\u0026#34;\u0026gt; %8 = llvm.insertvalue %6, %7[1 : i32] : !llvm\u0026lt;\u0026#34;{ float*, float*, i64, [4 x i64], [4 x i64] }\u0026#34;\u0026gt; %9 = llvm.mlir.constant(0 : i64) : !llvm.i64 %10 = llvm.insertvalue %9, %8[2 : i32] : !llvm\u0026lt;\u0026#34;{ float*, float*, i64, [4 x i64], [4 x i64] }\u0026#34;\u0026gt; %11 = llvm.call @getSizes(%1) : (!llvm\u0026lt;\u0026#34;i8*\u0026#34;\u0026gt;) -\u0026gt; !llvm\u0026lt;\u0026#34;i64*\u0026#34;\u0026gt; %12 = llvm.call @getStrides(%1) : (!llvm\u0026lt;\u0026#34;i8*\u0026#34;\u0026gt;) -\u0026gt; !llvm\u0026lt;\u0026#34;i64*\u0026#34;\u0026gt; %13 = llvm.mlir.constant(0 : i64) : !llvm.i64 %14 = llvm.getelementptr %11[%13] : (!llvm\u0026lt;\u0026#34;i64*\u0026#34;\u0026gt;, !llvm.i64) -\u0026gt; !llvm\u0026lt;\u0026#34;i64*\u0026#34;\u0026gt; %15 = llvm.load %14 : !llvm\u0026lt;\u0026#34;i64*\u0026#34;\u0026gt; %16 = llvm.insertvalue %15, %10[3, 0] : !llvm\u0026lt;\u0026#34;{ float*, float*, i64, [4 x i64], [4 x i64] }\u0026#34;\u0026gt; %17 = llvm.getelementptr %11[%13] : (!llvm\u0026lt;\u0026#34;i64*\u0026#34;\u0026gt;, !llvm.i64) -\u0026gt; !llvm\u0026lt;\u0026#34;i64*\u0026#34;\u0026gt; %18 = llvm.load %17 : !llvm\u0026lt;\u0026#34;i64*\u0026#34;\u0026gt; %19 = llvm.insertvalue %18, %16[4, 0] : !llvm\u0026lt;\u0026#34;{ float*, float*, i64, [4 x i64], [4 x i64] }\u0026#34;\u0026gt; %20 = llvm.mlir.constant(1 : i64) : !llvm.i64 %21 = llvm.getelementptr %11[%20] : (!llvm\u0026lt;\u0026#34;i64*\u0026#34;\u0026gt;, !llvm.i64) -\u0026gt; !llvm\u0026lt;\u0026#34;i64*\u0026#34;\u0026gt; %22 = llvm.load %21 : !llvm\u0026lt;\u0026#34;i64*\u0026#34;\u0026gt; %23 = llvm.insertvalue %22, %19[3, 1] : !llvm\u0026lt;\u0026#34;{ float*, float*, i64, [4 x i64], [4 x i64] }\u0026#34;\u0026gt; %24 = llvm.getelementptr %11[%20] : (!llvm\u0026lt;\u0026#34;i64*\u0026#34;\u0026gt;, !llvm.i64) -\u0026gt; !llvm\u0026lt;\u0026#34;i64*\u0026#34;\u0026gt; %25 = llvm.load %24 : !llvm\u0026lt;\u0026#34;i64*\u0026#34;\u0026gt; %26 = llvm.insertvalue %25, %23[4, 1] : !llvm\u0026lt;\u0026#34;{ float*, float*, i64, [4 x i64], [4 x i64] }\u0026#34;\u0026gt; %27 = llvm.mlir.constant(2 : i64) : !llvm.i64 %28 = llvm.getelementptr %11[%27] : (!llvm\u0026lt;\u0026#34;i64*\u0026#34;\u0026gt;, !llvm.i64) -\u0026gt; !llvm\u0026lt;\u0026#34;i64*\u0026#34;\u0026gt; %29 = llvm.load %28 : !llvm\u0026lt;\u0026#34;i64*\u0026#34;\u0026gt; %30 = llvm.insertvalue %29, %26[3, 2] : !llvm\u0026lt;\u0026#34;{ float*, float*, i64, [4 x i64], [4 x i64] }\u0026#34;\u0026gt; %31 = llvm.getelementptr %11[%27] : (!llvm\u0026lt;\u0026#34;i64*\u0026#34;\u0026gt;, !llvm.i64) -\u0026gt; !llvm\u0026lt;\u0026#34;i64*\u0026#34;\u0026gt; %32 = llvm.load %31 : !llvm\u0026lt;\u0026#34;i64*\u0026#34;\u0026gt; %33 = llvm.insertvalue %32, %30[4, 2] : !llvm\u0026lt;\u0026#34;{ float*, float*, i64, [4 x i64], [4 x i64] }\u0026#34;\u0026gt; %34 = llvm.mlir.constant(3 : i64) : !llvm.i64 %35 = llvm.getelementptr %11[%34] : (!llvm\u0026lt;\u0026#34;i64*\u0026#34;\u0026gt;, !llvm.i64) -\u0026gt; !llvm\u0026lt;\u0026#34;i64*\u0026#34;\u0026gt; %36 = llvm.load %35 : !llvm\u0026lt;\u0026#34;i64*\u0026#34;\u0026gt; %37 = llvm.insertvalue %36, %33[3, 3] : !llvm\u0026lt;\u0026#34;{ float*, float*, i64, [4 x i64], [4 x i64] }\u0026#34;\u0026gt; %38 = llvm.getelementptr %11[%34] : (!llvm\u0026lt;\u0026#34;i64*\u0026#34;\u0026gt;, !llvm.i64) -\u0026gt; !llvm\u0026lt;\u0026#34;i64*\u0026#34;\u0026gt; %39 = llvm.load %38 : !llvm\u0026lt;\u0026#34;i64*\u0026#34;\u0026gt; %40 = llvm.insertvalue %39, %37[4, 3] : !llvm\u0026lt;\u0026#34;{ float*, float*, i64, [4 x i64], [4 x i64] }\u0026#34;\u0026gt; llvm.store %40, %3 : !llvm\u0026lt;\u0026#34;{ float*, float*, i64, [4 x i64], [4 x i64] }*\u0026#34;\u0026gt; %41 = llvm.call @_mlir_ciface_main_graph(%3) : (!llvm\u0026lt;\u0026#34;{ float*, float*, i64, [4 x i64], [4 x i64] }*\u0026#34;\u0026gt;) -\u0026gt; !llvm\u0026lt;\u0026#34;{ float*, float*, i64, [2 x i64], [2 x i64] }\u0026#34;\u0026gt; %42 = llvm.call @createOrderedRtMemRefDict() : () -\u0026gt; !llvm\u0026lt;\u0026#34;i8*\u0026#34;\u0026gt; %43 = llvm.mlir.constant(2 : i32) : !llvm.i32 %44 = llvm.call @createRtMemRef(%43) : (!llvm.i32) -\u0026gt; !llvm\u0026lt;\u0026#34;i8*\u0026#34;\u0026gt; %45 = llvm.extractvalue %41[0] : !llvm\u0026lt;\u0026#34;{ float*, float*, i64, [2 x i64], [2 x i64] }\u0026#34;\u0026gt; %46 = llvm.bitcast %45 : !llvm\u0026lt;\u0026#34;float*\u0026#34;\u0026gt; to !llvm\u0026lt;\u0026#34;i8*\u0026#34;\u0026gt; %47 = llvm.call @setData(%44, %46) : (!llvm\u0026lt;\u0026#34;i8*\u0026#34;\u0026gt;, !llvm\u0026lt;\u0026#34;i8*\u0026#34;\u0026gt;) -\u0026gt; !llvm.void %48 = llvm.mlir.constant(1 : i32) : !llvm.i32 %49 = llvm.call @setDType(%44, %48) : (!llvm\u0026lt;\u0026#34;i8*\u0026#34;\u0026gt;, !llvm.i32) -\u0026gt; !llvm.void %50 = llvm.call @getSizes(%44) : (!llvm\u0026lt;\u0026#34;i8*\u0026#34;\u0026gt;) -\u0026gt; !llvm\u0026lt;\u0026#34;i64*\u0026#34;\u0026gt; %51 = llvm.call @getStrides(%44) : (!llvm\u0026lt;\u0026#34;i8*\u0026#34;\u0026gt;) -\u0026gt; !llvm\u0026lt;\u0026#34;i64*\u0026#34;\u0026gt; %52 = llvm.mlir.constant(0 : i64) : !llvm.i64 %53 = llvm.extractvalue %41[3, 0] : !llvm\u0026lt;\u0026#34;{ float*, float*, i64, [2 x i64], [2 x i64] }\u0026#34;\u0026gt; %54 = llvm.getelementptr %50[%52] : (!llvm\u0026lt;\u0026#34;i64*\u0026#34;\u0026gt;, !llvm.i64) -\u0026gt; !llvm\u0026lt;\u0026#34;i64*\u0026#34;\u0026gt; llvm.store %53, %54 : !llvm\u0026lt;\u0026#34;i64*\u0026#34;\u0026gt; %55 = llvm.extractvalue %41[4, 0] : !llvm\u0026lt;\u0026#34;{ float*, float*, i64, [2 x i64], [2 x i64] }\u0026#34;\u0026gt; %56 = llvm.getelementptr %51[%52] : (!llvm\u0026lt;\u0026#34;i64*\u0026#34;\u0026gt;, !llvm.i64) -\u0026gt; !llvm\u0026lt;\u0026#34;i64*\u0026#34;\u0026gt; llvm.store %55, %56 : !llvm\u0026lt;\u0026#34;i64*\u0026#34;\u0026gt; %57 = llvm.mlir.constant(1 : i64) : !llvm.i64 %58 = llvm.extractvalue %41[3, 1] : !llvm\u0026lt;\u0026#34;{ float*, float*, i64, [2 x i64], [2 x i64] }\u0026#34;\u0026gt; %59 = llvm.getelementptr %50[%57] : (!llvm\u0026lt;\u0026#34;i64*\u0026#34;\u0026gt;, !llvm.i64) -\u0026gt; !llvm\u0026lt;\u0026#34;i64*\u0026#34;\u0026gt; llvm.store %58, %59 : !llvm\u0026lt;\u0026#34;i64*\u0026#34;\u0026gt; %60 = llvm.extractvalue %41[4, 1] : !llvm\u0026lt;\u0026#34;{ float*, float*, i64, [2 x i64], [2 x i64] }\u0026#34;\u0026gt; %61 = llvm.getelementptr %51[%57] : (!llvm\u0026lt;\u0026#34;i64*\u0026#34;\u0026gt;, !llvm.i64) -\u0026gt; !llvm\u0026lt;\u0026#34;i64*\u0026#34;\u0026gt; llvm.store %60, %61 : !llvm\u0026lt;\u0026#34;i64*\u0026#34;\u0026gt; %62 = llvm.mlir.constant(0 : i32) : !llvm.i32 %63 = llvm.call @setRtMemRef(%42, %62, %44) : (!llvm\u0026lt;\u0026#34;i8*\u0026#34;\u0026gt;, !llvm.i32, !llvm\u0026lt;\u0026#34;i8*\u0026#34;\u0026gt;) -\u0026gt; !llvm.void llvm.return %42 : !llvm\u0026lt;\u0026#34;i8*\u0026#34;\u0026gt; } }   コマンドのヘルプ onnx-mlirコマンドのヘルプ\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23  $ onnx-mlir -h OVERVIEW: ONNX MLIR modular optimizer driver USAGE: onnx-mlir [options] \u0026lt;input file\u0026gt; OPTIONS: Generic Options: --help - Display available options (--help-hidden for more) --help-list - Display list of available options (--help-list-hidden for more) --version - Display the version of this program ONNX MLIR Options: These are frontend options. Choose target to emit: --EmitONNXBasic - Ingest ONNX and emit the basic ONNX operations withoutinferred shapes. --EmitONNXIR - Ingest ONNX and emit corresponding ONNX dialect. --EmitMLIR - Lower model to MLIR built-in transformation dialect. --EmitLLVMIR - Lower model to LLVM IR (LLVM dialect). --EmitLib - Lower model to LLVM IR, emit (to file) LLVM bitcode for model, compile and link it to a shared library. --EmitJNI - Lower model to LLMV IR -\u0026gt; LLVM bitcode -\u0026gt; JNI shared library -\u0026gt; jar   onnx-mlir-optコマンドのヘルプ\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334  $ onnx-mlir-opt -h OVERVIEW: ONNX MLIR modular optimizer driver USAGE: onnx-mlir-opt [options] \u0026lt;input file\u0026gt; OPTIONS: Color Options: --color - Use colors in output (default=autodetect) General options: --allow-unregistered-dialect - Allow operation with no registered dialects --enable-name-compression - Enable name/filename string compression --mlir-disable-threading - Disabling multi-threading within MLIR --mlir-elide-elementsattrs-if-larger=\u0026lt;uint\u0026gt; - Elide ElementsAttrs with \u0026#34;...\u0026#34; that have more elements than the given upper limit --mlir-pretty-debuginfo - Print pretty debug info in MLIR output --mlir-print-debuginfo - Print debug info in MLIR output --mlir-print-elementsattrs-with-hex-if-larger=\u0026lt;long\u0026gt; - Print DenseElementsAttrs with a hex string that have more elements than the given upper limit (use -1 to disable) --mlir-print-op-on-diagnostic - When a diagnostic is emitted on an operation, also print the operation as an attached note --mlir-print-stacktrace-on-diagnostic - When a diagnostic is emitted, also print the stack trace as an attached note -o=\u0026lt;filename\u0026gt; - Output filename Compiler passes to run --pass-pipeline - A textual description of a pass pipeline to run Passes: --affine-data-copy-generate - Generate explicit copying for affine memory operations --fast-mem-capacity=\u0026lt;ulong\u0026gt; - Set fast memory space capacity in KiB (default: unlimited) --fast-mem-space=\u0026lt;uint\u0026gt; - Fast memory space identifier for copy generation (default: 1) --generate-dma - Generate DMA instead of point-wise copy --min-dma-transfer=\u0026lt;int\u0026gt; - Minimum DMA transfer size supported by the target in bytes --skip-non-unit-stride-loops - Testing purposes: avoid non-unit stride loop choice depths for copy placement --slow-mem-space=\u0026lt;uint\u0026gt; - Slow memory space identifier for copy generation (default: 0) --tag-mem-space=\u0026lt;uint\u0026gt; - Tag memory space identifier for copy generation (default: 0) --affine-loop-fusion - Fuse affine loop nests --fusion-compute-tolerance=\u0026lt;number\u0026gt; - Fractional increase in additional computation tolerated while fusing --fusion-fast-mem-space=\u0026lt;uint\u0026gt; - Faster memory space number to promote fusion buffers to --fusion-local-buf-threshold=\u0026lt;ulong\u0026gt; - Threshold size (KiB) for promoting local buffers to fast memory space --fusion-maximal - Enables maximal loop fusion --affine-loop-invariant-code-motion - Hoist loop invariant instructions outside of affine loops --affine-loop-tile - Tile affine loop nests --cache-size=\u0026lt;ulong\u0026gt; - Set size of cache to tile for in KiB --separate - Separate full and partial tiles --tile-size=\u0026lt;uint\u0026gt; - Use this tile size for all loops --tile-sizes=\u0026lt;uint\u0026gt; - List of tile sizes for each perfect nest (overridden by -tile-size) --affine-loop-unroll - Unroll affine loops --unroll-factor=\u0026lt;uint\u0026gt; - Use this unroll factor for all loops being unrolled --unroll-full - Fully unroll loops --unroll-full-threshold=\u0026lt;uint\u0026gt; - Unroll all loops with trip count less than or equal to this --unroll-num-reps=\u0026lt;uint\u0026gt; - Unroll innermost loops repeatedly this many times --affine-loop-unroll-jam - Unroll and jam affine loops --unroll-jam-factor=\u0026lt;uint\u0026gt; - Use this unroll jam factor for all loops (default 4) --affine-pipeline-data-transfer - Pipeline non-blocking data transfers between explicitly managed levels of the memory hierarchy --affine-super-vectorize - Vectorize to a target independent n-D vector abstraction --test-fastest-varying=\u0026lt;long\u0026gt; - Specify a 1-D, 2-D or 3-D pattern of fastest varying memory dimensions to match. See defaultPatterns in Vectorize.cpp for a description and examples. This is used for testing purposes --virtual-vector-size=\u0026lt;long\u0026gt; - Specify an n-D virtual vector size for vectorization --attribute-promotion - Promote constant operands to attributes. --buffer-placement - Optimizes placement of alloc and dealloc operations --bundle-memory-pools - Bundle memory pools of internal MemRefs into a single memory pool. --canonicalize - Canonicalize operations --constprop-onnx - ConstProp ONNX operations into composition of other ONNX operations. --convert-krnl-to-affine - Lower Krnl dialect. --convert-krnl-to-llvm - Lower the Krnl Affine and Std dialects to LLVM. --convert-linalg-on-tensors-to-buffers - Convert the Linalg operations which work on tensor-type operands or results to use buffers instead --convert-linalg-to-affine-loops - Lower the operations from the linalg dialect into affine loops --convert-linalg-to-loops - Lower the operations from the linalg dialect into loops --convert-linalg-to-parallel-loops - Lower the operations from the linalg dialect into parallel loops --convert-onnx-to-krnl - Lower frontend ops to Krnl dialect. --convert-scf-to-std - Lower SCF to Standard Dialect. --convert-vector-to-llvm - Lower Vector Dialect to LLVM IR Dialect. --reassociate-fp-reductions - Allows llvm to reassociate floating-point reductions for speed --convert-vector-to-scf - Convert vector to SCF. --full-unroll - Perform full unrolling when converting vector transfers to SCF --cse - Eliminate common sub-expressions --decompose-onnx - Decompose ONNX operations into composition of other ONNX operations. --elide-constants - Elide values of constant operations. --elide-krnl-constants - Elide the constant values of the Global Krnl operations. --enable-memory-pool - Enable a memory pool for allocating internal MemRefs. --for-loop-specialization - Specialize `for` loops for vectorization --inline - Inline function calls --disable-simplify - Disable running simplifications during inlining --max-iterations=\u0026lt;uint\u0026gt; - Maximum number of iterations when inlining within an SCC --linalg-fold-unit-extent-dims - Remove unit-extent dimension in Linalg ops on tensors --fold-one-trip-loops-only - Only folds the one-trip loops from Linalg ops on tensors (for testing purposes only) --linalg-fusion - Fuse operations in the linalg dialect --linalg-fusion-for-tensor-ops - Fuse operations on RankedTensorType in linalg dialect --linalg-promote-subviews - Promote subview ops to local buffers --test-promote-dynamic - Test generation of dynamic promoted buffers --linalg-tile - Tile operations in the linalg dialect --linalg-tile-sizes=\u0026lt;long\u0026gt; - Test generation of dynamic promoted buffers --linalg-tile-to-parallel-loops - Tile operations in the linalg dialect to parallel loops --linalg-tile-sizes=\u0026lt;long\u0026gt; - Test generation of dynamic promoted buffers --loop-coalescing - Coalesce nested loops with independent bounds into a single loop --loop-invariant-code-motion - Hoist loop invariant instructions outside of the loop --lower-affine - Lower Affine Dialect to Standard Dialect. --memref-dataflow-opt - Perform store/load forwarding for memrefs --pack-krnl-constants - Elide the constant values of the Global Krnl operations. --elision-threshold=\u0026lt;long\u0026gt; - A threshold value specifying the maximum number of elements a constant operation can hold as an attribute. If the number exceeds this threshold, constants will be packed together and, in the case where `move-to-file` option is enabled, stored as a binary file on disk. This can help preserve readability of IR dump and improve compilation speed. --filename=\u0026lt;string\u0026gt; - Specify a file in which the packed constant is to be stored. --move-to-file - Whether to move the packed constant to a file. --parallel-loop-collapsing - Collapse parallel loops to use less induction variables --collapsed-indices-0=\u0026lt;uint\u0026gt; - Which loop indices to combine 0th loop index --collapsed-indices-1=\u0026lt;uint\u0026gt; - Which loop indices to combine into the position 1 loop index --collapsed-indices-2=\u0026lt;uint\u0026gt; - Which loop indices to combine into the position 2 loop index --parallel-loop-fusion - Fuse adjacent parallel loops --parallel-loop-specialization - Specialize parallel loops for vectorization --parallel-loop-tiling - Tile parallel loops --parallel-loop-tile-sizes=\u0026lt;long\u0026gt; - Factors to tile parallel loops by --print-cfg-graph - Print CFG graph per-Region --print-op-graph - Print op graph per-Region --print-op-stats - Print statistics of operations --sccp - Sparse Conditional Constant Propagation --shape-inference - Shape inference for frontend dialects. --simplify-affine-structures - Simplify affine expressions in maps/sets and normalize memrefs --snapshot-op-locations - Generate new locations from the current IR --filename=\u0026lt;string\u0026gt; - The filename to print the generated IR --tag=\u0026lt;string\u0026gt; - A tag to use when fusing the new locations with the original. If unset, the locations are replaced. --strip-debuginfo - Strip debug info from all operations --symbol-dce - Eliminate dead symbols --pass-pipeline-crash-reproducer=\u0026lt;string\u0026gt; - Generate a .mlir reproducer file at the given output path if the pass manager crashes or fails --pass-pipeline-local-reproducer - When generating a crash reproducer, attempt to generated a reproducer with the smallest pipeline. --pass-statistics - Display the statistics of each pass --pass-statistics-display=\u0026lt;value\u0026gt; - Display method for pass statistics =list - display the results in a merged list sorted by pass name =pipeline - display the results with a nested pipeline view --pass-timing - Display the execution times of each pass --pass-timing-display=\u0026lt;value\u0026gt; - Display method for pass timing data =list - display the results in a list sorted by total time =pipeline - display the results with a nested pipeline view --print-ir-after - Print IR after specified passes --pass-pipeline - A textual description of a pass pipeline to run Passes: --affine-data-copy-generate - Generate explicit copying for affine memory operations --fast-mem-capacity=\u0026lt;ulong\u0026gt; - Set fast memory space capacity in KiB (default: unlimited) --fast-mem-space=\u0026lt;uint\u0026gt; - Fast memory space identifier for copy generation (default: 1) --generate-dma - Generate DMA instead of point-wise copy --min-dma-transfer=\u0026lt;int\u0026gt; - Minimum DMA transfer size supported by the target in bytes --skip-non-unit-stride-loops - Testing purposes: avoid non-unit stride loop choice depths for copy placement --slow-mem-space=\u0026lt;uint\u0026gt; - Slow memory space identifier for copy generation (default: 0) --tag-mem-space=\u0026lt;uint\u0026gt; - Tag memory space identifier for copy generation (default: 0) --affine-loop-fusion - Fuse affine loop nests --fusion-compute-tolerance=\u0026lt;number\u0026gt; - Fractional increase in additional computation tolerated while fusing --fusion-fast-mem-space=\u0026lt;uint\u0026gt; - Faster memory space number to promote fusion buffers to --fusion-local-buf-threshold=\u0026lt;ulong\u0026gt; - Threshold size (KiB) for promoting local buffers to fast memory space --fusion-maximal - Enables maximal loop fusion --affine-loop-invariant-code-motion - Hoist loop invariant instructions outside of affine loops --affine-loop-tile - Tile affine loop nests --cache-size=\u0026lt;ulong\u0026gt; - Set size of cache to tile for in KiB --separate - Separate full and partial tiles --tile-size=\u0026lt;uint\u0026gt; - Use this tile size for all loops --tile-sizes=\u0026lt;uint\u0026gt; - List of tile sizes for each perfect nest (overridden by -tile-size) --affine-loop-unroll - Unroll affine loops --unroll-factor=\u0026lt;uint\u0026gt; - Use this unroll factor for all loops being unrolled --unroll-full - Fully unroll loops --unroll-full-threshold=\u0026lt;uint\u0026gt; - Unroll all loops with trip count less than or equal to this --unroll-num-reps=\u0026lt;uint\u0026gt; - Unroll innermost loops repeatedly this many times --affine-loop-unroll-jam - Unroll and jam affine loops --unroll-jam-factor=\u0026lt;uint\u0026gt; - Use this unroll jam factor for all loops (default 4) --affine-pipeline-data-transfer - Pipeline non-blocking data transfers between explicitly managed levels of the memory hierarchy --affine-super-vectorize - Vectorize to a target independent n-D vector abstraction --test-fastest-varying=\u0026lt;long\u0026gt; - Specify a 1-D, 2-D or 3-D pattern of fastest varying memory dimensions to match. See defaultPatterns in Vectorize.cpp for a description and examples. This is used for testing purposes --virtual-vector-size=\u0026lt;long\u0026gt; - Specify an n-D virtual vector size for vectorization --attribute-promotion - Promote constant operands to attributes. --buffer-placement - Optimizes placement of alloc and dealloc operations --bundle-memory-pools - Bundle memory pools of internal MemRefs into a single memory pool. --canonicalize - Canonicalize operations --constprop-onnx - ConstProp ONNX operations into composition of other ONNX operations. --convert-krnl-to-affine - Lower Krnl dialect. --convert-krnl-to-llvm - Lower the Krnl Affine and Std dialects to LLVM. --convert-linalg-on-tensors-to-buffers - Convert the Linalg operations which work on tensor-type operands or results to use buffers instead --convert-linalg-to-affine-loops - Lower the operations from the linalg dialect into affine loops --convert-linalg-to-loops - Lower the operations from the linalg dialect into loops --convert-linalg-to-parallel-loops - Lower the operations from the linalg dialect into parallel loops --convert-onnx-to-krnl - Lower frontend ops to Krnl dialect. --convert-scf-to-std - Lower SCF to Standard Dialect. --convert-vector-to-llvm - Lower Vector Dialect to LLVM IR Dialect. --reassociate-fp-reductions - Allows llvm to reassociate floating-point reductions for speed --convert-vector-to-scf - Convert vector to SCF. --full-unroll - Perform full unrolling when converting vector transfers to SCF --cse - Eliminate common sub-expressions --decompose-onnx - Decompose ONNX operations into composition of other ONNX operations. --elide-constants - Elide values of constant operations. --elide-krnl-constants - Elide the constant values of the Global Krnl operations. --enable-memory-pool - Enable a memory pool for allocating internal MemRefs. --for-loop-specialization - Specialize `for` loops for vectorization --inline - Inline function calls --disable-simplify - Disable running simplifications during inlining --max-iterations=\u0026lt;uint\u0026gt; - Maximum number of iterations when inlining within an SCC --linalg-fold-unit-extent-dims - Remove unit-extent dimension in Linalg ops on tensors --fold-one-trip-loops-only - Only folds the one-trip loops from Linalg ops on tensors (for testing purposes only) --linalg-fusion - Fuse operations in the linalg dialect --linalg-fusion-for-tensor-ops - Fuse operations on RankedTensorType in linalg dialect --linalg-promote-subviews - Promote subview ops to local buffers --test-promote-dynamic - Test generation of dynamic promoted buffers --linalg-tile - Tile operations in the linalg dialect --linalg-tile-sizes=\u0026lt;long\u0026gt; - Test generation of dynamic promoted buffers --linalg-tile-to-parallel-loops - Tile operations in the linalg dialect to parallel loops --linalg-tile-sizes=\u0026lt;long\u0026gt; - Test generation of dynamic promoted buffers --loop-coalescing - Coalesce nested loops with independent bounds into a single loop --loop-invariant-code-motion - Hoist loop invariant instructions outside of the loop --lower-affine - Lower Affine Dialect to Standard Dialect. --memref-dataflow-opt - Perform store/load forwarding for memrefs --pack-krnl-constants - Elide the constant values of the Global Krnl operations. --elision-threshold=\u0026lt;long\u0026gt; - A threshold value specifying the maximum number of elements a constant operation can hold as an attribute. If the number exceeds this threshold, constants will be packed together and, in the case where `move-to-file` option is enabled, stored as a binary file on disk. This can help preserve readability of IR dump and improve compilation speed. --filename=\u0026lt;string\u0026gt; - Specify a file in which the packed constant is to be stored. --move-to-file - Whether to move the packed constant to a file. --parallel-loop-collapsing - Collapse parallel loops to use less induction variables --collapsed-indices-0=\u0026lt;uint\u0026gt; - Which loop indices to combine 0th loop index --collapsed-indices-1=\u0026lt;uint\u0026gt; - Which loop indices to combine into the position 1 loop index --collapsed-indices-2=\u0026lt;uint\u0026gt; - Which loop indices to combine into the position 2 loop index --parallel-loop-fusion - Fuse adjacent parallel loops --parallel-loop-specialization - Specialize parallel loops for vectorization --parallel-loop-tiling - Tile parallel loops --parallel-loop-tile-sizes=\u0026lt;long\u0026gt; - Factors to tile parallel loops by --print-cfg-graph - Print CFG graph per-Region --print-op-graph - Print op graph per-Region --print-op-stats - Print statistics of operations --sccp - Sparse Conditional Constant Propagation --shape-inference - Shape inference for frontend dialects. --simplify-affine-structures - Simplify affine expressions in maps/sets and normalize memrefs --snapshot-op-locations - Generate new locations from the current IR --filename=\u0026lt;string\u0026gt; - The filename to print the generated IR --tag=\u0026lt;string\u0026gt; - A tag to use when fusing the new locations with the original. If unset, the locations are replaced. --strip-debuginfo - Strip debug info from all operations --symbol-dce - Eliminate dead symbols --print-ir-after-all - Print IR after each pass --print-ir-after-change - When printing the IR after a pass, only print if the IR changed --print-ir-before - Print IR before specified passes --pass-pipeline - A textual description of a pass pipeline to run Passes: --affine-data-copy-generate - Generate explicit copying for affine memory operations --fast-mem-capacity=\u0026lt;ulong\u0026gt; - Set fast memory space capacity in KiB (default: unlimited) --fast-mem-space=\u0026lt;uint\u0026gt; - Fast memory space identifier for copy generation (default: 1) --generate-dma - Generate DMA instead of point-wise copy --min-dma-transfer=\u0026lt;int\u0026gt; - Minimum DMA transfer size supported by the target in bytes --skip-non-unit-stride-loops - Testing purposes: avoid non-unit stride loop choice depths for copy placement --slow-mem-space=\u0026lt;uint\u0026gt; - Slow memory space identifier for copy generation (default: 0) --tag-mem-space=\u0026lt;uint\u0026gt; - Tag memory space identifier for copy generation (default: 0) --affine-loop-fusion - Fuse affine loop nests --fusion-compute-tolerance=\u0026lt;number\u0026gt; - Fractional increase in additional computation tolerated while fusing --fusion-fast-mem-space=\u0026lt;uint\u0026gt; - Faster memory space number to promote fusion buffers to --fusion-local-buf-threshold=\u0026lt;ulong\u0026gt; - Threshold size (KiB) for promoting local buffers to fast memory space --fusion-maximal - Enables maximal loop fusion --affine-loop-invariant-code-motion - Hoist loop invariant instructions outside of affine loops --affine-loop-tile - Tile affine loop nests --cache-size=\u0026lt;ulong\u0026gt; - Set size of cache to tile for in KiB --separate - Separate full and partial tiles --tile-size=\u0026lt;uint\u0026gt; - Use this tile size for all loops --tile-sizes=\u0026lt;uint\u0026gt; - List of tile sizes for each perfect nest (overridden by -tile-size) --affine-loop-unroll - Unroll affine loops --unroll-factor=\u0026lt;uint\u0026gt; - Use this unroll factor for all loops being unrolled --unroll-full - Fully unroll loops --unroll-full-threshold=\u0026lt;uint\u0026gt; - Unroll all loops with trip count less than or equal to this --unroll-num-reps=\u0026lt;uint\u0026gt; - Unroll innermost loops repeatedly this many times --affine-loop-unroll-jam - Unroll and jam affine loops --unroll-jam-factor=\u0026lt;uint\u0026gt; - Use this unroll jam factor for all loops (default 4) --affine-pipeline-data-transfer - Pipeline non-blocking data transfers between explicitly managed levels of the memory hierarchy --affine-super-vectorize - Vectorize to a target independent n-D vector abstraction --test-fastest-varying=\u0026lt;long\u0026gt; - Specify a 1-D, 2-D or 3-D pattern of fastest varying memory dimensions to match. See defaultPatterns in Vectorize.cpp for a description and examples. This is used for testing purposes --virtual-vector-size=\u0026lt;long\u0026gt; - Specify an n-D virtual vector size for vectorization --attribute-promotion - Promote constant operands to attributes. --buffer-placement - Optimizes placement of alloc and dealloc operations --bundle-memory-pools - Bundle memory pools of internal MemRefs into a single memory pool. --canonicalize - Canonicalize operations --constprop-onnx - ConstProp ONNX operations into composition of other ONNX operations. --convert-krnl-to-affine - Lower Krnl dialect. --convert-krnl-to-llvm - Lower the Krnl Affine and Std dialects to LLVM. --convert-linalg-on-tensors-to-buffers - Convert the Linalg operations which work on tensor-type operands or results to use buffers instead --convert-linalg-to-affine-loops - Lower the operations from the linalg dialect into affine loops --convert-linalg-to-loops - Lower the operations from the linalg dialect into loops --convert-linalg-to-parallel-loops - Lower the operations from the linalg dialect into parallel loops --convert-onnx-to-krnl - Lower frontend ops to Krnl dialect. --convert-scf-to-std - Lower SCF to Standard Dialect. --convert-vector-to-llvm - Lower Vector Dialect to LLVM IR Dialect. --reassociate-fp-reductions - Allows llvm to reassociate floating-point reductions for speed --convert-vector-to-scf - Convert vector to SCF. --full-unroll - Perform full unrolling when converting vector transfers to SCF --cse - Eliminate common sub-expressions --decompose-onnx - Decompose ONNX operations into composition of other ONNX operations. --elide-constants - Elide values of constant operations. --elide-krnl-constants - Elide the constant values of the Global Krnl operations. --enable-memory-pool - Enable a memory pool for allocating internal MemRefs. --for-loop-specialization - Specialize `for` loops for vectorization --inline - Inline function calls --disable-simplify - Disable running simplifications during inlining --max-iterations=\u0026lt;uint\u0026gt; - Maximum number of iterations when inlining within an SCC --linalg-fold-unit-extent-dims - Remove unit-extent dimension in Linalg ops on tensors --fold-one-trip-loops-only - Only folds the one-trip loops from Linalg ops on tensors (for testing purposes only) --linalg-fusion - Fuse operations in the linalg dialect --linalg-fusion-for-tensor-ops - Fuse operations on RankedTensorType in linalg dialect --linalg-promote-subviews - Promote subview ops to local buffers --test-promote-dynamic - Test generation of dynamic promoted buffers --linalg-tile - Tile operations in the linalg dialect --linalg-tile-sizes=\u0026lt;long\u0026gt; - Test generation of dynamic promoted buffers --linalg-tile-to-parallel-loops - Tile operations in the linalg dialect to parallel loops --linalg-tile-sizes=\u0026lt;long\u0026gt; - Test generation of dynamic promoted buffers --loop-coalescing - Coalesce nested loops with independent bounds into a single loop --loop-invariant-code-motion - Hoist loop invariant instructions outside of the loop --lower-affine - Lower Affine Dialect to Standard Dialect. --memref-dataflow-opt - Perform store/load forwarding for memrefs --pack-krnl-constants - Elide the constant values of the Global Krnl operations. --elision-threshold=\u0026lt;long\u0026gt; - A threshold value specifying the maximum number of elements a constant operation can hold as an attribute. If the number exceeds this threshold, constants will be packed together and, in the case where `move-to-file` option is enabled, stored as a binary file on disk. This can help preserve readability of IR dump and improve compilation speed. --filename=\u0026lt;string\u0026gt; - Specify a file in which the packed constant is to be stored. --move-to-file - Whether to move the packed constant to a file. --parallel-loop-collapsing - Collapse parallel loops to use less induction variables --collapsed-indices-0=\u0026lt;uint\u0026gt; - Which loop indices to combine 0th loop index --collapsed-indices-1=\u0026lt;uint\u0026gt; - Which loop indices to combine into the position 1 loop index --collapsed-indices-2=\u0026lt;uint\u0026gt; - Which loop indices to combine into the position 2 loop index --parallel-loop-fusion - Fuse adjacent parallel loops --parallel-loop-specialization - Specialize parallel loops for vectorization --parallel-loop-tiling - Tile parallel loops --parallel-loop-tile-sizes=\u0026lt;long\u0026gt; - Factors to tile parallel loops by --print-cfg-graph - Print CFG graph per-Region --print-op-graph - Print op graph per-Region --print-op-stats - Print statistics of operations --sccp - Sparse Conditional Constant Propagation --shape-inference - Shape inference for frontend dialects. --simplify-affine-structures - Simplify affine expressions in maps/sets and normalize memrefs --snapshot-op-locations - Generate new locations from the current IR --filename=\u0026lt;string\u0026gt; - The filename to print the generated IR --tag=\u0026lt;string\u0026gt; - A tag to use when fusing the new locations with the original. If unset, the locations are replaced. --strip-debuginfo - Strip debug info from all operations --symbol-dce - Eliminate dead symbols --print-ir-before-all - Print IR before each pass --print-ir-module-scope - When printing IR for print-ir-[before|after]{-all} always print the top-level module operation --split-input-file - Split the input file into pieces and process each chunk independently --verify-diagnostics - Check that emitted diagnostics match expected-* lines on the corresponding line --verify-each - Run the verifier after each transformation pass Generic Options: --help - Display available options (--help-hidden for more) --help-list - Display list of available options (--help-list-hidden for more) --version - Display the version of this program   ",date:"2020-08-03 Mon",permalink:"https://mshr-h.com/posts/convert-onnx-with-onnx-mlir/",title:"ONNX MLIRでONNXモデルを変換する"},{body:"ONNX MLIRをビルドする手順。基本はGitHubのREADMEに記載の手順と同じ。\n検証環境は\n Ryzen 5 1600 Ubuntu 20.04 on WSL2 ONNX MLIR commit id ac67900  ビルドツール導入 ビルドに必要なツール群を導入する。 Ubuntu 18.04の場合、libprotoc-devが古くてビルドできないため、別途手動で導入する必要がある。\n1 2  sudo apt install protobuf-compiler build-essential cmake libprotoc-dev \\  ninja-build libncurses python3 python3-dev python-is-python3   MLIRのビルド カレントディレクトリは~/workspaceとする。\nLLVM内にあるMLIRを取得し、ONNX MLIRのビルドが確認できているブランチをチェックアウトする。\n1 2 3  cd ~/workspace git clone https://github.com/llvm/llvm-project.git cd llvm-project \u0026amp;\u0026amp; git checkout 1d01fc100bb5bef5f5eaf92520b2e52f64ee1d6e \u0026amp;\u0026amp; cd ..   ビルドする。Ryzen 5 1600で20分程度。\n1 2 3 4 5 6 7 8 9 10 11 12  mkdir llvm-project/build cd llvm-project/build cmake -G Ninja ../llvm \\  -DLLVM_ENABLE_PROJECTS=mlir \\  -DLLVM_BUILD_EXAMPLES=ON \\  -DLLVM_TARGETS_TO_BUILD=\u0026#34;host\u0026#34; \\  -DCMAKE_BUILD_TYPE=Release \\  -DLLVM_ENABLE_ASSERTIONS=ON \\  -DLLVM_ENABLE_RTTI=ON cmake --build . cmake --build . --target check-mlir   ONNX MLIRのビルド onnx-mlirのソースコードを取得する。\n1 2  cd ~/workspace git clone --recursive https://github.com/onnx/onnx-mlir.git   ビルドする。Ryzen 5 1600で5分程度。\n1 2 3 4 5 6 7 8 9  export LLVM_PROJ_SRC=$(pwd)/llvm-project/ export LLVM_PROJ_BUILD=$(pwd)/llvm-project/build mkdir onnx-mlir/build \u0026amp;\u0026amp; cd onnx-mlir/build cmake -G Ninja .. cmake --build . export LIT_OPTS=-v cmake --build . --target check-onnx-lit   ",date:"2020-07-27 Mon",permalink:"https://mshr-h.com/posts/building-onnx-mlir/",title:"ONNX MLIRをビルドする"},{body:"Windows/LinuxでプロセスIDをC/Pythonから取得する方法。\nWindows/C GetCurrentProcessId()を使う。\n1 2 3 4 5 6 7  #include \u0026lt;stdio.h\u0026gt;#include \u0026lt;windows.h\u0026gt; int main(void) { printf(\u0026#34;Process ID = %d\\n\u0026#34;, GetCurrentProcessId()); return 0; }   Linux/C getpid()を使う。\n1 2 3 4 5 6 7 8  #include \u0026lt;stdio.h\u0026gt;#include \u0026lt;sys/types.h\u0026gt;#include \u0026lt;unistd.h\u0026gt; int main(void) { printf(\u0026#34;Process ID = %d\\n\u0026#34;, getpid()); return 0; }   Python os.getpid()を使う。\n1 2 3  import os print(\u0026#34;Process ID = \u0026#34;, os.getpid())   ",date:"2020-07-08 Wed",permalink:"https://mshr-h.com/posts/get-pid-in-windows-linux-from-c-python/",title:"Windows/LinuxでプロセスIDをC/Pythonから取得する"},{body:"Python 3にはSQLiteを扱うためのモジュールが付属している。 サンプルコードを書いたのでメモ。\nstep-by-stepで説明 1 2  dbname = \u0026#34;test.db\u0026#34; conn = sqlite3.connect(dbname)   データベースへ接続する。\n1  cur = conn.cursor()   データベースを操作するカーソルオブジェクトを取得。\n1 2  cur.execute(\u0026#39;DROP TABLE IF EXISTS sample\u0026#39;) cur.execute(\u0026#39;CREATE TABLE IF NOT EXISTS sample (sensor1 real, sensor2 real, sensor3 real)\u0026#39;)   カーソルオブジェクトに対して.execute()メソッドでSQL文を実行する。 テーブルsampleが存在していれば、削除する。 新たなテーブルsampleを作成する。\n1 2 3 4 5  for i in range(24*60*60): sensor1 = np.random.normal() sensor2 = np.random.normal() sensor3 = np.random.normal() cur.execute(\u0026#39;INSERT INTO sample VALUES(?, ?, ?)\u0026#39;, (sensor1, sensor2, sensor3))   NumPyで3つのランダムな実数を生成し、テーブルへレコードをINSERTする。\n1  conn.commit()   データベースへコミットし、変更を反映させる。\n1 2 3  cur.execute(\u0026#39;SELECT * FROM sample\u0026#39;) for i in range(5): print(cur.fetchone())   テーブルsampleからレコードを取得し、5件表示する。\n1  conn.close()   接続を閉じる。\n全体ソースコード 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26  import numpy as np import sqlite3 np.random.seed(seed=0) dbname = \u0026#34;test.db\u0026#34; conn = sqlite3.connect(dbname) cur = conn.cursor() cur.execute(\u0026#39;DROP TABLE IF EXISTS sample\u0026#39;) cur.execute(\u0026#39;CREATE TABLE IF NOT EXISTS sample (sensor1 real, sensor2 real, sensor3 real)\u0026#39;) for i in range(24*60*60): sensor1 = np.random.normal() sensor2 = np.random.normal() sensor3 = np.random.normal() cur.execute(\u0026#39;INSERT INTO sample VALUES(?, ?, ?)\u0026#39;, (sensor1, sensor2, sensor3)) conn.commit() cur.execute(\u0026#39;SELECT * FROM sample\u0026#39;) for i in range(5): print(cur.fetchone()) conn.close()   ",date:"2020-05-28 Thu",permalink:"https://mshr-h.com/posts/sqlite-from-python3/",title:"Python3からSQLiteを使う"},{body:"TFRT(TensorFlow Runtime)は、TensorFlowの新しい実行ランタイムでパフォーマンスが良いらしい。 Linux(WSL)上でビルドしたので、メモ。\n実施環境  Ryzen 5 1600 32GB RAM Ubuntu 18.04 on WSL1  必要なツール導入 Clang 9以上とlibstdc++ 8以上、Bazel 2.0.0〜3.1.0が必要なので、導入する。\n1 2 3 4 5 6 7 8 9  $ sudo apt update $ sudo apt install clang-9 $ sudo update-alternatives --install /usr/bin/clang clang /usr/bin/clang-9 9 $ sudo update-alternatives --install /usr/bin/clang++ clang++ /usr/bin/clang++-9 9 $ sudo add-apt-repository -y ppa:ubuntu-toolchain-r/test $ sudo apt-get update $ sudo apt-get install -y gcc-8 g++-8 $ wget https://github.com/bazelbuild/bazel/releases/download/3.1.0/bazel-3.1.0-linux-x86_64 $ mv ./bazel-3.1.0-linux-x86_64 ~/bin/bazel # PATHが通っているディレクトリ   ちゃんと導入できたか確認。\n1 2 3 4  $ clang++ -v |\u0026amp; grep \u0026#34;Selected GCC\u0026#34; Selected GCC installation: /usr/bin/../lib/gcc/x86_64-linux-gnu/8 $ bazel --version bazel 3.1.0   ビルド実施 ソースコードを取得し、ビルド開始。\n1 2 3 4 5  $ cd ~/workspace $ git clone https://github.com/tensorflow/runtime $ cd runtime $ bazel build -c opt //tools:bef_executor $ bazel build -c opt //tools:tfrt_translate   bef_executorのビルドに33分、tfrt_translateのビルドに2.5分ぐらいかかった。TensorFlow本体のビルドは1.5時間程度かかったので、それを比べるとかなり短い。\nテスト実行 用意されているテストをいくつか実行してみる。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27  $ bazel-bin/tools/tfrt_translate -mlir-to-bef mlir_tests/bef_executor/async.mlir | bazel-bin/tools/bef_executor Choosing memory leak check allocator. Choosing single-threaded work queue. --- Not running \u0026#39;\u0026#39; because it has arguments. --- Running \u0026#39;async_add\u0026#39;: int32 = 42 int32 = 42 int32 = 43 --- Running \u0026#39;async_repeat2\u0026#39;: int32 = -1 hello host executor! int32 = 0 hello host executor! int32 = 0 --- Not running \u0026#39;call_async_add.i32\u0026#39; because it has arguments. --- Running \u0026#39;async_add.i32_caller\u0026#39;: int32 = 42 int32 = 42 int32 = 44 --- Running \u0026#39;test_async_print_result\u0026#39;: \u0026#39;test_async_print_result\u0026#39; returned 43 --- Running \u0026#39;test_async_copy\u0026#39;: \u0026#39;test_async_copy\u0026#39; returned 42 --- Running \u0026#39;test_async_copy.with_delay\u0026#39;: \u0026#39;test_async_copy.with_delay\u0026#39; returned 42 --- Running \u0026#39;test_async_copy_2\u0026#39;: \u0026#39;test_async_copy_2\u0026#39; returned 43   1 2 3 4 5 6 7 8 9 10 11 12  $ bazel test //integrationtest/mnist:mnist.mlir.test INFO: Analyzed target //integrationtest/mnist:mnist.mlir.test (6 packages loaded, 215 targets configured). INFO: Found 1 test target... Target //integrationtest/mnist:mnist.mlir.test up-to-date: bazel-bin/integrationtest/mnist/mnist.mlir.test INFO: Elapsed time: 209.614s, Critical Path: 21.09s INFO: 8 processes: 8 processwrapper-sandbox. INFO: Build completed successfully, 15 total actions //integrationtest/mnist:mnist.mlir.test PASSED in 10.8s Executed 1 out of 1 test: 1 test passes. There were tests whose specified size is too big. Use the --test_verbose_timeout_warnings command line option INFO: Build completed successfully, 15 total actions   1 2 3 4 5 6 7 8 9 10 11 12  $ bazel test //integrationtest/mnist:mnist_training.mlir.test INFO: Analyzed target //integrationtest/mnist:mnist_training.mlir.test (0 packages loaded, 2 targets configured). INFO: Found 1 test target... Target //integrationtest/mnist:mnist_training.mlir.test up-to-date: bazel-bin/integrationtest/mnist/mnist_training.mlir.test INFO: Elapsed time: 2.932s, Critical Path: 0.88s INFO: 2 processes: 2 processwrapper-sandbox. INFO: Build completed successfully, 5 total actions //integrationtest/mnist:mnist_training.mlir.test PASSED in 0.5s Executed 1 out of 1 test: 1 test passes. There were tests whose specified size is too big. Use the --test_verbose_timeout_warnings command line option INFO: Build completed successfully, 5 total actions   テストが通っており、正しくビルドできたみたい。\n",date:"2020-05-13 Wed",permalink:"https://mshr-h.com/posts/building-tensorflow-runtime/",title:"TFRT(TensorFlow Runtime)をUbuntu 18.04 on WSLでビルドした"},{body:"履歴書PDFのビルド作業をGitHub Actionsで定義した。 リポジトリ自体はyaml_cvをクローンし、プライベートリポジトリとして作成した。 以下の内容を.github/workflows/create_pdf.yamlとして保存し、リポジトリにプッシュするだけ。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21  name:Create PDFon:pushjobs:lint:name:Create PDFruns-on:ubuntu-lateststeps:- uses:actions/checkout@v2with:fetch-depth:1- uses:actions/setup-ruby@v1with:node-version:\u0026#34;2.7\u0026#34;- run:|gem install prawn ruby make_cv.rb -i data.yaml -s style.txt -o output.pdf- uses:actions/upload-artifact@v1with:name:create-pdfpath:./output.pdf  ビルドに成功すると以下のようにActionsタブにビルド結果が表示される。create-pdfをクリックするとPDFがダウンロードできる。\n  ",date:"2020-05-06 Wed",permalink:"https://mshr-h.com/posts/resume-pdf-github-actions/",title:"yaml_cvによる履歴書PDFのビルドをGitHub Actionsでやる"},{body:"DNSレコードとは、DNSを動作させるための設定情報のこと。DNSサーバは、ドメイン名とIPアドレスの対応表である「ゾーンファイル」を保持しており、このファイルに記載されている1行ごとの詳細情報をDNSレコードと呼ぶ。 このゾーンファイル設定では、「レコードタイプ」と呼ぶ情報の種類に応じてDNSレコードを記述する。レコードタイプのうち、Vercelで購入したドメインに対してnow dns ls実行時に表示されるものを次に示す。\n A(Address)レコード  ホスト名に対応するIPアドレスを定義する 例えば、独自ドメインでGitHub Pagesを公開する際に使用する   CNAMEレコード  ドメインやホスト名の別の名義を定義する 例えば、www付きドメインからwww無しドメインに転送する際に使用する   TXTレコード  ホスト名に関連付けるテキスト情報を定義する 例えば、Google Search Consoleにドメインプロパティとしてドメインを登録する際に使用する   MXレコード  メールの転送先(メールサーバ)のホスト名を定義する   CAA(Certification Authority Authorization)レコード  SSL/TLSサーバ証明書を発行できる認証局(CA)を指定する    ",date:"2020-05-02 Sat",permalink:"https://mshr-h.com/posts/dns-record/",title:"DNSレコードの種類"},{body:"HugoとGithub Pagesで個人ブログを作ったので作業メモ。 macOS Catalina 10.15.4で作業した。\n手順  GitHub repositoryを作成 Hugoでサイト作成 GitHub Pagesで公開 独自ドメイン設定 記事を追加  GitHub repositoryを作成 GitHubで新しくリポジトリ(例えばblogという名前)を作成する。このリポジトリにはHugoのプロジェクトを配置する。プライベートリポジトリでも可。 次に、username.github.ioリポジトリを作成する。ここにはHugoで生成したサイトのファイルを配置するため、パブリックリポジトリとして作成する必要がある。\n mshr-h/mshr-h.github.io  1 2 3 4 5  $ hugo new site blog $ cd blog $ git submodule add https://github.com/zhaohuabing/hugo-theme-cleanwhite themes/hugo-theme-cleanwhite $ cp -r themes/beautifulhugo/exampleSite/* . $ hugo server -D   Hugoでサイト作成 Hugoをインストールする。\n1  $ brew isntall hugo   作業ディレクトリに移動し、hugoコマンドで新規プロジェクトを作成する。\n1 2 3  $ cd ~/workspace $ hugo new site blog $ cd blog   テーマをインストールする。今回はClean Whiteを選んだ。テーマはsubmoduleとして追加する。\n1 2  $ git init $ git submodule add https://github.com/zhaohuabing/hugo-theme-cleanwhite.git themes/hugo-theme-cleanwhite   テーマが用意してくれているサンプルページをベースに構築する。サンプルページをコピーする。\n1 2  $ cd ~/workspace/blog $ cp -r themes/hugo-theme-cleanwhite/exampleSite/* .   設定ファルを編集する。\n1  $ vim config.toml   baseurlは独自ドメインを使わない場合username.github.io、使う場合はそのドメインを指定する。titleはブログのタイトルを、themeはテーマ名(hugo-theme-cleanwhite)を指定する。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68  baseurl = \u0026#34;https://keepcodingkeepclimbing.com/\u0026#34; title = \u0026#34;Keep Coding, Keep Climbing\u0026#34; theme = \u0026#34;hugo-theme-cleanwhite\u0026#34; languageCode = \u0026#34;ja-jp\u0026#34; googleAnalytics = \u0026#34;\u0026#34; paginate = 8 #frontpage pagination hasCJKLanguage = true [outputs] home = [\u0026#34;HTML\u0026#34;, \u0026#34;RSS\u0026#34;, \u0026#34;Algolia\u0026#34;] [params] header_image = \u0026#34;img/home-bg-jeep.jpg\u0026#34; SEOTitle = \u0026#34;Keep Coding, Keep Climbing\u0026#34; description = \u0026#34;programming and rock climbing\u0026#34; keyword = \u0026#34;programming, software, machine learning, climbing, bouldering, blog\u0026#34; slogan = \u0026#34;programming and rock climbing\u0026#34; image_404 = \u0026#34;img/404-bg.jpg\u0026#34; title_404 = \u0026#34;404 Not Found\u0026#34; omit_categories = false # algolia site search algolia_search = true algolia_appId = \u0026#34;\u0026#34; algolia_indexName = \u0026#34;\u0026#34; algolia_apiKey = \u0026#34;\u0026#34; # Sidebar settings sidebar_about_description = \u0026#34;Edge deep learning research engineer, open source enthusiast and rock climber\u0026#34; sidebar_avatar = \u0026#34;img/avatar.jpg\u0026#34; # use absolute URL, seeing it\u0026#39;s used in both `/` and `/about/` featured_tags = true featured_condition_size = 1 about_me = true custom_css = [\u0026#34;css/custom-font.css\u0026#34;] [params.social] rss = true twitter = \u0026#34;https://twitter.com/mshrh3\u0026#34; linkedin = \u0026#34;https://www.linkedin.com/in/masahiro-hiramori-63b992167/\u0026#34; github = \u0026#34;https://github.com/mshr-h\u0026#34; googlescholar = \u0026#34;https://scholar.google.com/citations?user=NSCMi88AAAAJ\u0026#34; facebook = \u0026#34;https://www.facebook.com/masahiro.hiramori\u0026#34; [[params.addtional_menus]] title = \u0026#34;CV\u0026#34; href = \u0026#34;/top/cv/\u0026#34; [[params.addtional_menus]] title = \u0026#34;ABOUT\u0026#34; href = \u0026#34;/top/about/\u0026#34; [outputFormats.Algolia] baseName = \u0026#34;algolia\u0026#34; isPlainText = true mediaType = \u0026#34;application/json\u0026#34; notAlternative = true [params.algolia] vars = [\u0026#34;title\u0026#34;, \u0026#34;summary\u0026#34;, \u0026#34;date\u0026#34;, \u0026#34;publishdate\u0026#34;, \u0026#34;expirydate\u0026#34;, \u0026#34;permalink\u0026#34;] params = [\u0026#34;categories\u0026#34;, \u0026#34;tags\u0026#34;] [markup.tableOfContents] endLevel = 2 startLevel = 1 [markup.highlight] style = \u0026#34;dracula\u0026#34; [markup.goldmark.renderer] unsafe = true   以下のコマンドでローカルにて確認できる。\n1  $ hugo server -D   http://localhost:1313/をブラウザで開くとサンプルページが表示される。\nGitHub Pagesで公開 hugoでビルドしたページはpublic/ディレクトリに生成される。このディレクトリをusername.github.ioにプッシュすることで、GitHub Pagesが更新される。 hugoで作成したblogディレクトリをリモートのblog/リポジトリに紐付け、public/ディレクトリをusername.github.ioリポジトリに紐付ける。\n1 2 3  $ cd ~/workspace/blog $ git remote add origin https://github.com/mshr-h/blog $ git submodule add -b master https://github.com/mshr-h/mshr-h.github.io public   この時点で各リポジトリとディレクトリの対応関係は以下の通り。\n1 2 3  ~/workspace/blog/ \u0026lt;-\u0026gt; https://github.com/mshr-h/blog +-public \u0026lt;-\u0026gt; github.com/mshr-h/mshr-h.github.io +-themes/hugo-theme-cleanwhite/ \u0026lt;-\u0026gt; https://github.com/zhaohuabing/hugo-theme-cleanwhite.git   Clean Whiteテーマにはデプロイスクリプトdeploy.shが用意されているので、これ使ってデプロイする。\n1 2  $ cd ~/workspace/blog $ ./deploy.sh   独自ドメイン設定 独自ドメインを使う場合、username.github.ioリポジトリとDNSレコードの設定が必要。\nusername.github.ioリポジトリの設定タブからGitHub PagesのCustom domainに独自ドメインを指定する。\nDNSのAレコードに以下を追加する。\n1 2 3 4  185.199.108.153 185.199.109.153 185.199.110.153 185.199.111.153   詳細はここを参照する。\n記事を追加 新しい記事を作成し、デプロイする。\n1 2 3  $ hugo new post/2020-04-01-article-title.md $ vim content/post/2020-04-01-article-title.md $ ./deploy.sh   Clean Whiteテーマ特有の設定 Clearn Whiteテーマはデフォルトで中華フォントのため、日本語フォントを使うためにはCustom CSSでフォントを指定する必要がある。\nstatic/css/custom-font.cssに以下の内容を保存する。\n1 2 3  body, h1, h2, h3, h4, h5, h6, .navbar-custom { font-family: Helvetica,\u0026#34;Sawarabi Gothic\u0026#34;,Meiryo,\u0026#34;メイリオ\u0026#34;,\u0026#34;Hiragino Kaku Gothic ProN\u0026#34;, \u0026#34;ヒラギノ角ゴ ProN\u0026#34;,YuGothic,\u0026#34;游ゴシック\u0026#34;,Arial,sans-serif; }   config.tomlにすでにcustom_cssに関して記載があるため、以下に書き換える。\n1  custom_css = [\u0026#34;css/custom-font.css\u0026#34;]   これでブログの設定完了。\n",date:"2020-05-02 Sat",permalink:"https://mshr-h.com/posts/new-website-with-hugo/",title:"Hugo+Github Pagesで新しい個人ウェブサイトを作った"},{body:"随時追記する。\nスクリーンショット取得  ディスプレイ全体のスクリーンショットをファイルに保存  command + shift + 3   ディスプレイ全体のスクリーンショットをクリップボードにコピー  command + shift + control + 3   選択範囲のスクリーンショットをファイルに保存  command + shift + 4   選択範囲のスクリーンショットをクリップボードにコピー  command + shift + control + 4   選択範囲したウィンドウのスクリーンショットをクリップボードにコピー  command + shift + control + 4 + space    ",date:"2020-04-29 Wed",permalink:"https://mshr-h.com/posts/macos-tips/",title:"macOS Tips"},{body:"macOS上のQEMUでRISC-V版Fedoraを動かしてみた。ビルド済みバイナリは下記から取得できるものを使用。\n https://fedorapeople.org/groups/risc-v/disk-images/  実施環境  macOS Catalina 10.15.4 brew導入済み  手順 HomebrewでQEMUを導入する。\n1  $ brew install qemu   ワークスペースに移動し、Linuxカーネル、ブートローダ、Fedoraディスクイメージをダウンロードする。\n1 2 3 4 5 6  $ cd ~/workspace $ mkdir risc-v-fedora $ wget https://fedorapeople.org/groups/risc-v/disk-images/vmlinux $ wget https://fedorapeople.org/groups/risc-v/disk-images/bbl $ wget https://fedorapeople.org/groups/risc-v/disk-images/stage4-disk.img.xz $ xzdec -d stage4-disk.img.xz \u0026gt; stage4-disk.img   以下のコマンドでQEMUを起動する。\n1 2 3 4 5 6 7 8 9 10 11  $ qemu-system-riscv64 \\  -nographic \\  -machine virt \\  -kernel bbl \\  -object rng-random,filename=/dev/urandom,id=rng0 \\  -device virtio-rng-device,rng=rng0 \\  -append \u0026#34;console=ttyS0 ro root=/dev/vda\u0026#34; \\  -device virtio-blk-device,drive=hd0 \\  -drive file=./stage4-disk.img,format=raw,id=hd0 \\  -device virtio-net-device,netdev=usernet \\  -netdev user,id=usernet,hostfwd=tcp::10000-:22   ユーザ名はroot、パスワードはriscvでログインする。\n  ホストのmacOSからSSHで接続もできる。\n1  $ ssh -p 10000 root@localhost   ",date:"2020-04-29 Wed",permalink:"https://mshr-h.com/posts/boot-fedora-on-risc-v-qemu/",title:"macOSでRISC-V版FedoraをQEMUで起動する"},{body:"Rustで書かれたOS、VMM、Bootloaderについて調べた。\nOS  Tock  ARM Cortex-M、、STM32、RISC-Vで動く組み込みOS 論文も出てる  Multiprogramming a 64kB Computer Safely and Efficiently     Redox  x86-64で動くUNIX系のマイクロカーネルOS エディタ、GUI、ビルドツールもRustで書かれている   intermezzOS  教育用OS    VMM  crosvm  Chromium OSに搭載されているLinux sandbox VM   Firecracker  KVMを使用してmicroVMを起動できる crosvmをベースに開発した    Bootloader  oreboot  corebootのRust移植    ",date:"2020-04-29 Wed",permalink:"https://mshr-h.com/posts/rust-system-programming-oss/",title:"Rustで書かれた低レイヤOSS"},{body:"前回の記事で導入したRaspbian Busterに、TensorFlow LiteとOpenCVの環境を構築したのでメモ。\nPython 3.7.7導入 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17  $ sudo apt-get install -y git openssl libssl-dev libbz2-dev libreadline-dev libsqlite3-dev $ sudo apt-get install -y make build-essential libssl-dev zlib1g-dev libbz2-dev \\  libreadline-dev libsqlite3-dev wget curl llvm libncurses5-dev libncursesw5-dev \\  xz-utils tk-dev libffi-dev liblzma-dev python-openssl $ git clone https://github.com/pyenv/pyenv.git ~/.pyenv $ git clone https://github.com/yyuu/pyenv-virtualenv.git ~/.pyenv/plugins/pyenv-virtualenv $ sudo vi ~/.bashrc # 以下を追記 # ここから export PYENV_ROOT=\u0026#34;$HOME/.pyenv\u0026#34; export PATH=\u0026#34;$PYENV_ROOT/bin:$PATH\u0026#34; eval \u0026#34;$(pyenv init -)\u0026#34; eval \u0026#34;$(pyenv virtualenv-init -)\u0026#34; # ここまで $ source ~/.bashrc   開発用Python仮想環境構築 開発用ディレクトリは~/mldevとする。\n1 2 3 4 5  $ pyenv install 3.7.7 $ pyenv virtualenv 3.7.7 mldev $ mkdir ~/mldev $ cd ~/mldev $ pyenv local mldev   numpy導入 1.18.3は導入できなかったので、1つ古い1.18.2を導入する。\n1  $ pip install https://www.piwheels.org/simple/numpy/numpy-1.18.2-cp37-cp37m-linux_armv7l.whl   TensorFlow Lite 2.1導入 1 2  $ cd ~/mldev $ pip install https://dl.google.com/coral/python/tflite_runtime-2.1.0.post1-cp37-cp37m-linux_armv7l.whl   OpenCV 4導入 1 2 3 4 5 6 7 8 9 10 11 12 13 14  $ sudo apt-get install -y \\  build-essential cmake pkg-config \\  libjpeg-dev libtiff5-dev libpng-dev \\  libavcodec-dev libavformat-dev libswscale-dev libv4l-dev \\  libxvidcore-dev libx264-dev \\  libgtk2.0-dev libgtk-3-dev \\  libcanberra-gtk* \\  gfortran liblapacke-dev \\  libavresample-dev libtesseract-dev libleptonica-dev \\  libgstreamer1.0-dev libgstreamer-plugins-base1.0-dev \\  libhdf5-dev libhdf5-serial-dev libhdf5-103 \\  libqtgui4 libqtwebkit4 libqt4-test \\  python3-pyqt5 libatlas-base-dev libjasper-dev $ pip install opencv-contrib-python opencv-python   .bashrcに以下を追記し、端末を再起動する。これを追記しないと、OpenCVのインポート時にopencv: undefined symbol: __atomic_fetch_add_8のエラーがでる。\n1  export LD_PRELOAD=/usr/lib/arm-linux-gnueabihf/libatomic.so.1   実行確認 1 2 3 4 5 6 7 8 9  $ cd ~/mldev $ python Python 3.7.7 (default, Apr 23 2020, 21:26:28) [GCC 8.3.0] on linux Type \u0026#34;help\u0026#34;, \u0026#34;copyright\u0026#34;, \u0026#34;credits\u0026#34; or \u0026#34;license\u0026#34; for more information. \u0026gt;\u0026gt;\u0026gt; import tflite_runtime \u0026gt;\u0026gt;\u0026gt; import numpy \u0026gt;\u0026gt;\u0026gt; import cv2 \u0026gt;\u0026gt;\u0026gt;   ",date:"2020-04-27 Mon",permalink:"https://mshr-h.com/posts/install-tflite-opencv-using-pyenv-on-raspbian/",title:"RaspbianにTensorFlow Lite 2.1とOpenCV 4を導入する"},{body:"Raspberry Pi 3 Model BにRaspbian Busterを導入したので作業メモ。\n実施環境  MacBook Pro 13インチ 2017年モデル  macOS Catalina 10.15.4   Raspberry Pi 3 Model B Raspbian Buster with desktop  Raspbianイメージを取得 1 2  $ cd ~/Downloads $ wget http://downloads.raspberrypi.org/raspbian/images/raspbian-2020-02-14/2020-02-13-raspbian-buster.zip   Raspbianイメージを書き込み microSDカードをMacBook Proに接続する。以下のコマンドでイメージを書き込む。\n1 2 3 4 5 6 7  $ diskutil list $ diskutil umountDisk /dev/disk2 $ cd ~/Downlaods $ unzip 2020-02-13-raspbian-buster.zip $ sudo dd bs=1m if=2020-02-13-raspbian-buster.img of=/dev/rdisk2 conv=sync $ sync $ diskutil umountDisk /dev/disk2   Raspberry Piにマウス、キーボード、ディスプレイを接続する。\nmicroSDをRaspberry Piに入れ、microUSBケーブルを接続すると起動。\n初期設定 デスクトップが起動すると初期設定画面が表示されるので、ユーザパスワード、無線LAN接続などを設定する。\nデスクトップが表示されたら、端末からsudo raspi-configコマンドでコンフィグを起動する。\nInterfacing Optionsを選択し、カメラを接続するためP1 Cameraと、開発用PCからリモートで接続できるようにP2 SSHとP3 VNCをそれぞれ有効にする。\nifconfigコマンドでIPアドレスを確認し、再起動する。開発用PCからSSHでRaspberry Piのpiユーザへ接続できれば設定完了。\n参考文献  https://www.raspberrypi.org/downloads/raspbian/ https://www.raspberrypi.org/documentation/installation/installing-images/mac.md  ",date:"2020-04-25 Sat",permalink:"https://mshr-h.com/posts/install-raspbian-on-raspberrypi-3/",title:"Raspberry Pi 3にRaspbian Busterを導入する"},{body:"たまに使うUNIXコマンドとその使い方をメモ。\nzip  -0  store only(圧縮しない)   -j  junk (don\u0026rsquo;t record) directory names(ディレクトリ名を保存しない)    zipinfo ZIPファイル内に格納されているファイルの一覧やサイズ、ファイルを表示する。\nbasename ディレクトリ名(not パス)を取得するコマンド。\n例：現在のディレクトリ名を取得する。\n1  basename \u0026#34;$PWD\u0026#34;   qpdf PDFファイルを操作するコマンド。\nmacOSへの導入 1  $ brew install qpdf   実行例 input.pdfの暗号化を解除し、output.pdfとして出力する。\n1  $ qpdf --decrypt --password=1234 input.pdf output.pdf   オプション  --decrypt  暗号化を解除   --password  パスワードを指定   --replace-input  入力ファイルを上書き    stress-ng 1  stress-ng   ",date:"2020-04-24 Fri",permalink:"https://mshr-h.com/posts/unix-commands-tips/",title:"UNIXコマンド Tips"},{body:"H8/3069Fの開発ツールを導入する。次のソースコードをダウンロードし、$HOME/h8devtoolsに保存する。\n GMP MPFR binutils MPC GCC h8write  あとはひたすらconfigure\u0026amp;makeする。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43  cd ~/h8devtools/ tar xvf gmp-6.2.0.tar.lz cd gmp-6.2.0 mkdir build \u0026amp;\u0026amp; cd build ../configure --prefix=$HOME/h8devtools make -j4 make install cd ../.. tar xvf mpfr-4.0.2.tar.bz2 cd mpfr-4.0.2 mkdir build \u0026amp;\u0026amp; cd build ../configure --prefix=$HOME/h8devtools --with-gmp=$HOME/h8devtools make -j4 make install cd ../.. tar xvf binutils-2.33.90.tar.xz cd binutils-2.33.90 mkdir build \u0026amp;\u0026amp; cd build ../configure --prefix=$HOME/h8devtools --target=h8300-elf --disable-nls make -j4 make install cd ../.. tar xvf mpc-1.1.0.tar.gz cd mpc-1.1.0 mkdir build \u0026amp;\u0026amp; cd build ../configure --prefix=$HOME/h8devtools --with-gmp=$HOME/h8devtools --with-mpfr=$HOME/h8devtools make -j4 make install cd ../.. tar xvf gcc-9.3.0.tar.xz cd gcc-9.3.0 mkdir build \u0026amp;\u0026amp; cd build ../configure --target=h8300-elf --disable-nls --disable-threads --disable-shared --disable-libssp --enable-languages=c --with-gmp=$HOME/h8devtools --with-mpfr=$HOME/h8devtools --with-mpc=$HOME/h8devtools --prefix=$HOME/h8devtools make -j4 make install cd ../.. clang -Wall -o h8write h8write.c mv h8write $HOME/h8devtools/bin   最後に、$HOME/h8devtools/binを環境変数PATHへ追加する。h8300-elf-gccが実行できれば正常に開発ツールが導入されている。\n1 2 3 4 5 6 7 8  mshrs-MacBook-Pro:~ mshr$ h8300-elf-gcc -v Using built-in specs. COLLECT_GCC=h8300-elf-gcc COLLECT_LTO_WRAPPER=/Users/mshr/h8devtools/libexec/gcc/h8300-elf/9.3.0/lto-wrapper Target: h8300-elf Configured with: ../configure --target=h8300-elf --disable-nls --disable-threads --disable-shared --disable-libssp --enable-languages=c --with-gmp=/Users/mshr/h8devtools --with-mpfr=/Users/mshr/h8devtools --with-mpc=/Users/mshr/h8devtools --prefix=/Users/mshr/h8devtools Thread model: single gcc version 9.3.0 (GCC)   ",date:"2020-04-16 Thu",permalink:"https://mshr-h.com/posts/h8300-development-tools-for-macos/",title:"H8/3069Fの開発ツールをmacOSに導入"},{body:"最近、Rustプログラミング言語に入門した。Rustの公式ページには、Rustの特徴として信頼性について記載されている。本記事では、Rustが保証するメモリ安全性とスレッド安全性を実現する、所有権システムについて雑に理解したので説明する。\n所有権システム Rustは、コンパイル時にメモリ安全性に関するバグをコンパイルエラーとして開発者に教えてくれる。所有権システムは、メモリ安全性に関するバグをRustコンパイラが発見するための仕組み。所有権システムは、次の3つの概念で構成されている。\n 所有権 借用 ライフタイム  所有権 変数束縛において、Rustでは所有権という特性を持つ。変数は、束縛している値の「所有権」を持つ。Rustの値は、所有権を持つ変数がスコープから外れると、その値のリソースは開放される。\n例えば以下の例では、内側の{}に入ると、新しい値Vec\u0026lt;T\u0026gt;が作成され、変数barが値を束縛する。変数barのスコープは内側の{}の間のため、{}の前でも後でも使えない。内側の{}を抜けると、変数barのスコープが終了し、値Vec\u0026lt;T\u0026gt;のリソースが開放(デストラクタdrop()が呼ばれる)される。\n1 2 3 4 5 6 7 8 9  fn foo(){// barは使えない {letbar=vec![1,2,3];println!(\u0026#34;bar.0 = {}\u0026#34;,bar.0);}// Vec\u0026lt;T\u0026gt;のリソースが開放される // barは使えない }  ムーブとコピー 次のコードを実行すると期待通りの実行結果が得られる。\n1 2 3 4 5 6  fn main(){letx=1;lety=x;println!(\u0026#34;x = {}, y = {}\u0026#34;,x,y);// =\u0026gt; x = 1, y = 1 }  一方、次のコードではコンパイルエラーが発生する。\n1 2 3 4 5  fn main(){letx=String::from(\u0026#34;hello\u0026#34;);lety=x;println!(\u0026#34;x = {}, y = {}\u0026#34;,x,y);}  1 2 3 4 5 6 7 8 9  error[E0382]: borrowofmovedvalue: `x`--\u0026gt; src/main.rs:4:32|2|letx=String::from(\u0026#34;hello\u0026#34;);|-moveoccursbecause`x`hastype `std::string::String`,whichdoesnotimplementthe`Copy`trait3|lety=x;|-valuemovedhere4|println!(\u0026#34;x = {}, y = {}\u0026#34;,x,y);|^valueborrowedhereaftermove  Rustでは、関数の引数や代入文は値そのものを渡すのではなく、所有権をムーブするのがデフォルト。let y = xでstd::string::Stringの所有権はyにムーブされたにも関わらず、println!(\u0026quot;x = {}, y = {}\u0026quot;, x, y)でxを使おうとしたため、エラーが発生した。\nRustのプリミティブ型のうち、スカラ型にはCopyトレイトが実装されている。Copyトレイトが実装されている変数の場合、値をコピーして、新しくその値の所有権を持つ変数を作成する。最初の例では、xはCopyトレイトが実装されているため、let y = xは所有権のムーブではなく、コピーされ、後続の処理においてもxを使うことができる。\n関数をまたいだ所有権の移動 関数呼び出しにおける引数においても、所有権はムーブする。次の例では、print_string(str)でstrを引数として指定しているため、所有権もムーブする。そのため、print_string(str)以降の処理ではstrを使用することができない。\n1 2 3 4 5 6 7 8 9  fn print_string(x: String){println!(\u0026#34;{}\u0026#34;,x);}fn main(){letstr=String::from(\u0026#34;sample\u0026#34;);print_string(str);// strの所有権はprint_stinr()に移動したため、以降strは使えない }  次のように、print_string()でxの所有権を返し、main()で所有権を受け取ることで解決できる。しかし、このような書き方は煩雑のため、「借用」を使うことで同様のことを実現する仕組みがある。\n1 2 3 4 5 6 7 8 9 10 11  fn print_string(x: String)-\u0026gt; String{println!(\u0026#34;{}\u0026#34;,x);x}fn main(){letstr=String::from(\u0026#34;sample\u0026#34;);letstr2=print_string(str);println!(\u0026#34;{}\u0026#34;,str2);// =\u0026gt; sampleと出力される }  借用 借用とは、所有権をムーブせずに、所有権を一時的に貸し出す参照を作る仕組み。参照は、スコープが終了してもリソースを開放しない。上記の例を借用を用いて書き直したのが以下のプログラム。\n1 2 3 4 5 6 7 8 9  fn print_string(x: \u0026amp;String){println!(\u0026#34;{}\u0026#34;,x);}fn main(){letstr=String::from(\u0026#34;sample\u0026#34;);print_string(\u0026amp;str);println!(\u0026#34;{}\u0026#34;,str);}  \u0026amp;は参照を意味する。参照は何らかの実態を指すポインタで、デフォルトでイミュータブルのため、参照している値を変更できない。変更するには、\u0026amp;mutを付けてミュータブルな参照を作る必要がある。\n1 2 3 4 5 6 7 8 9 10  fn print_string(x: \u0026amp;mutString){x.push_str(\u0026#34; text\u0026#34;);}fn main(){letmutstr=String::from(\u0026#34;sample\u0026#34;);println!(\u0026#34;{}\u0026#34;,str);print_string(\u0026amp;mutstr);println!(\u0026#34;{}\u0026#34;,str);}  借用は、次のいずれか一方の状態を満たす必要がある。\n  ただ一つのミュータブルな参照が存在する状態\n1 2 3 4 5 6 7  fn main(){letmutstr=String::from(\u0026#34;sample\u0026#34;);letstr1=\u0026amp;mutstr;str1.push_str(\u0026#34; text\u0026#34;);println!(\u0026#34;str1: {}\u0026#34;,str1);// =\u0026gt; sample text }    複数のイミュータブルな参照が存在する状態\n1 2 3 4 5 6 7  fn main(){letmutstr=String::from(\u0026#34;sample\u0026#34;);letstr1=\u0026amp;str;letstr2=\u0026amp;str;println!(\u0026#34;str1: {}, str2: {}\u0026#34;,str1,str2);// =\u0026gt; str1: sample, str2: sample }    ライフタイム ライフタイムとは、参照が有効になる範囲(スコープ)のこと。参照は、何らかの実体を指すポインタのため、その指している実体より長く生き残ることはできない。ライフタイムにより、ある参照には必ず実体が存在する、ということが保証される。多くの場合、プログラマはRustコンパイラがライフタイムを推論してくれるため、ライフタイムを明示的に指定する必要はない。Rustコンパイラは、借用チェッカにより参照のスコープを比較することで、参照が有効かをチェックする。\n例えば、下記のプログラムはコンパイルエラーが発生する。\n1 2 3 4 5 6 7 8  fn main(){lety_ref;{lety=10;y_ref=\u0026amp;y;}println!(\u0026#34;x = {}\u0026#34;,y_ref);}  1 2 3 4 5 6 7 8 9  error[E0597]: `y`doesnotlivelongenough--\u0026gt; src/main.rs:5:17|5|y_ref=\u0026amp;y;|^^borrowedvaluedoesnotlivelongenough6|}|-`y`droppedherewhilestillborrowed7|println!(\u0026#34;x = {}\u0026#34;,y_ref);|-----borrowlaterusedhere  これは、yのライフタイムは内側の{}であるのに対し、yを参照するy_refはその外側であり、yはy_refより長く生き残れないため、借用チェッカによりエラーが発生する。\nまとめ Rustの所有権システムは、所有権、借用、ライフタイムの3つの概念から構成されている。\n「所有権」とは、ある値は一つの変数のみからしか読み書きを行わない、というルールのこと。所有権を持つ変数のスコープが終了すると、その値は破棄される。ある変数が所有する所有権は、他の変数へ移動(ムーブ)することができ、ムーブすると元の変数から値にアクセスできなくなる。\nムーブすることなく、値へアクセスするために、「借用」という所有権を一時的に貸し出す仕組みにより、所有権を持つ変数への参照を作ることができる。借用は、「ただ一つのミュータブルな参照が存在する状態」、「複数のイミュータブルな参照が存在する状態」のいずれか一つの状態を満たすことができる。\n参照には「ライフタイム」が存在する。ライフタイムとは、その参照が有効であるスコープのこと。Rustコンパイラは、ライフタイムを比較することで、参照が有効であることを保証する。\n",date:"2020-04-15 Wed",permalink:"https://mshr-h.com/posts/what-is-ownership-borrow-lifetime-in-rust-language/",title:"Rustの所有権、借用、ライフタイムについて雑に理解した"},{body:"12ステップで作る 組込みOS自作入門を再開するにあたり、MacBook Pro 13インチを購入したのでmacOS上で開発しようと思う。\n使用するUSBシリアル変換アダプタは下記で購入したもの。\n ＦＴ２３２　ＵＳＢシリアル変換ケーブル　ＶＥ４８８  ドライバ導入 以下のページからFTDIUSBSerialDriver_xxxxx.dmgをダウロードし、ダブルクリックして開く。\n Virtual COM Port Drivers  中に入っているFTDIUSBSerial.pkgを右クリックし、Openをクリックする。インストーラが起動するので、指示に従いドライバをインストールする。\n接続確認 シリアル変換デバイスをMacに接続し、iTermでls /dev/cu.*を実行すると/dev/cu.usbserial-XXXXXX(XXXXXXは英数字)が表示される。\nあとはscreen /dev/cu.usbserial-XXXXXXでこのデバイスに繋ぐだけ。\n",date:"2020-04-14 Tue",permalink:"https://mshr-h.com/posts/macos-ftdi-ft232-usb-serial-device/",title:"FTDI社製FT232シリーズのUSBシリアル変換アダプタをmacOSで使う"},{body:"以前、Next.js Learn (Basics)でNext.jsの基礎を学んだでNext.jsのチュートリアルを実施した。今回は続きのNext.js Learn (Excel)を実施したので、まとめた。\n内容 Next.js Learn (Excel)は4つのレッスンで構成されている。\n Export into a Static HTML App TypeScript Create AMP Pages Automatic Static Optimization  Export into a Static HTML App Next.js Learn (Basics)で作成したTV Showsを静的コンテンツとしてエクスポートする。TV Showsのルートディレクトリに下記内容をnext.config.jsとして保存する。これは、エクスポート時に呼ばれる関数で、/と/about、/show/[id]のパス情報を出力する。/show/[id]はTVmaze APIのアクセス結果からパス情報を取得している。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20  const fetch = require(\u0026#39;isomorphic-unfetch\u0026#39;); module.exports = { exportTrailingSlash: true, exportPathMap: async function() { const paths = { \u0026#39;/\u0026#39;: { page: \u0026#39;/\u0026#39; }, \u0026#39;/about\u0026#39;: {page: \u0026#39;/about\u0026#39;} }; const res = await fetch(\u0026#39;https://api.tvmaze.com/search/shows?q=batman\u0026#39;); const data = await res.json(); const shows = data.map(entry =\u0026gt; entry.show); shows.forEach(show =\u0026gt; { paths[`/show/${show.id}`] = {page: \u0026#39;/show/[id]\u0026#39;, query: {id: show.id } }; }); return paths; } };   ルートディレクトリでnpm run exportを実行すると、TV Showsの各ページが静的コンテンツとして/outに出力される。npm install -g serveでHTTPサーバをインストールし、serveで配信するとBatman TV Showsへアクセスできる。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37  $ npm run export \u0026gt; hello-next@1.0.0 export /Users/mshr/next-learn-demo/E1-static-export \u0026gt; next export \u0026gt; using build directory: /Users/mshr/next-learn-demo/E1-static-export/.next copying \u0026#34;static build\u0026#34; directory launching 3 workers [ =] Exporting (1/14)Fetched show: The Batman Show data fetched. Count: 10 [ ] Exporting (1/14)Fetched show: Batman [ ===] Exporting (4/14)Fetched show: Batman: The Animated Series Fetched show: The New Batman Adventures Fetched show: Batman Beyond [= ] Exporting (7/14)Fetched show: Beware the Batman Fetched show: Batman: Black and White [ ==] Exporting (9/14)Fetched show: Batman Unlimited [== ] Exporting (12/14)Fetched show: The Adventures of Batman [====] Exporting (13/14)Fetched show: Batman: The Brave and the Bold Exporting (14/14) Export successful mshrs-MacBook-Pro:out mshr$ ls 404 _next index.html 404.html about show mshrs-MacBook-Pro:out mshr$ serve -p 8080 ┌────────────────────────────────────────────────────┐ │ │ │ Serving! │ │ │ │ - Local: http://localhost:8080 │  │ - On Your Network: http://192.168.0.1:8080 │  │ │ │ Copied local address to clipboard! │ │ │ └────────────────────────────────────────────────────┘   TypeScript Next.jsはTypeScriptに対応している。このレッスンでは、新しくプロジェクトを作り、その中で作業を進める。\n1 2 3 4 5  mkdir next-ts cd next-ts npm init -y npm install --save react react-dom next npm install --save-dev typescript @types/react @types/node   package.jsonを開き、scriptを以下に書き換える。\n1 2 3 4 5  \u0026#34;scripts\u0026#34;: { \u0026#34;dev\u0026#34;: \u0026#34;next\u0026#34;, \u0026#34;build\u0026#34;: \u0026#34;next build\u0026#34;, \u0026#34;start\u0026#34;: \u0026#34;next start\u0026#34; }   pages/index.tsxを作り、以下を記述する。\n1 2 3  const Home = () =\u0026gt; \u0026lt;h1\u0026gt;Hello world!\u0026lt;/h1\u0026gt;; export default Home;   npm run devを実行すると、開発サーバが起動するとともにtsconfig.jsonが自動生成された旨のメッセージが端末に表示される。\n次に、pages/index.tsxを下記に書き換え、\n1 2 3 4 5 6 7 8  const Home = ({ userAgent }) =\u0026gt; \u0026lt;h1\u0026gt;Hello world! - user agent: {userAgent}\u0026lt;/h1\u0026gt;; Home.getInitialProps = async ({ req }) =\u0026gt; { const userAgent = req ? req.headers[\u0026#39;user-agent\u0026#39;] : navigator.userAgent; return { userAgent }; }; export default Home;   tsconfig.json内のstrictを\u0026quot;strict\u0026quot;: trueへ書き換え、http://localhost:3000へアクセスすると、型エラーが表示される。\n1 2 3 4 5 6 7  ERROR in /Users/mshr/next-ts/pages/index.tsx(1,17): 1:17 Binding element \u0026#39;userAgent\u0026#39; implicitly has an \u0026#39;any\u0026#39; type. \u0026gt; 1 | const Home = ({ userAgent }) =\u0026gt; \u0026lt;h1\u0026gt;Hello world! - user agent: {userAgent}\u0026lt;/h1\u0026gt;; | ^ 2 | 3 | Home.getInitialProps = async ({ req }) =\u0026gt; { 4 | const userAgent = req ? req.headers[\u0026#39;user-agent\u0026#39;] : navigator.userAgent;   index.tsxを下記に書き換え、型情報を付与することで、エラーが解消される。\n1 2 3 4 5 6 7 8 9 10 11 12  import { NextPage } from \u0026#39;next\u0026#39;; const Home: NextPage\u0026lt;{ userAgent: string }\u0026gt; = ({ userAgent }) =\u0026gt; ( \u0026lt;h1\u0026gt;Hello world! - user agent: {userAgent}\u0026lt;/h1\u0026gt; ); Home.getInitialProps = async ({ req }) =\u0026gt; { const userAgent = req ? req.headers[\u0026#39;user-agent\u0026#39;] || \u0026#39;\u0026#39; : navigator.userAgent; return { userAgent }; }; export default Home;   Create AMP Pages アプリケーションをAMP対応させる。configオブジェクトのamp: trueをエクスポートすることで、常にAMP対応ページになる。\n1 2 3 4 5 6  // pages/index.js export const config = { amp: true }; export default function Index(props) { return \u0026lt;p\u0026gt;Welcome to the AMP only Index page!!\u0026lt;/p\u0026gt;; }   amp: 'hybrid'とすることで、URLへ?amp=1を付けるとAMPページが、付けないと通常のページがレンダリングされる。\n1 2 3 4 5 6 7 8 9  // pages/index.js import { useAmp } from \u0026#39;next/amp\u0026#39;; export const config = { amp: \u0026#39;hybrid\u0026#39; }; export default function Index(props) { const isAmp = useAmp(); return \u0026lt;p\u0026gt;Welcome to the {isAmp ? \u0026#39;AMP\u0026#39; : \u0026#39;normal\u0026#39;} version of the Index page!!\u0026lt;/p\u0026gt;; }   Automatic Static Optimization Next.js 9以降のバージョンでは、動的な実装を含むページはServerとして、静的な実装のみならStaticとしてビルドしてくれる。\n以下の実装をindex.jsとして保存する。\n1 2  const Index = () =\u0026gt; \u0026lt;h1\u0026gt;Hello World\u0026lt;/h1\u0026gt;; export default Index;   npm run buildでビルドすると、Staticとしてビルドされたことが確認できる。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24  mshrs-MacBook-Pro:hello-next mshr$ npm run build \u0026gt; hello-next@1.0.0 build /Users/mshr/hello-next \u0026gt; next build Creating an optimized production build Compiled successfully. Automatically optimizing pages Page Size First Load JS ┌ ○ / 266 B 58.2 kB └ ○ /404 3.15 kB 61.1 kB + First Load JS shared by all 57.9 kB ├ static/pages/_app.js 957 B ├ chunks/bd49b44e65de90cbf4f977910e0c706119f124ab.92878c.js 10.3 kB ├ chunks/framework.0f140d.js 40 kB ├ runtime/main.43a0bb.js 5.95 kB └ runtime/webpack.b65cab.js 746 B λ (Server) server-side renders at runtime (uses getInitialProps or getServerSideProps) ○ (Static) automatically rendered as static HTML (uses no initial props) ● (SSG) automatically generated as static HTML + JSON (uses getStaticProps)   次に、agent.jsとして以下を保存し、\n1 2 3 4 5 6 7 8  const Agent = ({ userAgent }) =\u0026gt; \u0026lt;h1\u0026gt;Your user agent is: {userAgent}\u0026lt;/h1\u0026gt;; Agent.getInitialProps = async ({ req }) =\u0026gt; { const userAgent = req ? req.headers[\u0026#39;user-agent\u0026#39;] : navigator.userAgent; return { userAgent }; }; export default Agent;   同様にnpm run buildでビルドすると、今度はServerとしてビルドされる。getInitialPropsを含むため、動的ページとして認識されている。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26  mshrs-MacBook-Pro:.next mshr$ npm run build \u0026gt; hello-next@1.0.0 build /Users/mshr/hello-next \u0026gt; next build Creating an optimized production build Compiled successfully. Automatically optimizing pages Page Size First Load JS ┌ ○ / 266 B 58.6 kB ├ ○ /404 3.15 kB 61.4 kB └ λ /agent 400 B 58.7 kB + First Load JS shared by all 58.3 kB ├ static/pages/_app.js 959 B ├ chunks/f7db141d5c375743d3f7fa783807f86c90c92554.a3bfbe.js 2.4 kB ├ chunks/fbdfa5f92fe41f664c609f7a50034ba170386183.79e44c.js 8.28 kB ├ chunks/framework.0f140d.js 40 kB ├ runtime/main.9a37d4.js 5.95 kB └ runtime/webpack.b65cab.js 746 B λ (Server) server-side renders at runtime (uses getInitialProps or getServerSideProps) ○ (Static) automatically rendered as static HTML (uses no initial props) ● (SSG) automatically generated as static HTML + JSON (uses getStaticProps)   まとめ Next.js Learn (Excel)では、静的コンテンツとしてエクスポートする方法、TypeScript、アプリケーションをAMP対応する方法、Automatic Static Optimizationによるページの自動静的/動的ビルドを学んだ。今回学んだことをベースに、このブログをカスタマイズしていきたい。\n",date:"2020-04-13 Mon",permalink:"https://mshr-h.com/posts/nextjs-learn-excel/",title:"Next.js Learn (Excel)で静的コンテンツ生成などを学んだ"},{body:"Interface 2020年5月号の読書メモ。\n第1部と第2部のみ記載、第3部はRustとGoの説明。\n第1部　進化を続けるプログラミング言語の世界  プログラミング言語の分類  分類その1　コンパイル言語 vs 非コンパイル言語  コンパイル言語はAOTコンパイラを用いる言語  代表例としてはC言語やJavaなど   非コンパイル言語はJITコンパイラやインタプリタを用いる言語  代表例としてはPythonやRubyなど     分類その2　型のある言語 vs 型のない言語  型とは、intやfloat、文字列といったデータ型のことを指す 型のある言語とは、強い静的型付けを行う言語のこと 静的型付けとは、コンパイル時にあらゆる変数の型を決定すること 強いとは、コンパイル時に行われる型検査で、型の安全性が保証されること  2つの変数が同じ型を持つと判定されたら、実行時のその2つの変数の間で代入が行われても、型の不一致によるエラーは発生しないことが保証されている   C言語は静的だが弱い型を持つ言語 Javaは強い静的型付けを行う言語   分類その3　手続き型 vs 関数型  手続き型とは、命令を順に並べることでプログラムを作る言語  C言語、Javaなど   関数型とは、プログラムの基本単位が式と関数であり、関数の入力(引数)と出力(返り値)をつなぐことでプログラムを作る言語  Haskell、Elixirなど     分類その4　ウェブ・フロントエンド系言語かそうでないか  1~3は機能的な分類であるが、4は応用用途による分類 ウェブ・クライアントとして、ブラウザ上で動くことを前提としたプログラミング言語 代表例はJavaScriptやTypeScriptなど      第2部　プログラミング言語＆コンパイラの基礎知識  プログラミング言語の実行方式による分類  コンパイラ(一括翻訳)型  テキストで記述したプログラムを一括翻訳(コンパイル)し、コンピュータ上で実行できるバイナリ形式にして実行する プログラムの実行前に、CPUが実行できる命令に変換するため、オーバーヘッドがない プログラムを修正するたびにコンパイルする必要がある 代表例：C、Fortran、Ada、Rust   インタプリタ(逐次翻訳)型  テキストで書かれたプログラムを逐次読み出して解釈してコンピュータを動かす 逐次、テキストで記述されたプログラムを読み出して解釈するため、実行時のオーバヘッドが大きい 手軽にプログラムを変更して実行確認できる 代表例：Python、Ruby、Perl、Bash   中間言語・仮想マシン  インタプリタ型の言語で、速度面の改善のために一度中間言語や仮想マシンを介して動く形式を採用している場合もある コンパイラ型の言語で、LLVMのようにCコンパイラで、LLVM IRのようなコンピュータに依存しない中間言語を利用できる処理系も存在する 代表例：Java     機械語からアセンブリ言語、高級言語の登場、現在主流の言語までの歴史的な経緯 原点となる概念  リスト構造、ラムダ式をベースにして関数型言語の基となったLISP メッセージをベースにした純粋なオブジェクト指向を実現したSmalltalk 一番普及した手続き型言語C   C言語の大きな特徴  手続き型の高級言語としての側面  構造化、モジュール化、タイプチェックの厳格な言語仕様により、アルゴリズムを読みやすく、保守しやすく記述可能   汎用のマクロ・アセンブラとしての側面  OSを記述するために、実コンピュータ・ハードウェアに適合してプログラムを効率的に走らせるための良いコードに変換することを目的としている CPUの演算に依存する仕様はあえて緩やかな規定になっている     Cコンパイラ  GCC  現存するほぼすべてのCPUに対応しており、特定のCPUによらずに開発されている  特定のCPUの最適化は、個別のCPUに特化したコンパイラ(Intel C Compilerなど)と比べて性能面で劣る   汎用コンパイラとして、C++、Objective-C、Go、Fortran、Adaなどの言語に対応   LLVM  GCCはGPLライセンスのため、商用向けにコンパイラの各機能を個別にモジュールとして新しいコンパイラ・ツールを開発するには使いにくい LLVMはコンパイラの各機能をモジュール化し、BSDライセンスでリリースされた  現在は条件付きApache Licenseとなっている   JavaのようなCPUに依存しないビット・コードを作成し、それからターゲットCPU向けに翻訳する仕組み 移植しやすく、コンパイルの各段階で最適化、高速化、デバッグ・ツールの研究開発が進んでいるため、さまざまなコンパイラ・ツールが開発されている     モダン・コンパイラLLVMの基礎知識  LLVMがどのようにコンパイラ開発を変えたか  LLVM中間言語(LLVM IR)により、コンパイラ開発の揚力を大幅に削減できる  中間言語がないと、各高級言語に対して、各機械語へコンパイルするための実装は、「高級言語の数×機械語の数」となる 中間言語を挟むことで、各高級言語について、中間言語へコンパイル、中間言語から機械語へのコンパイルのみを実装すればよく、「高級言語の数+機械語の数」の実装でよくなる 最適化のアルゴリズムも中間言語で実装するため、再利用が可能 機械語依存の最適化を実装する場合、高級言語とは独立して実装可能     ライセンス  LLVMを用いて作ったソフトウェアを使用、複製、変更、複合、公開、配布、再使用権許諾、売却を許す。ただし、  LLVMの再配布をする際に同じライセンスを提示しなければならない LLVMを用いて作ったソフトェアをLLVM開発者の名でプロモーションしてはならない   GPLライセンスのように、企業が再配布する際にはソースコードを公開しなければならないといったことが発生しない   構造  LLVMを基盤とするコンパイラが、高級言語を機械語へ翻訳する処理手順  任意の高級言語からLLVM IRへの翻訳を行うフロントエンド LLVM IRからLLVM IRへの最適化または計装(検査用のコード挿入)のためのコード変換を行うミドルレンジ LLVM IRから任意の機械語への翻訳、CPUアーキテクチャ依存の最適化を行うバックエンド   フロントエンド  C言語の場合、字句解析、構文解析、意味解析を実装し、最適化前のLLVM IRのコードを生成する Clangを用いたLLVM IR出力例  clang -S -emit-llvm main.c -o main.ll     ミドルレンジ  LLVM IRで最適化を行う optというLLVM IRの変換ツールがある  実行例：opt -S -O3 main.ll   optツールは、Passと呼ばれる静的解析およびコード変換のモジュールを複数動作させるための道具  Passの依存関係を踏まえながら、複数回同じPassが実行されないように静的解析で得られた情報を管理する -O3フラグで実行されるPassは250個以上     バックエンド  LLVM IRからCPUアーキテクチャの機械語へ翻訳する x86、ARM、MIPS、PowerPCなどに対応 実行例  llc mail.ll -o main.asmでLLVM IRからアセンブリ・コードへ変換 clang main.asm -o fooでアセンブリコードを実行可能バイナリへ変換  アセンブラはClangに内蔵       LLVM IRの主要な特徴  SSA(Static Single Assignment)形式：1つの変数が1度しか定義されない性質 型安全：アセンブリ・コードと違い型が定義されており、狭義の型安全性を持つ   optツールが使うPassモジュールの自作  データ・フロー解析を実装する 詳細は書籍を参考        ",date:"2020-04-11 Sat",permalink:"https://mshr-h.com/posts/interface-2020-5-research-on-modern-language/",title:"[読書メモ]Interface 2020年5月号 C/C++後継モダン言語の研究"},{body:"Next.jsの公式チュートリアルNext.js Learn (Basics)でNext.jsの基礎を学んだ。\n背景 本ブログは、Next.js+Notionでブログを作れるNotion Blogをベースに構築している。React、nodejs、Next.js等のWebフロントエンドは未経験者なので、ブログのカスタマイズに必要な知識の獲得を目的にチュートリアルを実施した。\n内容 チュートリアルは9つのレッスンで構成されている。全部実施するとおよそ3時間程度で終わる。\n Getting Started Navigate Between Pages Using Shared Components Create Dynamic Pages Clean URLs with Dynamic Routing Fetching Data for Pages Styling Components API Routes Deploying a Next.js App  各レッスンは繋がっており、全部実施すると計4つのアプリを作ることになる。\n Hello World  プロジェクト作成、サイト内遷移、共有コンポーネントを学ぶ   Blog  動的ページ、動的ルーティング、styled-jsx、Nowへのデプロイ方法を学ぶ   TV Shows  ページデータのフェッチを学ぶ   Famous Quotes  APIの作り方、使い方を学ぶ    下記リポジトリに各レッスンの開始状態が公開されているため、最初から実施する必要はなく途中からでも可能。\n zeit/next-learn-demo  作成したアプリ(Famous Quotes)  学習メモ  pages/p/[id].tsxのファイル名の[id]はdynamic route機能を意味する export default () =\u0026gt;...でReact Componentをエクスポートする Linkでページ内遷移する getInitialPropsを使い初回ロード時に実行する処理を記述する  ",date:"2020-03-23 Mon",permalink:"https://mshr-h.com/posts/nextjs-learn-basics/",title:"Next.js Learn (Basics)でNext.jsの基礎を学んだ"},{body:"ZEITは、静的サイト/サーバレス向けPaaSのNowを開発・提供している。NowのインタフェースとしてCLIツールが公式に開発されている。しかし、Now CLIはプロキシ環境下で使えないという制約がある。2017年1月27日に下記のGitHub Issueで話題に上がっているが、3年立った2020/3現在もProxyに対応していない。\n Unable to deploy because of proxy · Issue #255 · zeit/now  そこで、Now CLIをプロキシ対応させるラッパーが非公式に開発されており、これを使うことでプロキシ環境下でもNow CLIを使うことができる。\n proxify-now - npm   導入方法 以下のコマンドで導入できる。\n1  $ npm i -g now global-agent proxify-now   使い方 環境変数のhttp_proxyとhttps_proxyにプロキシサーバを設定する。Now CLIを使う際に、コマンド名をnowではなくpnowを実行するだけ。\n",date:"2020-03-20 Fri",permalink:"https://mshr-h.com/posts/how-to-use-now-cli-behind-proxy/",title:"プロキシ環境下でNow CLIを使う"},{body:"aptなどのパッケージマネージャでnode.jsをインストールすると、古いバージョンが導入されることがある。n packageを使うことで、簡単にnode.jsの最新版を導入できる。\n手順   node.jsとnpmを導入\n1  $ sudo apt install -y nodejs npm     n packageを導入\n1  $ sudo npm install -g n     n packageを使い、nodeの最新版を導入\n1  $ sudo n stable     最後に、apt-getで導入したnode.jsとnpmを削除\n1  $ sudo apt purge -y nodejs npm     正しく導入されていることを確認\n1 2  $ node -v v12.16.1     ",date:"2020-03-07 Sat",permalink:"https://mshr-h.com/posts/how-to-install-latest-nodejs-on-ubuntu/",title:"Ubuntuで最新版Node.jsをインストールする"},{body:"microsoft/onnxruntime provides build instruction for ARMv7l python wheel which requires onnx/onnx. But it doesn\u0026rsquo;t provide binary package nor build instruction for ARMv7l. So I\u0026rsquo;ve written a dockerfile to build onnx/onnx python wheel.\nBuild instruction 1. Create a build directory 1 2  mkdir build-onnx cd build-onnx   2. Save the dockerfile on into the build directory  Dockerfile.arm32v7  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34  FROM balenalib/raspberrypi3-python:latest-stretch-build ARG REPO_URL=https://github.com/onnx/onnx ARG BRANCH=master #Enforces cross-compilation through Qemu RUN [ \u0026#34;cross-build-start\u0026#34; ] RUN install_packages \\\\ sudo \\\\ build-essential \\\\ cmake \\\\ git \\\\ python3 \\\\ python3-pip \\\\ python3-dev \\\\ libprotoc-dev \\\\ protobuf-compiler RUN pip3 install --upgrade pip setuptools wheel RUN pip3 install numpy # Prepare onnx Repo WORKDIR /code RUN git clone --single-branch --branch ${BRANCH} --recursive ${REPO_URL} onnx # Start the basic build WORKDIR /code/onnx RUN python3 setup.py bdist_wheel # Build Output RUN realpath /code/onnx/dist/onnx-*.whl RUN [ \u0026#34;cross-build-end\u0026#34; ]   3. Run docker build It will take several hours depending on your machine specs.\n1  docker build -t onnx-arm32v7 -f Dockerfile.arm32v7 .   4. Note the full path of the .whl file It will print the path something like this.\n1 2 3  Step 12/13 : RUN realpath /code/onnx/dist/onnx-*.whl ---\u0026gt; Running in ded3b4302e29 /code/onnx/dist/onnx-1.6.0-cp35-cp35m-linux_armv7l.whl   5. Copy the Python wheel from the docker image 1 2 3  docker create -ti --name onnx_temp onnx-arm32v7 bash docker cp onnx_temp:/code/onnx/dist/onnx-1.6.0-cp35-cp35m-linux_armv7l.whl . docker rm -fv onnx_temp   6. Copy the wheel file to your ARMv7l device example:\n1  scp onnx-1.6.0-cp35-cp35m-linux_armv7l.whl pi@RaspberryPi:/home/pi/   7. On device, install the wheel file 1  pip install onnx-1.6.0-cp35-cp35m-linux_armv7l.whl   ",date:"2020-02-25 Tue",permalink:"https://mshr-h.com/posts/how-to-build-onnx-for-your-armv7l-devices/",title:"How to build onnx/onnx for your ARMv7l devices"},{body:"TD;LR 1 2 3 4  #include \u0026lt;stdio.h\u0026gt; printf(\u0026#34;\\\\t%s:%dL %s() : some_variable=%d\\\\n\u0026#34;, __FILE__, __LINE__, __func__, some_variable);   はじめに そこそこ大規模なOSS(TensorFlowというディープラーニングフレームワーク)の動作解析に役立ったコードスニペットを紹介。特に、関数間の呼び出し順序を解析するときに役に立った。\n説明 printf関数でソースコードのファイルパス、printf呼び出しの行数、printf呼び出し元の関数名を出力する。必要に応じて関数内に定義された変数も出力する。このコードスニペットで使っている事前定義識別子の説明は以下のとおり。\n __FILE__  ソースコードのファイル名がフルパスで文字列として定義されている変数   __LINE__  ソースコード中の行数が数値として定義されている変数   __func__  関数名が文字列として定義されている変数    使い方 呼び出し順序を解析したい関数の先頭に上記のコードスニペットを貼り付けて、ビルド、実行するだけ。\n",date:"2020-02-22 Sat",permalink:"https://mshr-h.com/posts/c-cpp-debug-print-practice/",title:"C/C++デバッグプリントプラクティス"},{body:"TD;LR 1 2  \u0026gt; netsh winhttp set proxy 1.2.3.4:5678 \u0026gt; slmgr.vbs -ipk AAAAA-BBBBB-CCCCC-DDDDD-EEEEE   手順 PowerShellを管理者権限で起動する。 netsh winhttp show proxyで現在のプロキシ設定を確認する。\n1 2 3 4 5  PS C:\\\\Windows\\\\system32\u0026gt; netsh winhttp show proxy 現在の WinHTTP プロキシ設定: 直接アクセス (プロキシ サーバーなし)。   netsh winhttp set proxy 1.2.3.4:5678でプロキシを設定する。下記コマンド実行例は、プロキシサーバが1.2.3.4:5678である前提。\n1 2 3 4 5 6  PS C:\\\\Windows\\\\system32\u0026gt; netsh winhttp set proxy 1.2.3.4:5678 現在の WinHTTP プロキシ設定: プロキシ サーバー: 1.2.3.4:5678 バイパス一覧 : (なし)   再度プロキシ設定を確認し、正しく設定されていることを確認する。\n1 2 3 4 5 6  PS C:\\\\Windows\\\\system32\u0026gt; netsh winhttp show proxy 現在の WinHTTP プロキシ設定: プロキシ サーバー: 1.2.3.4:5678 バイパス一覧 : (なし)   slmgr.vbs -ipk AAAAA-BBBBB-CCCCC-DDDDD-EEEEEでライセンス認証をする。下記コマンド、実行例はプロダクトキーがAAAAA-BBBBB-CCCCC-DDDDD-EEEEEである前提。\n1  PS C:\\\\Windows\\\\system32\u0026gt; slmgr.vbs -ipk AAAAA-BBBBB-CCCCC-DDDDD-EEEEE    以上の手順でライセンス認証は完了。\n",date:"2020-02-08 Sat",permalink:"https://mshr-h.com/posts/how-to-activate-windows10-behind-proxy/",title:"プロキシ環境下でWindows 10のライセンス認証する"},{body:"振り返ってみた。\n新規 Notion 年額48ドル。Todo、個人ORK、ウェブクリッパーなどを管理するために契約。\nGoogle One 2TB 月額1100円。PCのバックアップ先として契約。Web上から契約すると1300円だが、iOSのGoogle Driveアプリから契約するとなぜか1100円で契約できる。\nYoutube Premium 月額1180円。モバイルアプリでのオフライン視聴、広告なし視聴のために契約。広告がない世界は本当に最高。\n継続 Amazon Prime 年額4320円。お急ぎ便とプライムビデオがメイン。継続だが、Amazon Prime契約からAmazonマスターカードゴールドを作成し、カードの特典に乗り換えた。\nMoneyForward ME プレミアム 年額5300円。クレジットカード、銀行口座、証券口座、電子マネー、ポイント、通販サイトを登録してお金の出入を管理している。\nRebuild.fm 年額60ドル。サポーターフィードなら配信後すぐに聞けるので割りと重宝している。\n解約 Microsoft Office 365 Solo 年額12,744円。1年の間に使う期間が限られてるので解約した。必要に応じて月額プランを契約する予定。\n",date:"2020-01-18 Sat",permalink:"https://mshr-h.com/posts/list-of-subscription-in-2019/",title:"2019年にお金を払ったサービス"},{body:"                             ",date:"2019-12-31 Tue",permalink:"https://mshr-h.com/posts/14-climbing-videos-to-help-you-stay-motivated/",title:"14 Climbing Videos to Help You Stay Motivated"},{body:"自分が最近良く聴くPodcastをまとめた。\n一覧 Rebuild.fm Podcastを聞く習慣はこれと下で紹介するバイリンガルニュースで始まった。毎回ゲストを呼んで、Tech業界からアメリカ、ゲームなどのディープな話をしている。もちろんRebuild Supporterに登録もしている。好きなゲストはNさん。hakさん回のタイトルも好き。好きなエピソードは、54: Email Will Never Die (naan, N)、[Aftershow 86: The Japanese Protocol (N)](Aftershow 86: The Japanese Protocol (N))、162: In Development For 500 Years (hak)、177: Kamen Rider Ryzen (hak)。\nバイリンガルニュース 2人のホストがニュースを取り上げて英語と日本語でディスカッションするPodcast。最近は時間が取れなくてあまり聞けてない。ゲストを呼んでトークする特別編の方が好き。\nMisreading Chat Computer Science系論文を紹介するPodcast。難しい話のはずなのに、説明がめちゃくちゃ分かりやすいおかげで、聞くだけで論文の内容を何となく理解できる。\nFukabori.fm エピソード2しか聞けてないけど今後聞きたい。ゲストを呼んでTech系の話をする形式なのでRebuild.fmに近いと思う。\nTuring Complete FM Cコンパイラをスクラッチから開発してみたで有名なRuiさんのPodcast。ゲストを呼んでプログラミングについての話をする。Misreading Chatに近いけど、こっちは実装寄りの話が多い。\n使ってるアプリ iPhoneでしか聞かないので、iOS標準のPodcastアプリを使ってる。\nいつ聴くか 片道30分弱の通勤中。掃除、洗濯。登録してるPodcastの全エピソードを消化できてない。\n",date:"2019-12-21 Sat",permalink:"https://mshr-h.com/posts/list-of-my-favorite-podcasts/",title:"最近良く聴くPodcast"},{body:"現状の英語力  4年前にTOEIC 850点ぐらい取った 技術系の資料は割と読める 心理的障壁は英語と日本語であまり違いはない(技術系の資料に限る) 読解スピードに関しては英語の方が圧倒的に遅い  現状の英語勉強方法  iPhoneの言語設定を英語にする PCの言語設定を英語にする Googleの言語設定で英語を第一言語にし、なるべく英語記事が検索結果のトップに表示されるようにする 英語のYoutube動画を観たり、Podcastを聞いたりする(バイリンガルニュース、The Verge、Engadget、クライミング関係など) iPhoneの瞬間英作文アプリで1日1セクション勉強  何に満足してないか リスニング 動画、Podcastだとなんとく聞き取れ、雰囲気で理解できてしまう。\nリーディング 気になる英語の技術記事はたくさんあるが読解スピードが遅すぎるため、全部に目を通しきれない。\nライティング GitHubのIssueに書くぐらいでしか英語を書かない。起承転結のある、数百ワードぐらいの文書を書けるようになりたい。\nスピーキング そもそも英語で話す機会がない。機会がないのはスピーキング能力が低いから？\nつらつらと書いて気づいたこと  インプット偏重で、アウトプットがほとんど無い。 そもそも英語でアウトプットすることが不要な生活を送っているので当然。 オンライン英会話などでアウトプットする機会を作る必要がある？  ",date:"2019-12-14 Sat",permalink:"https://mshr-h.com/posts/how-i-study-english-as-of-2019-12/",title:"2019/12時点の英語勉強方法とか"},{body:"シューズ 最近はLa Sportivaのジーニアスを履いてます。BananaFingersで購入。\nLA SPORTIVA Genius\nチョーク\u0026amp;チョークバッグ Organic climbingのDELUXE CHALK BUCKETを愛用している。\n DELUXE CHALK BUCKET  チョークは東京粉末を使用。\n 東京粉末（TOKYO POWDER INDUSTRIES） PURE BLACK/ピュアブラック NET330g  チョークバッグにはMADROCKのブラシを使用。\n MADROCK(マッドロック) Hedgehog Climbing Brush MDZ011 ホワイト M  小物 今は売ってないが、無印の化粧ポーチに小物を入れている。\n ポリエステルラウンド広口ポーチ・仕切付カーキ・約１３．５×２０×９ｃｍ 通販 | 無印良品  テーピングテープを切る用のはさみ。\n ピップ テーピングハサミ ステンレス製  テーピングテープは指用に12mm、手首用に50mmを使用。\n ニチバン バトルウィンテーピングテープ 非伸縮タイプ 12mm幅 12m巻き 2巻入り 2巻入 テーピングテープ キネシオ テープ 筋肉・関節をサポート 伸縮性強い 汗に強い パフォーマンスを高める 5cm x 5m  傷手当用にバンドエイドとキズパワーパッド、液体絆創膏を使用。\n BAND-AID(バンドエイド) 救急絆創膏 ウォーターブロック 40枚 BAND-AID(バンドエイド) キズパワーパッド ふつうサイズ 10枚+ケース付 絆創膏  ",date:"2019-12-07 Sat",permalink:"https://mshr-h.com/posts/things-to-bring-for-climbing-gym-as-of-2019-12/",title:"Things to bring for climbing gym(as of 2019/12)"},{body:"私がメンテナであるOSS(Verilog HDL/SystemVerilog向けのVS Codeプラグイン)のIssueを見ていて気づいた、Issue報告時に気をつけて欲しいことをつらつら書いた。 OSSの規模感はインストール:9.2万、Star:63、Fork:26。\n 再現手順を記載する 「〇〇が正しく動かない」とだけ書かれたIssueがたまにある。OSやソフトウェアバージョン等の実行環境、再現手順、期待される結果が書かれていると、こちらで調査しやすくなる。\n1つのIssueには1つの問題だけ記載する 「〇〇という機能と××という機能が動かない」のようなIssueもたまにある。複数の問題を1つのIssueに詰め込まれると、手を付けるのが面倒になって後回しになることが多々あるので、1つのIssueには1つの問題だけ記載してほしい。\nおわりに とまあ、気をつけてほしいことを書いたが、以下のテンプレートを参考にIssue報告を書けば問題ないかと思う。\nGithub Issue Template Example - Loki Docs\n",date:"2019-11-03 Sun",permalink:"https://mshr-h.com/posts/things-to-be-careful-when-you-write-issue-on-github/",title:"OSSメンテナをしていて気づいた、Issue報告時に気をつけて欲しいこと"},{body:"TD;LR 1  /usr/bin/time -f \u0026#34;%M KB\u0026#34; command   GNU time GNU timeには、プロセスが使用したユーザ/システム時間だけでなく、最大メモリ使用量(Resident Set Size)を取得することができる。例えば、 git --versionを実行したときの最大メモリ使用量を表示するには、次のコマンドを実行する。\n1 2 3  $ /usr/bin/time -f \u0026#34;RSS: %M KB\u0026#34; git --version git version 2.17.1 RSS: 1312 KB   -fオプションで出力フォーマットを指定し、引数に%Mを指定することで最大メモリ使用量を表示する。\n1 2 3 4 5 6 7  OPTIONS -f FORMAT, --format FORMAT Use FORMAT as the format string that controls the output of time. See the below more information. ...... The resource specifiers, which are a superset of those recognized by the tcsh(1) builtin `time\u0026#39; command, are: ...... M Maximum resident set size of the process during its lifetime, in Kilobytes.   ",date:"2019-07-23 Tue",permalink:"https://mshr-h.com/posts/measuring-process-memory-usage-using-gnu-time/",title:"GNU timeでプロセスのメモリ使用量を取得する"},{body:"ある日、Windows上のVirtualBoxでVMを起動しようとしたら以下のエラーメッセージが出て起動しない問題が発生した。\n Webで検索してみたところ、4年ぐらい前のバージョンでも同様の問題が起きていたそう。\n #13697 (4.3.20 doesn’t start virtual machines any more (supHardenedWinVerifyProcess failed)) — Oracle VM VirtualBox  どうやらアンチウイルスソフトが問題の模様。今回、問題が起きたPCではウイルスバスターを導入しているが、これをアンインストールすることは諸事情によりできない。なので、VirtualBoxの古いバージョンを入れるしかなさそう。というわけで、VirtualBox 6.0.0をアンインストールし、VirtualBox 5.2.2を使用することで起きなくなった。\n",date:"2019-06-23 Sun",permalink:"https://mshr-h.com/posts/how-to-solve-error-in-supr3hardntchildpurify-on-virtualbox/",title:"Windows 10のVirtualBoxで「Error In supR3HardNtChildPurify」とエラーが表示されて仮想マシンが起動しない問題"},{body:"JAXとは、Python+NumPyプログラムを微分可能かつ、XLAを使ってGPUもしくはTPU上で動作するコードにコンパイルしてくれる、Pythonライブラリ。Googleが開発しており、現状はリサーチプロジェクト。 この記事ではJAX調査に向けて、WSL上でソースコードからビルドする環境構築手順を紹介。\n依存ライブラリ導入 ビルドに必要なPythonとライブラリを導入。\n1 2  sudo apt install -y python3 python3-dev pip install --user scipy   ソースコード取得 GitHubからソースコードを取得。\n1  git clone \u0026lt;https://github.com/google/jax\u0026gt;   ビルド開始 Pythonスクリプトを実行し、ビルドを開始します。XLAをCUDA有りでビルドする場合、--enable_cudaオプションを有効にしてbuild.pyを実行。以下はCPUのみのビルド。\n1 2  cd jax python build/build.py   Ryzen5 1600、メモリ32GB、1TB SSDの環境で２時間ぐらいかかった。\nインストール 以下のコマンドでインストール。\n1 2  pip install -e build pip install -e .   動作確認 Pythonインタプリタを起動後、JAXをインポートし、行列積の演算を実行。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24  $ python Python 3.6.7 (default, Oct 22 2018, 11:32:17) [GCC 8.2.0] on linux Type \u0026#34;help\u0026#34;, \u0026#34;copyright\u0026#34;, \u0026#34;credits\u0026#34; or \u0026#34;license\u0026#34; for more information. \u0026gt;\u0026gt;\u0026gt; import jax.numpy as np \u0026gt;\u0026gt;\u0026gt; from jax import random \u0026gt;\u0026gt;\u0026gt; key = random.PRNGKey(0) /home/mshr/src/github.com/google/jax/jax/lib/xla_bridge.py:164: UserWarning: No GPU found, falling back to CPU. warnings.warn(\u0026#39;No GPU found, falling back to CPU.\u0026#39;) \u0026gt;\u0026gt;\u0026gt; x = random.normal(key, (5000, 5000)) \u0026gt;\u0026gt;\u0026gt; print(np.dot(x, x.T) / 2) [[ 2.5272668e+03 8.1589289e+00 -8.5327983e-01 ... -9.3034286e+00 -3.1621683e+01 -1.7542191e+01] [ 8.1589289e+00 2.4567305e+03 2.2345556e+01 ... 5.2793068e+01 6.4099159e+00 -9.1594181e+00] [-8.5327983e-01 2.2345556e+01 2.4511853e+03 ... 1.2905287e+01 2.2311758e+01 -2.4411291e+01] ... [-9.3034382e+00 5.2793064e+01 1.2905293e+01 ... 2.5079480e+03 -4.8833957e+00 -2.1701965e+01] [-3.1621683e+01 6.4099188e+00 2.2311762e+01 ... -4.8834038e+00 2.4965664e+03 2.1068907e+01] [-1.7542183e+01 -9.1594162e+00 -2.4411289e+01 ... -2.1701965e+01 2.1068907e+01 2.4813088e+03]]   以上でGoogle/JAXをソースコードからビルドし、インストール、動作確認ができた。\n",date:"2019-05-12 Sun",permalink:"https://mshr-h.com/posts/how-to-install-google-jax/",title:"Google/JAX調査(インストール編)"},{body:"モンベル ボルダーマットを購入する前に他の候補と比較した際のメモを記しておく。 以下の要件で5つの候補を挙げた。\n 電車で岩場へ行くことを考え、そこそこ軽量でコンパクト マットをきれいにしたうえで自室に保管したいので、汚れを落としやすい   モンベル ボルダーマット←購入  サイズ：125×95×9cm 重量：4.7kg 価格：26,460円(モンベル通販) 折りたたみ方式：タコスタイル  ショルダーハーネスを覆うためのフラップが付いてる。裏地がTPUラミネートのため、雑巾で拭き掃除がしやすそう。気になる点は、少し重そうなのと、厚みが他と比べて薄いところ。\n→購入後感想：雑巾で拭き掃除がしやく、重さはそこまで感じず、厚みも今の所問題ない。\nsnap HIP  サイズ：120×100×10cm 重量：4.0kg 価格：28,080円(グッぼる) 折りたたみ方式：タコス  こちらはフラップがついてない代わりに、ショルダーハーネスを容易に取り外し可能。フラップがついてないため、拭き掃除に手間がかからなそう。また、4kgと軽量なため、電車移動にも向いてそう。気になる点は、マットを設置したときに背負う面が保護されないため、汚れが付着しやすそうな点。\nMETOLIUS sessionII  サイズ：122×91×10cm 重量：4.0kg 価格：17,604円(グッぼる) 折りたたみ方式：ヒンジタイプ  候補の中では最も安い。ショルダーハーネスを覆うためのフラップが付いているが、L字型のため、メンテナンスに手間がかかりそう。\nベアール エアライト  サイズ：100×100×9cm 重量：3.2kg 価格：23,004円(グッぼる) 折りたたみ方式：ヒンジタイプ  候補の中では最もコンパクトで軽量。調べてもあまり情報がなかった。\nORGANIC FULL PAD  サイズ：120×90×10cm 重量：5.2kg 価格：41,040円(エッジアンドソファ) 折りたたみ方式：ハイブリッドタイプ  候補の中では最も重い。ショルダーハーネスを覆うフラップが付いている。公式サイトだと着地面の色と柄をカスタマイズできて、日本への発送も可能とのこと。\n",date:"2019-04-28 Sun",permalink:"https://mshr-h.com/posts/choosing-crash-pad/",title:"外岩用ボルダーマット考"},{body:"Jupyter Notebook上でPythonコードを実行中に、メモリ使用量を確認したいときがある。次のプラグインをインストールすると、Jupyter Notebook上にメモリ使用量を表示できる。\n yuvipanda/nbresuse  インストール方法は次のコマンドを実行する。\n1  pip install nbresuse   Jupyter Notebookを起動すると、下図赤枠のようにメモリ使用量が表示さる。\n ",date:"2019-03-10 Sun",permalink:"https://mshr-h.com/posts/display-memory-usage-on-jupyter-notebook/",title:"Jupyter Notebook上に現在のノートブックのメモリ使用量を表示する"},{body:"Visual C++コンパイラについて調べたのでメモ。\nVisual C++コンパイラとは Microsoft Visual C++という、Microsoft製のC/C++統合開発環境に付属のC/C++コンパイラ。Visual Studioをインストールする際にC/C++開発サポートを有効にすると、Microsoft Visual C++が導入される。このVisual C++コンパイラ自体は、標準のインストール先であればC:\\\\Program Files (x86)\\\\Microsoft Visual Studio 14.0\\\\VC\\\\binに存在し、以下の実行ファイルとDLLで構成される。\n cl.exe：コンパイラのドライバ c1.dll：Visual Cのフロントエンド c1xx.dll：Visual C++のフロントエンド c2.dll：バックエンド   cl.exe\nコンパイラのドライバで、フロントエンド、バックエンドをつなぐ役割。\nc1.dll、c1xx.dll\nコンパイラのフロントエンド処理を実行する。C/C++ソースコードを解析し、MSIL(Microsoft Intermediate Language)形式の中間言語を生成する。ソースコードがC言語の場合はc1.dll、C++言語の場合はc1xx.dllにより処理される。\nc2.dll\nコンパイラのバックエンド処理を実行する。フロントエンドで生成されたMSILを受取り、最適化、コード生成(オブジェクトファイル生成)を行う。\nPhoenix Compiler Frameworkとは Microsoftが2003年頃？から研究開発しているコンパイラフレームワーク。プラグイン機構を採用することで、コンパイラのフロントエンド、バックエンドを取り替えることができる。これにより、新たなプログラミング言語/CPUアーキテクチャへの対応に必要な開発コストを削減可能となる。Visual C++コンパイラはこのPhoronix Compiler Frameworkがベースになってるよう。\n余談 LLVMの作者の一人であるChris Lattnerは学生時代、Microsoft ResearchのインターンでPhoenix Compiler Frameworkの開発に関わっていたらしい。具体的には、MicrosoftコンパイラとLLVMコンパイラのブリッジ(LLVMが.NETコードをコンパイル可能とする)の開発を行っていたそう。\n参考文献  Phoenix (compiler framework) — Wikipedia An Explanation of the Phoenix Compiler Framework Andy Ayers: Understanding the Phoenix Compiler Framework CppCon 2015: James Radigan “CLANG + C2 — Engineering/Futures/Measurements” — Youtube Phoenix: Experience with an Analysis and Optimization Framework — Microsoft Research [From Mole Hills to Mountains: Revealing Rich Header and Malware Triage](From Mole Hills to Mountains: Revealing Rich Header and Malware Triage) Chris Lattner’s Resume  ",date:"2019-02-10 Sun",permalink:"https://mshr-h.com/posts/phoenix-compiler-framework/",title:"Visual C++コンパイラとPhoenix Compiler Framework"},{body:"mshr-h/golicense\ngolicenseという、コマンドライン上でLICENSEファイルを生成するプログラムをGo言語で作成した。いくつかのライセンスから選んで、そのライセンスファイルをカレントディレクトリに出力する。\n現在サポートしているライセンスは以下の3つのみ。\n MIT GPL-3 Apache 2.0  インストール方法 1  go get github.com/mshr-h/golicense   おわりに Goの標準ライブラリのみ使用可能、という縛りで実装してみた。この程度の機能なら、外部ライブラリに頼らずとも簡単に実装できることが分った。他にもコマンドラインツールを作成して、Go標準のライブラリの勉強を進めていきたい。\n",date:"2019-01-19 Sat",permalink:"https://mshr-h.com/posts/golicense-generate-license-file-from-cli/",title:"LICENSEファイルを生成するgolicenseを作った"},{body:"ディープラーニングフレームワークのTensorFlowは、Googleが開発しており、ビルド済みのTensorFlowも提供されている。しかし、動作させるCPUによって、対応する拡張命令は異なる。ソースコードからビルドすることで、特定の環境でTensorFlowを高速に動作することが可能となる。 今回は、Linux(WSL)上でTensorFlowをソースコードからビルドする方法について書く。ビルドに使用するPC環境は以下のとおり。\n Ryzen 5 1600 32GBメモリ Windows Subsystem for Linux(Ubuntu 18.04)  今回は以下の構成でビルドする。\n TensorFlow v1.12.0 Python 2 GPUサポートは無し  基本的には、以下の公式ページ通りに進めることでビルドできるが、最新版Bazelを使うとビルドエラーになるため、古いバージョンを導入する必要があることに注意。\n Build from source | TensorFlow  ビルドの流れとしては、\n 必要なPythonパッケージ、ビルドツールの導入 ソースコードの取得 ビルドコンフィグの生成 ビルド実施  の順で進める。\nビルドに必要なPythonパッケージの導入 公式手順通りにPythonパッケージを導入する。\n1 2 3 4  $ sudo apt install -y python-dev python-pip $ pip install -U --user pip six numpy wheel mock $ pip install -U --user keras_applications==1.0.6 --no-deps $ pip install -U --user keras_preprocessing==1.0.5 --no-deps   Bazelの導入 2018/12/16時点の最新版(0.20.0)だとビルドできないので、古い0.15.0を導入する。\n1 2 3  $ wget https://github.com/bazelbuild/bazel/releases/download/0.15.0/bazel_0.15.0-linux-x86_64.deb $ sudo dpkg -i bazel_0.15.0-linux-x86_64.deb $ sudo apt install -f -y   TensorFlowソースコード取得 TensorFlowのソースコードを取得します。今回は、v1.12.0をビルドするので、該当tagをチェックアウトする。\n1 2 3  $ git clone https://github.com/tensorflow/tensorflow $ cd tensorflow $ git checkout v1.12.0   ビルドコンフィグ生成 ビルドコンフィグを生成する。今回はデフォルトのままで進める。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35  $ ./configure WARNING: The following rc files are no longer being read, please transfer their contents or import their path into one of the standard rc files: /home/mshr/tensorflow/tools/bazel.rc WARNING: --batch mode is deprecated. Please instead explicitly shut down your Bazel server using the command \u0026#34;bazel shutdown\u0026#34;. INFO: Invocation ID: 2e09c61f-cc51-4ae2-9704-46e8b8f239f5 You have bazel 0.20.0 installed. Please specify the location of python. [Default is /usr/bin/python]: Found possible Python library paths: /usr/local/lib/python2.7/dist-packages /usr/lib/python2.7/dist-packages Please input the desired Python library path to use. Default is [/usr/local/lib/python2.7/dist-packages] Do you wish to build TensorFlow with Apache Ignite support? [Y/n]: Apache Ignite support will be enabled for TensorFlow. Do you wish to build TensorFlow with XLA JIT support? [Y/n]: XLA JIT support will be enabled for TensorFlow. Do you wish to build TensorFlow with OpenCL SYCL support? [y/N]: No OpenCL SYCL support will be enabled for TensorFlow. Do you wish to build TensorFlow with ROCm support? [y/N]: No ROCm support will be enabled for TensorFlow. Do you wish to build TensorFlow with CUDA support? [y/N]: No CUDA support will be enabled for TensorFlow. Do you wish to download a fresh release of clang? (Experimental) [y/N]: Clang will not be downloaded. Do you wish to build TensorFlow with MPI support? [y/N]: No MPI support will be enabled for TensorFlow. Please specify optimization flags to use during compilation when bazel option \u0026#34;--config=opt\u0026#34; is specified [Default is -march=native]: Would you like to interactively configure ./WORKSPACE for Android builds? [y/N]: Not configuring the WORKSPACE for Android builds. Preconfigured Bazel build configs. You can use any of the below by adding \u0026#34;--config=\u0026lt;\u0026gt;\u0026#34; to your build command. See tools/bazel.rc for more details. --config=mkl # Build with MKL support. --config=monolithic # Config for mostly static monolithic build. --config=gdr # Build with GDR support. --config=verbs # Build with libverbs support. --config=ngraph # Build with Intel nGraph support. Configuration finished   ビルド実施 ビルドを開始する。今回のビルド環境だと1時間半程度かかる。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25  $ bazel build --config=opt //tensorflow/tools/pip_package:build_pip_package ・・省略・・ INFO: From Executing genrule //tensorflow/python/estimator/api:estimator_python_api_gen: tf.estimator package not installed. tf.estimator package not installed. Target //tensorflow/tools/pip_package:build_pip_package up-to-date:  bazel-bin/tensorflow/tools/pip_package/build_pip_package INFO: Elapsed time: 5474.748s, Critical Path: 172.25s INFO: 10641 processes: 10641 local. INFO: Build completed successfully, 11347 total actions ビルド完了後、PythonのPIPパッケージを作成します。作成には15分ほどかかります。 $ ./bazel-bin/tensorflow/tools/pip_package/build_pip_package /tmp/tensorflow_pkg Sat Dec 15 22:47:56 DST 2018 : === Preparing sources in dir: /tmp/tmp.qmE6tTngOh ~/tensorflow ~/tensorflow ~/tensorflow Sat Dec 15 22:49:18 DST 2018 : === Building wheel warning: no files found matching \u0026#39;*.pd\u0026#39; under directory \u0026#39;*\u0026#39; warning: no files found matching \u0026#39;*.dll\u0026#39; under directory \u0026#39;*\u0026#39; warning: no files found matching \u0026#39;*.lib\u0026#39; under directory \u0026#39;*\u0026#39; warning: no files found matching \u0026#39;*.h\u0026#39; under directory \u0026#39;tensorflow/include/tensorflow\u0026#39; warning: no files found matching \u0026#39;*\u0026#39; under directory \u0026#39;tensorflow/include/Eigen\u0026#39; warning: no files found matching \u0026#39;*.h\u0026#39; under directory \u0026#39;tensorflow/include/google\u0026#39; warning: no files found matching \u0026#39;*\u0026#39; under directory \u0026#39;tensorflow/include/third_party\u0026#39; warning: no files found matching \u0026#39;*\u0026#39; under directory \u0026#39;tensorflow/include/unsupported\u0026#39; Sat Dec 15 22:50:10 DST 2018 : === Output wheel file is in: /tmp/tensorflow_pkg   ビルドしたTensorFlowの導入 pipコマンドによりビルドしたTensorFlowを導入する。\n1  $ pip install --user /tmp/tensorflow_pkg/tensorflow-1.12.0-cp27-cp27mu-linux_x86_64.whl   MNISTを学習 ビルドしたTensorFlowの動作確認のために、TensorFlow公式チュートリアルに記載のMNISTを学習する。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18  import tensorflow as tf mnist = tf.keras.datasets.mnist (x_train, y_train),(x_test, y_test) = mnist.load_data() x_train, x_test = x_train / 255.0, x_test / 255.0 model = tf.keras.models.Sequential([ tf.keras.layers.Flatten(), tf.keras.layers.Dense(512, activation=tf.nn.relu), tf.keras.layers.Dropout(0.2), tf.keras.layers.Dense(10, activation=tf.nn.softmax) ]) model.compile(optimizer=\u0026#39;adam\u0026#39;, loss=\u0026#39;sparse_categorical_crossentropy\u0026#39;, metrics=[\u0026#39;accuracy\u0026#39;]) model.fit(x_train, y_train, epochs=5) model.evaluate(x_test, y_test)   以上で、TensorFlowをソースコードからビルドし、MNISTの学習を実施し、ビルドしたTensorFlowの動作を確認した。次回は、拡張命令の有無による動作速度の変化を検証したい。\n",date:"2018-12-19 Wed",permalink:"https://mshr-h.com/posts/how-to-build-from-tensorflow-on-wsl/",title:"Linux(WSL)上でTensorFlowをソースコードからビルドする"},{body:"TensorFlowのソースコードを読んでいたら、エンディアンチェックのコードが含まれていたので改めて調べた。 該当するTensorFlowのコードは、リトルエンディアンならgrpcioを依存パッケージに含めるという処理。\n setup.py  1 2 3 4 5  if sys.byteorder == \u0026#39;little\u0026#39;: # grpcio does not build correctly on big-endian machines due # to lack of BoringSSL support. # See \u0026lt;https://github.com/tensorflow/tensorflow/issues/17882\u0026gt;. REQUIRED_PACKAGES.append(\u0026#39;grpcio \u0026gt;= 1.8.6\u0026#39;)    エンディアンとは マルチバイトのデータをバイト単位に変換する方法で、ビッグエンディアン、リトルエンディアンがある。プロセッサによってエンディアンは異なり、AMD64だとリトルエンディアン、IBM S390Xだとビッグエンディアン、ARMはリトルエンディアンとビッグエンディアンを切替可能なバイエンディアンを採用している。 例えば、0x89ABCDEFで構成される4バイトデータを、メモリアドレス0x0010から0x0013の領域へ格納するときを考える。 ビッグエンディアンの場合、\n1 2 3 4  0x0010: 89 0x0011: AB 0x0012: CD 0x0013: EF   のように、下位アドレスに最上位バイトが格納される。 リトルエンディアンの場合、\n1 2 3 4  0x0010: EF 0x0011: CD 0x0012: AB 0x0013: 89   のように、上位アドレスに最上位バイトが格納される。\nなぜエンディアンチェックのコードがTensorFlowに含まれているのか TensorFlowはAMD64やARMに加えて、IBM S390X向けにもビルド済みバイナリを提供している。しかし、TensorFlowが依存するRPCフレームワークのgrpcioは、ビッグエンディアン向けに正しくビルドできないというバグがある。ビッグエンディアンのマシン上にgrpcioが導入されるのを回避するために、リトルエンディアンのマシンなら依存ライブラリにgrpcioも含める、というコードが記載されている。\n",date:"2018-12-17 Mon",permalink:"https://mshr-h.com/posts/what-is-byteorder/",title:"バイトオーダー(エンディアン)についてメモ"},{body:"TensorFlowをソースコードからビルドすると、PythonパッケージとしてTensorFlowのwhlファイルが作成される。このwhlファイルが依存するライブラリ一覧は、whlファイル内のMETADATAに記載されている。TensorFlow 1.12.0を対象に、実際にMETADATAファイルの中身を見てみた。\n 検証環境  Ubuntu 16.04 x86_64 Python 3.6.6  手順 適当なディレクトリを作成し、TensorFlowのwhlファイルをダウンロード、解凍。\n1 2 3  $ mkdir workspace; cd workspace $ pip3 download tensorflow==1.12.0 — no-deps $ unzip tensorflow-1.12.0-cp36-cp36m-manylinux1_x86_64.whl   解凍すると、以下の2つのディレクトリができあがる。\n1 2  tensorflow-1.12.0.data tensorflow-1.12.0.dist-info   tensorflow-1.12.0.dist-info/METADATAの中身は以下のようになっている。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48  Metadata-Version: 2.1 Name: tensorflow Version: 1.12.0 Summary: TensorFlow is an open source machine learning framework for everyone. Home-page: \u0026lt;https://www.tensorflow.org/\u0026gt; Author: Google Inc. Author-email: opensource@google.com License: Apache 2.0 Download-URL: \u0026lt;https://github.com/tensorflow/tensorflow/tags\u0026gt; Keywords: tensorflow tensor machine learning Platform: UNKNOWN Classifier: Development Status :: 5 — Production/Stable Classifier: Intended Audience :: Developers Classifier: Intended Audience :: Education Classifier: Intended Audience :: Science/Research Classifier: License :: OSI Approved :: Apache Software License Classifier: Programming Language :: Python :: 2 Classifier: Programming Language :: Python :: 2.7 Classifier: Programming Language :: Python :: 3 Classifier: Programming Language :: Python :: 3.4 Classifier: Programming Language :: Python :: 3.5 Classifier: Programming Language :: Python :: 3.6 Classifier: Topic :: Scientific/Engineering Classifier: Topic :: Scientific/Engineering :: Mathematics Classifier: Topic :: Scientific/Engineering :: Artificial Intelligence Classifier: Topic :: Software Development Classifier: Topic :: Software Development :: Libraries Classifier: Topic :: Software Development :: Libraries :: Python Modules Requires-Dist: absl-py (\u0026gt;=0.1.6) Requires-Dist: astor (\u0026gt;=0.6.0) Requires-Dist: gast (\u0026gt;=0.2.0) Requires-Dist: keras-applications (\u0026gt;=1.0.6) Requires-Dist: keras-preprocessing (\u0026gt;=1.0.5) Requires-Dist: numpy (\u0026gt;=1.13.3) Requires-Dist: six (\u0026gt;=1.10.0) Requires-Dist: protobuf (\u0026gt;=3.6.1) Requires-Dist: tensorboard (\u0026lt;1.13.0,\u0026gt;=1.12.0) Requires-Dist: termcolor (\u0026gt;=1.1.0) Requires-Dist: grpcio (\u0026gt;=1.8.6) Requires-Dist: wheel (\u0026gt;=0.26) TensorFlow is an open source software library for high performance numerical computation. Its flexible architecture allows easy deployment of computation across a variety of platforms (CPUs, GPUs, TPUs), and from desktops to clusters of servers to mobile and edge devices. Originally developed by researchers and engineers from the Google Brain team within Google’s AI organization, it comes with strong support for machine learning and deep learning and the flexible numerical computation core is used across many other scientific domains.   Requires-Dist:で始まる行が、Pythonパッケージが依存するライブラリを表している。TensorFlow 1.12.0の場合、以下のライブラリに依存していることが分かる。\n1 2 3 4 5 6 7 8 9 10 11 12  absl-py (\u0026gt;=0.1.6) astor (\u0026gt;=0.6.0) gast (\u0026gt;=0.2.0) keras-applications (\u0026gt;=1.0.6) keras-preprocessing (\u0026gt;=1.0.5) numpy (\u0026gt;=1.13.3) six (\u0026gt;=1.10.0) protobuf (\u0026gt;=3.6.1) tensorboard (\u0026lt;1.13.0,\u0026gt;=1.12.0) termcolor (\u0026gt;=1.1.0) grpcio (\u0026gt;=1.8.6) wheel (\u0026gt;=0.26)   以上で、TensorFlow 1.12.0のwhlファイルから、依存するライブラリ一覧を探すことができた。\n",date:"2018-12-16 Sun",permalink:"https://mshr-h.com/posts/%E3%81%82%E3%82%8Bpython%E3%83%91%E3%83%83%E3%82%B1%E3%83%BC%E3%82%B8%E3%81%8C%E4%BE%9D%E5%AD%98%E3%81%99%E3%82%8B%E3%83%A9%E3%82%A4%E3%83%96%E3%83%A9%E3%83%AA%E4%B8%80%E8%A6%A7%E3%82%92whl%E3%83%95%E3%82%A1%E3%82%A4%E3%83%AB%E3%81%8B%E3%82%89%E6%8E%A2%E3%81%99/",title:"あるPythonパッケージが依存するライブラリ一覧をwhlファイルから探す"},{body:"Ubuntu 18.04にibus-mozcをインストールしたところ、キーボード配列が日本語にならなかった。ibus-mozcの設定を書き換えると解決したので防備録。\n検証環境  Ubuntu 18.04 LTS ibus-mozc 2.20.2673.102  解決策 ibus-mozcの設定ファイルを開く。\n1  sudo vi /usr/share/ibus/component/mozc.xml   下から6行目のdefaultをjpに書き換える。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24  \u0026lt;component\u0026gt; \u0026lt;version\u0026gt;2.20.2673.102+dfsg-2\u0026lt;/version\u0026gt; \u0026lt;name\u0026gt;com.google.IBus.Mozc\u0026lt;/name\u0026gt; \u0026lt;license\u0026gt;New BSD\u0026lt;/license\u0026gt; \u0026lt;exec\u0026gt;/usr/lib/ibus-mozc/ibus-engine-mozc --ibus\u0026lt;/exec\u0026gt; \u0026lt;textdomain\u0026gt;ibus-mozc\u0026lt;/textdomain\u0026gt; \u0026lt;author\u0026gt;Google Inc.\u0026lt;/author\u0026gt; \u0026lt;homepage\u0026gt;\u0026lt;https://github.com/google/mozc\u0026gt;\u0026lt;/homepage\u0026gt; \u0026lt;description\u0026gt;Mozc Component\u0026lt;/description\u0026gt; \u0026lt;engines\u0026gt; \u0026lt;engine\u0026gt; \u0026lt;description\u0026gt;Mozc (Japanese Input Method)\u0026lt;/description\u0026gt; \u0026lt;language\u0026gt;ja\u0026lt;/language\u0026gt; \u0026lt;symbol\u0026gt;\u0026amp;#x3042;\u0026lt;/symbol\u0026gt; \u0026lt;rank\u0026gt;80\u0026lt;/rank\u0026gt; \u0026lt;icon_prop_key\u0026gt;InputMode\u0026lt;/icon_prop_key\u0026gt; \u0026lt;icon\u0026gt;/usr/share/ibus-mozc/product_icon.png\u0026lt;/icon\u0026gt; \u0026lt;setup\u0026gt;/usr/lib/mozc/mozc_tool --mode=config_dialog\u0026lt;/setup\u0026gt; \u0026lt;layout\u0026gt;default\u0026lt;/layout\u0026gt; \u0026lt;name\u0026gt;mozc-jp\u0026lt;/name\u0026gt; \u0026lt;longname\u0026gt;Mozc\u0026lt;/longname\u0026gt; \u0026lt;/engine\u0026gt; \u0026lt;/engines\u0026gt; \u0026lt;/component\u0026gt;   ログアウトし、再ログインするとキーボード配列が日本語になる。\n",date:"2018-06-04 Mon",permalink:"https://mshr-h.com/posts/ubuntu-18.04-lts%E3%81%A7ibus-mozc%E3%81%AE%E3%82%AD%E3%83%BC%E3%83%9C%E3%83%BC%E3%83%89%E9%85%8D%E5%88%97%E3%81%8C%E6%97%A5%E6%9C%AC%E8%AA%9E%E3%81%AB%E3%81%AA%E3%82%89%E3%81%AA%E3%81%84%E5%95%8F%E9%A1%8C%E3%81%A8%E8%A7%A3%E6%B1%BA%E6%96%B9%E6%B3%95/",title:"Ubuntu 18.04 LTSでibus-mozcのキーボード配列が日本語にならない問題と解決方法"},{body:" Masahiro Hiramori is a SAMURAI research engineer working for industrial company in Japan. My interest is how the computer works.\nInterests  Open source software Computer architecture TinyML Deep learning inference framework Deep learning compiler System/performance engineering Rock climbing  ",date:"0001-01-01 Mon",permalink:"https://mshr-h.com/about/",title:"About"},{body:"Curriculum Vitae Basic information  Name: Hiramori Masahiro (平森 将裕) E-mail: mhg00g13 at gmail.com  Please send text-only e-mail   Live in: Kanagawa, Japan Language  Japanese - Native proficiency English - Limited working proficiency   GitHub: mshr-h Twitter: mshrh3 Facebook: masahiro.hiramori LinkedIn: masahiro-hiramori-63b992167  Activities Projects  vscode-verilog-hdl-support  VS Code extension for Verilog HDL/SystemVerilog/Bluespec SystemVerilog support   motion_estimation_simulator  Motion estimation simulator written in C   fibonacci_verilog  Fibonacci number calcualtor cuicuit wirtten in Verilog-HDL   gomirror  Local directory mirroring tool written in Go   awesome-bouldering  A curated list of bouldering information    OSS Contributions  onnx/onnx-mlir  Commits list in GitHub   dense-analysis/ale  Commits list in GitHub   textmate/verilog.tmbundle  Commits list in GitHub   shinofara/stand  Commits list in GitHub    Employment  Research Engineer, Apr. 2017 - Present  Information Technology R\u0026amp;D Center, Mitsubishi Electric Corporation, Japan.    Education  M. S. in Information Science and Technology, Osaka Institute of Technology, Japan. Apr. 2015 - Mar. 2017 B. A. in Information Science and Technology, Osaka Institute of Technology, Japan. Apr. 2011 - Mar. 2015  Publications INTERNATIONAL CONFERENCES (REFEREED)  Masahiro Hiramori, Ryota Bandou, Shuhei Iwade, Hiroshi Makino, Tsutomu Yoshimura, Yoshio Matsuda. A study on fast motion estimation algorithm, In IEEE 5th Global Conference on Consumer Electronics, 2016. Ryota Bnadou, Masahiro Hiramori, Shuhei Iwade, Hiroshi Makino, Tutomu Yoshimura, Yoshio Matsuda. A study on motion estimation algorithm for moving pictures, In IEEE 5th Global Conference on Consumer Electronics, 2016.  DOMESTIC CONFERENCES \u0026amp; WORKSHOPS (NOT REFEREED)  平森 将裕, 出口 昌弘, 大木 英俊, 水口 武尚. 組込み向けディープラーニングフレームワークの評価, In 第 148 回 OS 研究会, 2020. 出口 昌弘，平森 将裕，水口 武尚. 組み込み機器適用のためのディープラーニングフレームワーク使用リソース調査と評価, In 第 145 回 OS 研究会, 2019. 平森 将裕, 攝津 敦. 組込み機器に向けたCaffeの性能評価, In ETNET, 2018. 阪東亮太, 平森将裕, 岩出秀平, 牧野博之, 布村泰浩, 吉村 勉, 松田吉雄. 動画像における動きベクトル検出手法の検討 ―4画素精度動き補償の評価 ―, In 画像関連学会連合会第二回秋季大会プログラム, 2015. 平森将裕, 大加茂祐輔, 岩出秀平, 牧野博之, 吉村勉, 松田吉雄. 動きベクトル探索の高速化手法の改善（その1）～比較画素単位での評価ビットシフト法, In 電気関係学会 関西支部連合大会, 講演論文集, 2014. 大加茂祐輔, 平森将裕, 岩出秀平, 牧野博之, 吉村勉, 松田吉雄. 動きベクトル探索の高速化手法に関する一検討, In 電気関係学会関西支部連合大会 講演論文集, 2014.  Skills Programming  Competent  C (10+ years)   Profound  Python 3 (5+ years)  Python - C/C++ interoperation PyBind11   C++ 11 (2+ years) Go (3+ years)    Machine learning  ONNX Runtime/ONNX-MLIR TVM TensorFlow/TensorFlow Lite Caffe  Version control  Git/GitHub  Development tools  VS Code/Vim/Emacs Makefile/CMake Docker/chroot/qemu gdb Visual Studio GitHub Actions/Travis CI  Embedded systems  ROS Yocto/Bitbake ARM Cortex-M4 Realtime OS H8/3069F  Hardware development  FPGA/Quartus II/Verilog-HDL  Built a full scratch 16-bit RISC CPU Built a video compression hardware  mshr-h/motion_estimation_processor_fullsearch      Web development  Next.js  My previous website was based on Next.js+Vercel+Notion    Operating systems  Windows  Mostly use for writing Word/Excel/PowerPoint documents   Linux  My main working machine is Ubuntu   macOS  My personal Laptop    Certifications  TOEIC Listening \u0026amp; Reading score 840 | May 2017 TOEIC Speaking \u0026amp; Writing score 290 (Speaking: 130/200, Writing: 160/200) | Aug 2020 Embedded Systems Specialist Examination (エンベデッドシステムスペシャリスト試験) | June 2015 Information Security Specialist Examination (情報セキュリティスペシャリスト試験) | Dec 2014  ",date:"0001-01-01 Mon",permalink:"https://mshr-h.com/cv/",title:"Curriculum Vitae"}]